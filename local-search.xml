<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go开发常用命令</title>
    <link href="/2023/05/06/Go%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/05/06/Go%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Go开发常用命令"><a href="#Go开发常用命令" class="headerlink" title="Go开发常用命令"></a>Go开发常用命令</h2><h3 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h3><h4 id="Mac-下编译，-Linux-或者-Windows-下执行"><a href="#Mac-下编译，-Linux-或者-Windows-下执行" class="headerlink" title="Mac 下编译， Linux 或者 Windows 下执行"></a>Mac 下编译， Linux 或者 Windows 下执行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">linux 下执行</span><br>CGO_ENABLED=0  GOOS=linux  GOARCH=amd64  go build main.go<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Windows 下执行</span><br>CGO_ENABLED=0 GOOS=windows  GOARCH=amd64  go  build  main.go<br></code></pre></td></tr></table></figure><h4 id="Linux-下编译-，-Mac-或者-Windows-下执行"><a href="#Linux-下编译-，-Mac-或者-Windows-下执行" class="headerlink" title="Linux 下编译 ， Mac 或者 Windows 下执行"></a>Linux 下编译 ， Mac 或者 Windows 下执行</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Mac  下执行</span><br>CGO_ENABLED=0 GOOS=darwin  GOARCH=amd64  go build main.go<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Windows 下执行</span><br>CGO_ENABLED=0 GOOS=windows  GOARCH=amd64  go build main.go<br></code></pre></td></tr></table></figure><h4 id="Windows-下执行-，-Mac-或-Linux-下执行"><a href="#Windows-下执行-，-Mac-或-Linux-下执行" class="headerlink" title="Windows 下执行 ， Mac 或 Linux 下执行"></a>Windows 下执行 ， Mac 或 Linux 下执行</h4><p>需要写一个批处理程序，在里面去设置，因为windows 下的 terminal 不支持shell , 这跟 Mac 和 Linux下的有点不同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Mac 下执行</span><br>SET  CGO_ENABLED=0<br>SET GOOS=darwin<br>SET GOARCH=amd64<br>go build main.go<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Linux 去执行</span><br>SET CGO_ENABLED=0<br>SET GOOS=linux<br>SET GOARCH=amd64<br>go build main.go<br></code></pre></td></tr></table></figure><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li><strong>CGO_ENABLED</strong> : CGO 表示golang中的工具，CGO_ENABLED 表示CGO禁用，交叉编译中不能使用CGO的</li><li><strong>GOOS</strong> : 目标平台<ul><li>mac 对应  <strong>darwin</strong></li><li>linux 对应 <strong>linux</strong></li><li>windows 对应 <strong>windows</strong></li></ul></li><li><strong>GOARCH</strong> ：目标平台的体系架构【386，amd64,arm】, 目前市面上的个人电脑一般都是amd64架构的<ul><li>386 也称 x86 对应  32位操作系统</li><li>amd64 也称 x64 对应 64位操作系统</li><li>arm 这种架构一般用于嵌入式开发。 比如 Android ， IOS ， Win mobile , TIZEN 等</li></ul></li></ul><h4 id="linux-或者-Mac下-go-build-前面的参数为何需要那样设置？"><a href="#linux-或者-Mac下-go-build-前面的参数为何需要那样设置？" class="headerlink" title="linux 或者 Mac下 go build 前面的参数为何需要那样设置？"></a>linux 或者 Mac下 go build 前面的参数为何需要那样设置？</h4><p><strong>go env</strong> 可以列出我们的 golang 默认环境变量，在shell中当我们只想一次性更改其环境变量时，就可以通过在 shell 中设置变量的方式来更改这个环境变量。</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用JWT进行身份验证</title>
    <link href="/2023/04/24/%E4%BD%BF%E7%94%A8JWT%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/"/>
    <url>/2023/04/24/%E4%BD%BF%E7%94%A8JWT%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h2 id="Go使用JWT进行身份验证"><a href="#Go使用JWT进行身份验证" class="headerlink" title="Go使用JWT进行身份验证"></a>Go使用JWT进行身份验证</h2><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><h3 id="1-1-JSON-Web-Token"><a href="#1-1-JSON-Web-Token" class="headerlink" title="1.1 JSON Web Token"></a>1.1 JSON Web Token</h3><p><code>jwt</code> 是 <code>json web token</code> 的简称。</p><p>JSON Web Token (JWT) 是一种开放标准 ( <a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a> )，它定义了一种紧凑且独立的方式，用于在各方之间安全地传输信息作为 JSON 对象。此信息可以被验证和信任，因为它是经过数字签名的。JWT 可以使用密码（使用<strong>HMAC</strong>算法）或使用<strong>RSA</strong>或<strong>ECDSA</strong>的公钥&#x2F;私钥对进行签名。</p><h3 id="1-2-JWT-的使用场景"><a href="#1-2-JWT-的使用场景" class="headerlink" title="1.2 JWT 的使用场景"></a>1.2 JWT 的使用场景</h3><ul><li><strong>授权</strong>：这是使用 JWT 最常见的场景。用户登录后，每个后续请求都将包含 JWT，允许用户访问该令牌允许的路由、服务和资源。单点登录是如今广泛使用 JWT 的一项功能，因为它的开销很小并且能够轻松跨不同域使用。</li><li><strong>信息交换</strong>：JSON Web Tokens 是在各方之间安全传输信息的好方法。因为 JWT 可以签名——例如，使用公钥&#x2F;私钥对——你可以确定发送者是他们所说的人。此外，由于签名是使用标头和有效负载计算的，因此还可以验证内容是否未被篡改。</li></ul><h3 id="1-3-JWT-的结构"><a href="#1-3-JWT-的结构" class="headerlink" title="1.3 JWT 的结构"></a>1.3 JWT 的结构</h3><p>JWT 由三部分组成，由点 ( <code>.</code>) 分隔，它们是：</p><ul><li>Header（标头）</li><li>Payload（有效载荷）</li><li>Signature（签名）</li></ul><p>JWT通常如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">xxxxx<span class="hljs-selector-class">.yyyyy</span>.zzzzz<br></code></pre></td></tr></table></figure><h4 id="1-3-1-Header"><a href="#1-3-1-Header" class="headerlink" title="1.3.1 Header"></a>1.3.1 Header</h4><p><code>Header</code> <strong>通常</strong>由两部分组成：令牌的类型，即 JWT，以及所使用的签名算法，例如 <code>HMAC SHA256</code> 或  <code>RSA</code>。</p><p>例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后，这个 JSON 被 <strong><code>Base64Url</code></strong> 编码以形成 JWT 的第一部分。</p><h4 id="1-3-2-Payload"><a href="#1-3-2-Payload" class="headerlink" title="1.3.2 Payload"></a>1.3.2 Payload</h4><p><code>token</code> 的第二部分是Payload，由 <code>claims</code> 组成。</p><p><code>claims</code> 关于实体（通常是用户）和附加数据的描述。</p><p><code>claims</code> 分为三种类型：</p><p><strong><code>registered claims（注册声明）</code></strong></p><p> <strong><code>public claims（公共声明）</code></strong></p><p> <strong><code>private claims（隐私声明）</code></strong> </p><ul><li><p><a href="https://tools.ietf.org/html/rfc7519#section-4.1"><strong>registered claims（已注册声明）</strong></a>：这这些是一组预定义的声明，它们不是强制性的，但建议使用，以提供一组有用的、可互操作的声明。其中一些是： <strong>iss</strong>（发行者）、 <strong>exp</strong>（到期时间）、 <strong>sub</strong>（主题）、 <strong>aud</strong>（受众）和<a href="https://tools.ietf.org/html/rfc7519#section-4.1">其他</a>。</p></li><li><p><a href="https://tools.ietf.org/html/rfc7519#section-4.2"><strong>public claims（公共声明）</strong></a>：这些可以由使用 JWT 的人随意定义。但是为了避免冲突，它们应该在<a href="https://www.iana.org/assignments/jwt/jwt.xhtml">IANA JSON Web 令牌注册表</a>中定义，或者定义为包含抗冲突名称空间的 URI。</p></li><li><p><a href="https://tools.ietf.org/html/rfc7519#section-4.3"><strong>private claims（隐私声明）</strong></a>：这些是为在同意使用它们的各方之间共享信息而创建的自定义声明，既不是注册声明也不是公共声明。</p></li></ul><p>一个有效的Payload应该是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;admin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>然后，有效负载经过 <strong><code>Base64Url</code></strong> 编码，形成 JWT 的第二部分。</p><h4 id="1-3-3-Signature"><a href="#1-3-3-Signature" class="headerlink" title="1.3.3 Signature"></a>1.3.3 Signature</h4><p>要创建签名部分，必须采用编码Header、编码Payload、 <code>secret</code> 、指定的算法，然后对其进行签名。</p><p>例如，如果要使用 HMAC SHA256 算法，将按以下方式创建签名：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">HMACSHA256(<br>  <span class="hljs-name">base64UrlEncode</span>(<span class="hljs-name">header</span>) + <span class="hljs-string">&quot;.&quot;</span> +<br>  base64UrlEncode(<span class="hljs-name">payload</span>),<br>  secret)<br></code></pre></td></tr></table></figure><p>签名用于验证消息在此过程中没有被更改，并且在使用私钥签名的令牌的情况下，它还可以验证 JWT 的发送者是否如其所说。</p><h4 id="1-3-4-组合-Header、Payload、Signature"><a href="#1-3-4-组合-Header、Payload、Signature" class="headerlink" title="1.3.4 组合 Header、Payload、Signature"></a>1.3.4 组合 Header、Payload、Signature</h4><p>输出由点分隔的三个 Base64-URL 字符串，可以在 HTML 和 HTTP 环境中轻松传递，同时与基于 XML 的标准（如 SAML）相比更加紧凑。</p><p>下面显示了一个 JWT，它对前面的标头和有效负载进行了编码，并使用私钥进行了签名。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">eyJhbGci<span class="hljs-number">0</span>iJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiIsInR5</span>cCI<span class="hljs-number">6</span>IkpX<span class="hljs-attr">VCJ9</span>.<br>eyJzdWIi<span class="hljs-number">0</span>iIxMiMO<span class="hljs-symbol">NTY30</span>DkwIiwibmFtZSI<span class="hljs-number">6</span>Ikpva<span class="hljs-name">G4</span><br>gR<span class="hljs-name">G91</span>IiwiaX<span class="hljs-symbol">NTb2</span><span class="hljs-symbol">NpYWwi0</span><span class="hljs-symbol">nRydWV9</span>.<br><span class="hljs-number">4</span>pcPMD<span class="hljs-number">0901</span>PSyX<span class="hljs-symbol">nrXCiTwXyr4</span>BsezdI<span class="hljs-number">1</span>AVTmud<span class="hljs-number">2</span>fU<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>目前， <code>Go</code> 主流使用的 <code>jwt</code> 库是 <code>golang-jwt/jwt</code> 。</p><h3 id="1-4-JWT-如何工作？"><a href="#1-4-JWT-如何工作？" class="headerlink" title="1.4 JWT 如何工作？"></a>1.4 JWT 如何工作？</h3><p>在身份验证中，当用户使用其身份成功登录时，将返回一个 JSON Web Token。由于 token 是凭据，因此必须非常小心以防止出现安全问题。通常，不应该将令牌保留的时间超过要求的时间。</p><p>每当用户想要访问受保护的路由或资源时，用户代理都应发送 JWT，通常使用在 <strong>Bearer模式的Authorization</strong> 标头中。标头的内容应如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">Authorization: Bearer <span class="hljs-tag">&lt;<span class="hljs-name">token</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在某些情况下，可以是无状态授权机制。服务器的受保护路由将检查标头中是否存在有效的 JWT <code>Authorization</code>，如果存在，则允许用户访问受保护的资源。如果 JWT 包含必要的数据，则可能会减少为某些操作查询数据库的需要。</p><p>使用 HTTP 标头发送 JWT ，需要尽量防止它们太大。有些服务器不接受超过 8 KB 的标头。试图在 JWT 令牌中嵌入过多信息，例如通过包含所有用户的权限，需要寻找替代解决方案，例如<a href="https://fga.dev/">Auth0 Fine-Grained Authorization</a>。</p><p>如果 token 在 <code>Authorization</code> 标头中发送，跨源资源共享 (CORS) 将不会成为问题，因为它不使用 cookie。</p><h3 id="1-5-JWT-的优势"><a href="#1-5-JWT-的优势" class="headerlink" title="1.5 JWT 的优势"></a>1.5 JWT 的优势</h3><p><strong>JSON Web Tokens (JWT)</strong> 与 <strong>Simple Web Tokens (SWT)</strong> 和 <strong>Security Assertion Markup Language Tokens (SAML)</strong> 相比的优势：</p><p>由于 JSON 比 XML 更简洁，因此在编码时它的大小也更小，使 JWT 比 SAML 更紧凑。这使得 JWT 成为在 HTML 和 HTTP 环境中传递的不错选择。</p><p>安全方面，SWT 只能通过使用 HMAC 算法的共享密钥进行对称签名。但是，JWT 和 SAML 令牌可以使用 X.509 证书形式的公钥&#x2F;私钥对进行签名。与签署 JSON 的简单性相比，使用 XML 数字签名签署 XML 而不会引入模糊的安全漏洞是非常困难的。</p><p>JSON 解析器在大多数编程语言中都很常见，因为它们直接映射到对象。相反，XML 没有自然的文档到对象的映射。这使得使用 JWT 比使用 SAML 断言更容易。</p><p>关于使用，JWT 用于互联网规模。这凸显了客户端在多个平台（尤其是移动平台）上处理 JSON Web 令牌的便利性。</p><h2 id="二、golang-jwt-x2F-jwt"><a href="#二、golang-jwt-x2F-jwt" class="headerlink" title="二、golang-jwt&#x2F;jwt"></a>二、golang-jwt&#x2F;jwt</h2><h3 id="安装jwt包"><a href="#安装jwt包" class="headerlink" title="安装jwt包"></a>安装jwt包</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/golang-jwt/jwt/v5<br></code></pre></td></tr></table></figure><h3 id="主流的两种加密算法"><a href="#主流的两种加密算法" class="headerlink" title="主流的两种加密算法"></a>主流的两种加密算法</h3><table><thead><tr><th align="left">加密算法</th><th>代表算法</th><th>加解密</th><th>区别</th></tr></thead><tbody><tr><td align="left">对称加密算法</td><td>HS256（最常用）、HS384、HS512</td><td>期望[]byte用于签名和验证的值</td><td>签名和验证密钥是相同的，两者必须受到同等保护（并且绝对不应该存储在您的代码中）</td></tr><tr><td align="left">非对称加密算法</td><td>RS256（最常用）、RS384、RS512</td><td>rsa.PrivateKey用于签名和*rsa.PublicKey用于验证</td><td>私钥（必须保密）用于签名，相应的公钥（可以自由传输）用于<em>验证</em>令牌。</td></tr></tbody></table><h2 id="三、代码实现-对称加密hsa（hash加密）"><a href="#三、代码实现-对称加密hsa（hash加密）" class="headerlink" title="三、代码实现-对称加密hsa（hash加密）"></a>三、代码实现-对称加密hsa（hash加密）</h2><h3 id="3-1-加密生成-token"><a href="#3-1-加密生成-token" class="headerlink" title="3.1 加密生成 token"></a>3.1 加密生成 token</h3><p>使用 <code>jwt.NewWithClaims()</code> 方法来生成<code>token</code>，官方的源码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewWithClaims</span><span class="hljs-params">(method SigningMethod, claims Claims, opts ...TokenOption)</span></span> *Token &#123;<br><span class="hljs-keyword">return</span> &amp;Token&#123;<br>Header: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;&#123;<br><span class="hljs-string">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span>,<br><span class="hljs-string">&quot;alg&quot;</span>: method.Alg(),<br>&#125;,<br>Claims: claims,<br>Method: method,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-生成token并使用hs256加密方法进行加密"><a href="#3-2-生成token并使用hs256加密方法进行加密" class="headerlink" title="3.2 生成token并使用hs256加密方法进行加密"></a>3.2 生成token并使用hs256加密方法进行加密</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    ID     <span class="hljs-type">int64</span><br>    Name   <span class="hljs-type">string</span><br>    Age    <span class="hljs-type">int</span><br>    Gender <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> UserClaims <span class="hljs-keyword">struct</span> &#123;<br>    User User<br>    jwt.RegisteredClaims<br>&#125;<br><br><span class="hljs-comment">// CreateHs256Token 生成一个token并使用hs256加密方法进行加密</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateHs256Token</span><span class="hljs-params">()</span></span> &#123;<br>    user := User&#123;<br>        ID:     <span class="hljs-number">1</span>,<br>        Name:   <span class="hljs-string">&quot;LiHua&quot;</span>,<br>        Age:    <span class="hljs-number">18</span>,<br>        Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>    &#125;<br>    fmt.Println(user)<br>    userClaims := UserClaims&#123;<br>        User:             user,<br>        RegisteredClaims: jwt.RegisteredClaims&#123;&#125;,<br>    &#125;<br>    token := jwt.NewWithClaims(jwt.SigningMethodHS256, userClaims)<br><br>    hs256Token, err := token.SignedString([]<span class="hljs-type">byte</span>(common.PriKey))<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error: &quot;</span>, err)<br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;hs256: &quot;</span>, hs256Token)<br>    ParseHs256Token(hs256Token)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-解密token得到原始数据"><a href="#3-3-解密token得到原始数据" class="headerlink" title="3.3 解密token得到原始数据"></a>3.3 解密token得到原始数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ParseHs256Token 解析hs256加密方法加密的token</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseHs256Token</span><span class="hljs-params">(hs256Token <span class="hljs-type">string</span>)</span></span> &#123;<br>    token, err := jwt.ParseWithClaims(hs256Token, &amp;UserClaims&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *jwt.Token)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><br>        <span class="hljs-keyword">return</span> []<span class="hljs-type">byte</span>(common.PriKey), <span class="hljs-literal">nil</span><br>    &#125;)<br>    <span class="hljs-keyword">if</span> userClaims, ok := token.Claims.(*UserClaims); ok &amp;&amp; token.Valid &#123;<br>        fmt.Println(userClaims, userClaims.RegisteredClaims.Issuer)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(err)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、代码实现-非对称加密-rsa（rs256加密）"><a href="#四、代码实现-非对称加密-rsa（rs256加密）" class="headerlink" title="四、代码实现-非对称加密 rsa（rs256加密）"></a>四、代码实现-非对称加密 rsa（rs256加密）</h2><h3 id="4-1-生成-rsa-私钥和公钥"><a href="#4-1-生成-rsa-私钥和公钥" class="headerlink" title="4.1 生成 rsa 私钥和公钥"></a>4.1 生成 rsa 私钥和公钥</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">生成私钥<br>openssl genrsa -out private-key.pem<br>生成公钥<br>openssl rsa -in private-key.pem -pubout -out public-key.pem<br></code></pre></td></tr></table></figure><h3 id="4-2-生成token并使用rs256加密方法进行加密"><a href="#4-2-生成token并使用rs256加密方法进行加密" class="headerlink" title="4.2 生成token并使用rs256加密方法进行加密"></a>4.2 生成token并使用rs256加密方法进行加密</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CreateRs256Token 生成一个token并使用rs256加密方法进行加密</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateRs256Token</span><span class="hljs-params">()</span></span> &#123;<br>    user := User&#123;<br>        ID:     <span class="hljs-number">2</span>,<br>        Name:   <span class="hljs-string">&quot;Lisa&quot;</span>,<br>        Gender: <span class="hljs-string">&quot;女&quot;</span>,<br>    &#125;<br>    userClaims := UserClaims&#123;<br>        User:             user,<br>        RegisteredClaims: jwt.RegisteredClaims&#123;&#125;,<br>    &#125;<br>    privateKeyDataPem, err := os.ReadFile(<span class="hljs-string">&quot;key/private-key.pem&quot;</span>)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    privateKey, err := jwt.ParseRSAPrivateKeyFromPEM(privateKeyDataPem)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    token := jwt.NewWithClaims(jwt.SigningMethodRS256, userClaims)<br><br>    rs256Token, err := token.SignedString(privateKey)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Println(<span class="hljs-string">&quot;rsa256: &quot;</span>, rs256Token)<br>    ParseRs256Token(rs256Token)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-解密token得到原始数据"><a href="#4-3-解密token得到原始数据" class="headerlink" title="4.3 解密token得到原始数据"></a>4.3 解密token得到原始数据</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ParseRs256Token 解析rs256加密方法加密的的token</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseRs256Token</span><span class="hljs-params">(rs256Token <span class="hljs-type">string</span>)</span></span> &#123;<br>    token, err := jwt.ParseWithClaims(rs256Token, &amp;UserClaims&#123;&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *jwt.Token)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>        publicKeyDataPem, err := os.ReadFile(<span class="hljs-string">&quot;key/public-key.pem&quot;</span>)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Error: &quot;</span>, err)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>        &#125;<br>        <span class="hljs-keyword">return</span> jwt.ParseRSAPublicKeyFromPEM(publicKeyDataPem)<br>    &#125;)<br><br>    <span class="hljs-keyword">if</span> userClaims, ok := token.Claims.(*UserClaims); ok &amp;&amp; token.Valid &#123;<br>        fmt.Println(userClaims, userClaims.RegisteredClaims.Issuer)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;Errors: &quot;</span>, err.Error())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="HTTPS-的加密流程"><a href="#HTTPS-的加密流程" class="headerlink" title="HTTPS 的加密流程"></a>HTTPS 的加密流程</h2><p>HTTPS 组合使用了对称加密和非对称加密</p><p>服务端生成了一对公钥和私钥，把公钥和证书发给客户端<br>客户端验证了证书真伪<br>客户端生成一个随机值，用公钥加密发给了服务端<br>服务端用私钥解密，获取了随机值<br>服务端使用该随机值作为密钥和客户端进通信</p><p>服务端的公钥和私钥就是非对称加密，客户端生成的随机值作为密钥来通信就是对称加密</p>]]></content>
    
    
    <categories>
      
      <category>token身份验证</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>jwt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用类型转换</title>
    <link href="/2023/04/21/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/04/21/%E5%B8%B8%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="Go中常用的类型转换方法"><a href="#Go中常用的类型转换方法" class="headerlink" title="Go中常用的类型转换方法"></a>Go中常用的类型转换方法</h2><h3 id="int-类型之间的相互转换"><a href="#int-类型之间的相互转换" class="headerlink" title="int 类型之间的相互转换"></a>int 类型之间的相互转换</h3><h4 id="int-和-int64-互转"><a href="#int-和-int64-互转" class="headerlink" title="int 和 int64 互转"></a>int 和 int64 互转</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// int 转 int64</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span> = <span class="hljs-number">97</span><br>m := <span class="hljs-type">int64</span>(n)<br><br><span class="hljs-comment">// int64 转 int</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int64</span> = <span class="hljs-number">97</span><br>m := <span class="hljs-type">int</span>(n)<br></code></pre></td></tr></table></figure><h4 id="int-和-uint64-互转"><a href="#int-和-uint64-互转" class="headerlink" title="int 和 uint64 互转"></a>int 和 uint64 互转</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// int 转 uint64</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span> = <span class="hljs-number">97</span><br>m := <span class="hljs-type">uint64</span>(n)<br><br><span class="hljs-comment">// uint64 转 int</span><br><span class="hljs-keyword">var</span> n <span class="hljs-type">uint64</span> = <span class="hljs-number">97</span><br>m := <span class="hljs-type">int</span>(n)<br></code></pre></td></tr></table></figure><h3 id="int-与-float64-类型的相互转换"><a href="#int-与-float64-类型的相互转换" class="headerlink" title="int 与 float64 类型的相互转换"></a>int 与 float64 类型的相互转换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// int 转 float64</span><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br>f := <span class="hljs-type">float64</span>(i)   <br><br><span class="hljs-comment">// float64 转 int</span><br><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> <span class="hljs-number">12.12</span><br>i := <span class="hljs-type">int</span>(f)<br></code></pre></td></tr></table></figure><h3 id="字符串与其它类型相互转换"><a href="#字符串与其它类型相互转换" class="headerlink" title="字符串与其它类型相互转换"></a>字符串与其它类型相互转换</h3><p><strong>与字符串相关的类型转换都是通过 <code>strconv</code> 包实现的</strong></p><h4 id="strconv-IntSize"><a href="#strconv-IntSize" class="headerlink" title="strconv.IntSize"></a>strconv.IntSize</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">strconv.IntSize<br><br><span class="hljs-keyword">const</span> strconv.IntSize untyped <span class="hljs-type">int</span> = <span class="hljs-number">64</span>  <span class="hljs-comment">// 64 位系统</span><br><span class="hljs-comment">// 获取程序运行的操作系统平台下 int 类型所占的位数</span><br></code></pre></td></tr></table></figure><h4 id="int-转-string"><a href="#int-转-string" class="headerlink" title="int 转 string"></a>int 转 string</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strconv</span>.<span class="hljs-title">Itoa</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 返回数字 i 所表示的字符串类型的十进制数</span><br></code></pre></td></tr></table></figure><h4 id="float64-转-string"><a href="#float64-转-string" class="headerlink" title="float64 转 string"></a>float64 转 string</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strconv</span>.<span class="hljs-title">FormatFloat</span><span class="hljs-params">(f <span class="hljs-type">float64</span>, fmt <span class="hljs-type">byte</span>, prec <span class="hljs-type">int</span>, bitSize <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 将 64 位浮点型的数字转换为字符串，其中 fmt 表示格式（其值可以是 &#x27;b&#x27;、&#x27;e&#x27;、&#x27;f&#x27; 或 &#x27;g&#x27;），prec 表示精度，bitSize 则使用 32 表示 float32，用 64 表示 float64</span><br></code></pre></td></tr></table></figure><h4 id="string-转-int"><a href="#string-转-int" class="headerlink" title="string 转 int"></a>string 转 int</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strconv</span>.<span class="hljs-title">Atoi</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>)<br><span class="hljs-comment">// 将字符串转换为 int 型</span><br></code></pre></td></tr></table></figure><h4 id="string-转-float64"><a href="#string-转-float64" class="headerlink" title="string 转 float64"></a>string 转 float64</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strconv</span>.<span class="hljs-title">ParseFloat</span><span class="hljs-params">(s <span class="hljs-type">string</span>, bitSize <span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">float64</span>, <span class="hljs-type">error</span>)<br><span class="hljs-comment">// 将字符串转换为 float64 型</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串处理</title>
    <link href="/2023/04/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <url>/2023/04/20/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Go中常用的字符串处理方法"><a href="#Go中常用的字符串处理方法" class="headerlink" title="Go中常用的字符串处理方法"></a>Go中常用的字符串处理方法</h2><h3 id="strings-Split"><a href="#strings-Split" class="headerlink" title="strings.Split"></a>strings.Split</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strings</span>.<span class="hljs-title">Split</span><span class="hljs-params">(s <span class="hljs-type">string</span>, sep <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span><br><span class="hljs-comment">// 将切片 s 拆分为所有由 sep 分隔的子字符串，并返回这些分隔符之间的子字符串切片。</span><br><span class="hljs-comment">// 如果 sep 为空，返回 UTF-8 字符数组。</span><br><span class="hljs-comment">// strings.Split(&quot;abc&quot;,&quot;&quot;) =&gt; [a b c]</span><br></code></pre></td></tr></table></figure><h3 id="strings-Fields"><a href="#strings-Fields" class="headerlink" title="strings.Fields"></a>strings.Fields</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fields</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span><br><span class="hljs-comment">// 返回一个用一个或多个连续的空格分隔的字符串 s 的子字符串的数组（slice），返回的数组中不含有空格</span><br><span class="hljs-comment">// strings.Fields(&quot;  abc def  gh i  jk  &quot;) =&gt; [&quot;abc&quot;,&quot;def&quot;,&quot;gh&quot;,&quot;i&quot;,&quot;jk&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="strings-FieldsFunc"><a href="#strings-FieldsFunc" class="headerlink" title="strings.FieldsFunc"></a>strings.FieldsFunc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Unicode 代码点 c 进行分隔：满足 f(c) 返回 true。该函数返回[]string。如果字符串 s 中所有的代码点 (unicode code points) 都满足 f(c) 或者 s 是空，则 FieldsFunc 返回空 slice。</span><br><br><span class="hljs-comment">// 示例</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;ahbhchdhehfh&quot;</span><br>fmt.Println(strings.FieldsFunc(str, cs)) <span class="hljs-comment">// =&gt; [a b c d e f]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cs</span><span class="hljs-params">(c <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> c == <span class="hljs-string">&#x27;h&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="strings-Contains、strings-ContainsAny、strings-ContainsRune"><a href="#strings-Contains、strings-ContainsAny、strings-ContainsRune" class="headerlink" title="strings.Contains、strings.ContainsAny、strings.ContainsRune"></a>strings.Contains、strings.ContainsAny、strings.ContainsRune</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(s, substr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-comment">// 判断字符串 s 中是否含有 substr 字符</span><br><span class="hljs-comment">// strings.Contains(&quot;abc&quot;,&quot;a&quot;) =&gt; true</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ContainsAny</span><span class="hljs-params">(s, chars <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-comment">// chars 中任何一个 Unicode 代码点在 s 中，返回 true</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ContainsRune</span><span class="hljs-params">(s <span class="hljs-type">string</span>, r <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-comment">// Unicode 代码点 r 在 s 中，返回 true</span><br></code></pre></td></tr></table></figure><h3 id="strings-Replace"><a href="#strings-Replace" class="headerlink" title="strings.Replace"></a>strings.Replace</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">strings</span>.<span class="hljs-title">Replace</span><span class="hljs-params">(s <span class="hljs-type">string</span>, old <span class="hljs-type">string</span>, <span class="hljs-built_in">new</span> <span class="hljs-type">string</span>, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 返回 s 的副本，使用 new 替换前 n 个 old 字符（如果 n&lt;0，则替换没有次数限制）</span><br><span class="hljs-comment">// strings.Replace(&quot;abc&quot;,&quot;b&quot;,&quot;d&quot;,-1) =&gt; adc</span><br></code></pre></td></tr></table></figure><h3 id="strings-HasPrefix、strings-HasSuffix"><a href="#strings-HasPrefix、strings-HasSuffix" class="headerlink" title="strings.HasPrefix、strings.HasSuffix"></a>strings.HasPrefix、strings.HasSuffix</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s <span class="hljs-type">string</span>, prefix <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-comment">// 判断字符串 s 是否以 prefix 开头</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasSuffix</span><span class="hljs-params">(s <span class="hljs-type">string</span>, suffix <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-comment">// 判断字符串 s 是否以 suffix 结尾</span><br></code></pre></td></tr></table></figure><h3 id="strings-Index、strings-LastIndex、strings-IndexRune"><a href="#strings-Index、strings-LastIndex、strings-IndexRune" class="headerlink" title="strings.Index、strings.LastIndex、strings.IndexRune"></a>strings.Index、strings.LastIndex、strings.IndexRune</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(s <span class="hljs-type">string</span>, substr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-comment">// 返回字符串 str 在字符串 s 中第一次出现的索引（str 的第一个字符的索引），-1 表示字符串 s 不包含字符串 str</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LastIndex</span><span class="hljs-params">(s <span class="hljs-type">string</span>, substr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-comment">// 返回字符串 str 在字符串 s 中最后出现位置的索引</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IndexRune</span><span class="hljs-params">(s <span class="hljs-type">string</span>, r <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-comment">// 查询非 ASCII 编码的字符在父字符串中的位置</span><br></code></pre></td></tr></table></figure><h3 id="strings-Count"><a href="#strings-Count" class="headerlink" title="strings.Count"></a>strings.Count</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Count</span><span class="hljs-params">(s <span class="hljs-type">string</span>, substr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-comment">// 计算字符串 str 在字符串 s 中出现的非重叠次数</span><br></code></pre></td></tr></table></figure><h3 id="strings-ToLower、strings-ToUpper"><a href="#strings-ToLower、strings-ToUpper" class="headerlink" title="strings.ToLower、strings.ToUpper"></a>strings.ToLower、strings.ToUpper</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ToUpper</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 将字符串中的 Unicode 字符全部转换为相应的小写字符</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ToUpper</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 将字符串中的 Unicode 字符全部转换为相应的大写字符</span><br></code></pre></td></tr></table></figure><h3 id="strings-Trim、strings-TrimSpace、TrimLeft、TrimRight"><a href="#strings-Trim、strings-TrimSpace、TrimLeft、TrimRight" class="headerlink" title="strings.Trim、strings.TrimSpace、TrimLeft、TrimRight"></a>strings.Trim、strings.TrimSpace、TrimLeft、TrimRight</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Trim</span><span class="hljs-params">(s <span class="hljs-type">string</span>, cutset <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 剔除字符串 s 中的指定字符 cutset</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TrimSpace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 剔除字符串 s 开头和结尾的空白符号</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TrimLeft</span><span class="hljs-params">(s <span class="hljs-type">string</span>, cutset <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 剔除字符串 s 开头的指定字符 cutset</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TrimRight</span><span class="hljs-params">(s <span class="hljs-type">string</span>, cutset <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 剔除字符串 s 结尾的指定字符 cutset</span><br></code></pre></td></tr></table></figure><h3 id="strings-Join"><a href="#strings-Join" class="headerlink" title="strings.Join"></a>strings.Join</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Join</span><span class="hljs-params">(elems []<span class="hljs-type">string</span>, sep <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// 使用分割字符 sep 将 string类型的 切片 elems 拼接成一个字符串</span><br></code></pre></td></tr></table></figure><h3 id="strings-NewReader"><a href="#strings-NewReader" class="headerlink" title="strings.NewReader"></a>strings.NewReader</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReader</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> *strings.Reader<br><span class="hljs-comment">// 用于生成一个 Reader 并读取字符串中的内容，然后返回指向该 Reader 的指针</span><br><br><span class="hljs-comment">// Read() 从 []byte 中读取内容。</span><br><span class="hljs-comment">// ReadByte() 和 ReadRune() 从字符串中读取下一个 byte 或者 rune。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang小笔记</title>
    <link href="/2023/04/17/golang%E5%B0%8F%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/04/17/golang%E5%B0%8F%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="golang小笔记"><a href="#golang小笔记" class="headerlink" title="golang小笔记"></a>golang小笔记</h2><h3 id="字符串打印时，-v和-v-的区别"><a href="#字符串打印时，-v和-v-的区别" class="headerlink" title="字符串打印时，%v和 %+v 的区别"></a>字符串打印时，<code>%v</code>和 <code>%+v</code> 的区别</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">`%v`</span>和<span class="hljs-string">`%+v`</span>都可以用来打印<span class="hljs-string">`struct`</span>的值，区别在于<span class="hljs-string">`%v`</span>仅打印各个字段的值，<span class="hljs-string">`%+v`</span>还会打印各个字段的名称。<br></code></pre></td></tr></table></figure><h3 id="空-struct-的用途"><a href="#空-struct-的用途" class="headerlink" title="空 struct{} 的用途"></a>空 struct{} 的用途</h3><p><strong>使用空结构体<code>struct&#123;&#125;</code>可以节省内存，一般作为占位符使用，表明这里并不需要一个值。</strong></p><p>比如使用<code>map</code>表示集合时，只关注<code>key</code>的话，<code>value</code>可以使用 <code>struct&#123;&#125; </code>作为占位符。如果使用其他类型作为占位符，例如<code>int</code>，<code>bool</code>，不仅浪费了内存，而且容易引起歧义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Set <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>使用信道(channel)控制并发时，我们只是需要一个信号，但并不需要传递值，这个时候，也可以使用 struct{} 代替。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-ch<br><span class="hljs-comment">// do something</span><br>&#125;()<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>再比如，声明只包含方法的结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Lamp <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Lamp)</span></span> On() &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;On&quot;</span>)<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l Lamp)</span></span> Off() &#123;<br>        <span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Off&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="与"><a href="#与" class="headerlink" title="/与%"></a><code>/</code>与<code>%</code></h3><p>A&#x3D;10B&#x3D;20</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">&#x2F;</td><td align="center">相除</td><td align="center">B &#x2F; A &#x3D; 2</td></tr><tr><td align="center">%</td><td align="center">求余</td><td align="center">B % A &#x3D; 0</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go学习资料</title>
    <link href="/2023/04/13/Go%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/"/>
    <url>/2023/04/13/Go%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<h2 id="Go学习资料"><a href="#Go学习资料" class="headerlink" title="Go学习资料"></a>Go学习资料</h2><h3 id="Go入门"><a href="#Go入门" class="headerlink" title="Go入门"></a>Go入门</h3><p><a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/directory.md">the-way-to-go</a></p><p><a href="https://www.kancloud.cn/kancloud/the-way-to-go/72432">Go入门指南</a></p><p><a href="https://tour.go-zh.org/list">Go指南</a></p><p><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/">Go语言标准库</a></p><p><a href="https://learnku.com/go/wikis">Go实用编码技巧</a></p><p><a href="https://cloud.tencent.com/developer/doc/1101">Go教程</a></p><h3 id="Go进阶"><a href="#Go进阶" class="headerlink" title="Go进阶"></a>Go进阶</h3><p><a href="https://draveness.me/golang/">Go 语言设计与实现</a></p><p><a href="https://books.studygolang.com/advanced-go-programming-book/">Go语言高级编程</a></p><p><a href="https://gofuncchan.gitee.io/books/">Go Book</a></p><p><a href="https://github.com/ssbandjl/golang-design-pattern">设计模式-Go语言</a></p><p><a href="https://github.com/smallnest/go_test_workshop/blob/master/Go%20Test%20%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BA%BA%E5%B9%B3.pdf">Go Test 从入门到躺平</a></p><p><a href="https://gocn.vip/c/3lQ6GbD5ny/s/Y2vWUE">Go Web 编程</a></p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程</a></p><p><a href="https://docs.github.com/zh/get-started/writing-on-github/getting-started-with-writing-and-formatting-on-github/quickstart-for-writing-on-github">GitHub仓库中README.md的编写</a></p><h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p><a href="https://www.yiibai.com/mysql">Mysql教程</a></p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p><a href="https://www.w3cschool.cn/redis/">Redis教程</a></p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式教程</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式练习网站</a></p><p><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html">正则表达式手册</a></p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><a href="https://github.com/greyireland/algorithm-pattern">算法模板，最科学的刷题方式，最快速的刷题路径</a></p><p><a href="https://labuladong.github.io/algo/">LABULADONG 的算法网站</a></p><p><a href="https://hunterhug.github.io/goa.c/#/">数据结构与算法Golang实现</a></p><p><a href="https://github.com/halfrost/LeetCode-Go">Go LeetCode</a></p><p><a href="https://github.com/peterrk/DSGO">数据结构之Go语言描述</a></p><p><a href="https://github.com/emirpasic/gods">Go Data Structures</a></p><p><a href="https://github.com/hunterhug/goa.c">数据结构和算法(Golang实现)</a></p><p><a href="https://greyireland.gitbook.io/algorithm-pattern/">algorithm-pattern的算法小抄</a></p><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p><a href="https://yeasy.gitbook.io/docker_practice/">Docker从入门到实践</a></p><h3 id="Kubernetes-k8s"><a href="#Kubernetes-k8s" class="headerlink" title="Kubernetes(k8s)"></a>Kubernetes(k8s)</h3><p><a href="https://kubernetes.io/zh-cn/docs/tutorials/kubernetes-basics/">Kubernetes基础</a></p><p><a href="https://www.k8stech.net/">k8s技术栈</a></p><h3 id="后端开发"><a href="#后端开发" class="headerlink" title="后端开发"></a>后端开发</h3><p><a href="https://gitbook.curiouser.top/">大厂后端开发必会技术</a></p><p><a href="https://icyfenix.cn/">构建分布式系统</a></p><p><a href="https://cn.dubbo.apache.org/zh-cn/overview/home/">阿里-Dubbo 分布式 RPC 框架</a></p><p><a href="https://github.com/zeromicro/go-zero/blob/master/readme-cn.md">go-zero</a></p><h3 id="Go开发者路线图"><a href="#Go开发者路线图" class="headerlink" title="Go开发者路线图"></a>Go开发者路线图</h3><p><a href="https://github.com/Alikhll/golang-developer-roadmap/blob/master/i18n/zh-CN/ReadMe-zh-CN.md">2021Go开发者成长路线图</a></p><p><a href="https://www.golangroadmap.com/">Gopher学习 GOLANG ROADMAP</a></p><h3 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h3><p><a href="https://github.com/inoutcode/bitcoin_book_2nd">区块链入门知识</a></p><h3 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h3><p><a href="https://github.com/avelino/awesome-go#web-frameworks">Go 框架、库和软件的精选列表</a></p><p><a href="https://github.com/practical-tutorials/project-based-learning#go">Project Based Learning</a></p><p><a href="https://cyc2018.xyz/">CS-Notes 面试笔记</a></p><p><a href="https://github.com/codecrafters-io/build-your-own-x">Build your own X</a></p><p><a href="https://github.com/talkgo/read">Go资料推荐</a></p><p><a href="https://github.com/shockerli/go-awesome">Go 语言优秀资源整理</a></p><p><a href="https://learnku.com/articles/58970">Go练手项目</a></p><p><a href="https://www.yuque.com/xinliangnote/go-gin-api/ngc3x5">go-gin-api</a></p><p><a href="https://github.com/RongleXie/java-books-collections">软件开发电子书推荐1</a></p><p><a href="https://github.com/EbookFoundation/free-programming-books/blob/main/books/free-programming-books-zh.md">软件开发电子书推荐2</a></p><p><a href="https://github.com/Tyson0314/java-books">200本计算机经典书籍</a></p><p><a href="https://github.com/realpython/python-guide">python指南</a></p><p><a href="https://www.runoob.com/python/python-tutorial.html">python基础教程</a></p><h3 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h3><p><a href="https://eddycjy.gitbook.io/golang/">跟煎鱼学Go</a></p><p><a href="https://www.liwenzhou.com/">李文周的博客</a></p><p><a href="http://www.lsdcloud.com/go/introduction.html">技术分享</a></p><p><a href="https://www.cnblogs.com/hmtk123/p/16179925.html">Golang学习笔记</a></p><p><a href="https://hao.studygolang.com/">Gopher网址导航</a></p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><a href="https://github.com/shadowsocks/ShadowsocksX-NG/releases">Shadowsocks</a></p><p><a href="https://www.printlove.cn/tools/sql2gorm">在线sql转gorm</a></p><p><a href="http://www.esjson.com/jsonviewer.html">在线格式化json</a></p><p><a href="https://www.zmhttp.com/">芝麻代理ip-爬虫</a></p><p><a href="https://www.91ajs.com/">爱加速代理ip-爬虫</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go入门笔记</title>
    <link href="/2023/04/13/go%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/04/13/go%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="go入门笔记"><a href="#go入门笔记" class="headerlink" title="go入门笔记"></a>go入门笔记</h2><h3 id="Go开发环境的搭建"><a href="#Go开发环境的搭建" class="headerlink" title="Go开发环境的搭建"></a>Go开发环境的搭建</h3><p>​下载Windows系统下安装包（64位、msi文件）（官网地址：<a href="https://studygolang.com/dl">Go下载 - Go语言中文网 - Golang中文社区 (studygolang.com)</a>）</p><p>​（<a href="https://cloud.tencent.com/developer/article/1867433">Windows Go 开发环境下载、安装并配置 - 云+社区 - 腾讯云 (tencent.com)</a>）</p><p>​（<a href="https://www.jianshu.com/p/93232e3164c6">2 Go安装和常用工具 - 简书 (jianshu.com)</a>）</p><p>​下载安装vscode，配置中文环境，下载Go插件（官网地址：<a href="https://code.visualstudio.com/">Visual Studio Code - Code Editing. Redefined</a>）</p><p>​(<a href="https://blog.csdn.net/Kenny_cn/article/details/88984965">Go语言开发环境搭建详细教程_Kenny_cn的博客-CSDN博客_go环境搭建</a>)</p><p>​下载安装GoLand（官网地址：<a href="https://www.jetbrains.com/go/download/#section=windows">Download GoLand: Smart IDE by JetBrains for Go development</a>）</p><p>Go运行时（runtime）</p><p>​类似于java与.net中的虚拟机，负责管理内存分配、垃圾回收、栈处理、切片、map、反射等</p><p>Go 开发工具 <a href="http://go-lang.cat-v.org/text-editors/">Go Syntax Highlighting and Other Text Editors and IDEs Extensions (cat-v.org)</a></p><p>使用Go自带的工具来构建应用程序</p><ul><li><code>go build</code> 编译自身包和依赖包</li><li><code>go install</code> 编译并安装自身包和依赖包</li></ul><p>包</p><p>​结构化代码的一种方式</p><p>​包名使用小写字母</p><p>​可见性规则：当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 private ）</p><p>Pascal 命名法：每一个单词的首字母都采用大写</p><p>驼峰命名法：第一个单词的首字母小写，其余单词的首字母大写</p><p>类型</p><p>​基本类型：int、float、bool、string</p><p>​结构类型：struct、array、slice、map、channel</p><p>​只描述类型的行为的：interface</p><p>​（结构化的类型没有真正的值，它使用 nil 作为默认值（在 Objective-C 中是 nil，在 Java 中是 null，在 C 和 C++ 中是NULL或 0）。值得注意的是，Go 语言中不存在类型继承。）</p><p>​函数也可以是一个确定的类型，就是以函数作为返回类型。这种类型的声明要写在函数名和可选的参数列表之后，例如：func FunctionName (a typea, b typeb) typeFunc</p><h4 id="4-0-Go-命名规范"><a href="#4-0-Go-命名规范" class="headerlink" title="4.0 Go 命名规范"></a>4.0 Go 命名规范</h4><p>​干净、可读的代码和简洁性是 Go 追求的主要目标。通过 gofmt 来强制实现统一的代码风格。Go 语言中对象的命名也应该是简洁且有意义的。像 Java 和 Python 中那样使用混合着大小写和下划线的冗长的名称会严重降低代码的可读性。名称不需要指出自己所属的包，因为在调用的时候会使用包名作为限定符。返回某个对象的函数或方法的名称一般都是使用名词，没有 <code>Get...</code> 之类的字符，如果是用于修改某个对象，则使用 <code>SetName</code>。有必须要的话可以使用大小写混合的方式，如 MixedCaps 或 mixedCaps，而不是使用下划线来分割多个名称。</p><p>​反斜杠 <code>\</code> 可以在常量表达式中作为多行的连接符使用</p><p>​变量命名使用驼峰命名法，如果全局变量需要被外部包使用，首字母也需要大写</p><p>常量使用关键字 <code>const</code> 定义，用于存储不会改变的数据。</p><p>声明变量的一般形式是使用 <code>var</code> 关键字：<code>var identifier type</code></p><p>值类型的变量的值存储在栈中。</p><p>​被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间</p><p>运算符优先级</p><p>​优先级 运算符<br>​ 7 ^ !<br>​ 6 * &#x2F; % &lt;&lt; &gt;&gt; &amp; &amp;^<br>​ 5 + - | ^<br>​ 4 &#x3D;&#x3D; !&#x3D; &lt; &lt;&#x3D; &gt;&#x3D; &gt;<br>             3 &lt;-<br>​ 2 &amp;&amp;<br>​ 1 ||</p><p>%s</p><h5 id="Go语言格式化说明符"><a href="#Go语言格式化说明符" class="headerlink" title="Go语言格式化说明符"></a>Go语言格式化说明符</h5><h6 id="1-v：相应值的默认格式"><a href="#1-v：相应值的默认格式" class="headerlink" title="1.%v：相应值的默认格式"></a>1.%v：相应值的默认格式</h6><h6 id="2-v：打印结构体的时候，会添加字段名"><a href="#2-v：打印结构体的时候，会添加字段名" class="headerlink" title="2.%+v：打印结构体的时候，会添加字段名"></a>2.%+v：打印结构体的时候，会添加字段名</h6><h6 id="3-v：相应值的Go语法表示"><a href="#3-v：相应值的Go语法表示" class="headerlink" title="3.%#v：相应值的Go语法表示"></a>3.%#v：相应值的Go语法表示</h6><h6 id="4-T：相应的类型的表示。直接会输出该变量的数据类型"><a href="#4-T：相应的类型的表示。直接会输出该变量的数据类型" class="headerlink" title="4.%T：相应的类型的表示。直接会输出该变量的数据类型"></a>4.%T：相应的类型的表示。直接会输出该变量的数据类型</h6><h6 id="5-t：在知道是bool类型的前提下，可以直接使用-t打印。如果不知道其类型，可以使用-v"><a href="#5-t：在知道是bool类型的前提下，可以直接使用-t打印。如果不知道其类型，可以使用-v" class="headerlink" title="5.%t：在知道是bool类型的前提下，可以直接使用%t打印。如果不知道其类型，可以使用%v"></a>5.%t：在知道是bool类型的前提下，可以直接使用%t打印。如果不知道其类型，可以使用%v</h6><h6 id="6-b：二进制表示"><a href="#6-b：二进制表示" class="headerlink" title="6.%b：二进制表示"></a>6.%b：二进制表示</h6><h6 id="7-q：双引号围绕的字符串字面值，由go语法安全地转义。意思是将双引号一并输出。-s只输出字符串中的内容，不会添加“-”"><a href="#7-q：双引号围绕的字符串字面值，由go语法安全地转义。意思是将双引号一并输出。-s只输出字符串中的内容，不会添加“-”" class="headerlink" title="7.%q：双引号围绕的字符串字面值，由go语法安全地转义。意思是将双引号一并输出。%s只输出字符串中的内容，不会添加“ ”"></a>7.%q：双引号围绕的字符串字面值，由go语法安全地转义。意思是将双引号一并输出。%s只输出字符串中的内容，不会添加“ ”</h6><h6 id="8-p：取地址"><a href="#8-p：取地址" class="headerlink" title="8.%p：取地址"></a>8.%p：取地址</h6><h6 id="9-：转义"><a href="#9-：转义" class="headerlink" title="9.%%：转义"></a>9.%%：转义</h6><h6 id="10-f：浮点数输出"><a href="#10-f：浮点数输出" class="headerlink" title="10.%f：浮点数输出"></a>10.%f：浮点数输出</h6><h6 id="11-x：十六进制输出"><a href="#11-x：十六进制输出" class="headerlink" title="11.%x：十六进制输出"></a>11.%x：十六进制输出</h6><h6 id="12-sprintf：将整数打印成字符串的格式"><a href="#12-sprintf：将整数打印成字符串的格式" class="headerlink" title="12.sprintf：将整数打印成字符串的格式"></a>12.sprintf：将整数打印成字符串的格式</h6><p><code>%t</code> ：在格式化输出时，你可以使用 <code>%t</code> 来表示你要输出的值为布尔型</p><p><code>%d</code> 用于格式化整数（<code>%x</code> 和 <code>%X</code> 用于格式化 16 进制表示的数字）</p><p><code>%g</code> 用于格式化浮点型（<code>%f</code> 输出浮点数，<code>%e</code> 输出科学计数表示法）</p><p><code>%0nd</code> 用于规定输出长度为n的整数，其中开头的数字 0 是必须的</p><p><code>%n.mg</code> 用于表示数字 n 并精确到小数点后 m 位，除了使用 g 之外，还可以使用 e 或者 f，例如：使用格式化字符串 <code>%5.2e</code> 来输出 3.4 的结果为 <code>3.40e+00</code>。</p><p>格式化说明符 <code>%c</code> 用于表示字符；当和字符配合使用时，<code>%v</code> 或 <code>%d</code> 会输出用于表示该字符的整数；<code>%U</code> 输出格式为 U+hhhh 的字符串（另一个示例见第 5.4.4 节）</p><p>包 <code>unicode</code> 包含了一些针对测试字符的非常有用的函数（其中 <code>ch</code> 代表字符）：</p><ul><li>判断是否为字母：<code>unicode.IsLetter(ch)</code></li><li>判断是否为数字：<code>unicode.IsDigit(ch)</code></li><li>判断是否为空白符号：<code>unicode.IsSpace(ch)</code></li></ul><p>这些函数返回一个布尔值。包 <code>utf8</code> 拥有更多与 rune 类型相关的函数。</p><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>​获取字节长度len(str)</p><p>​获取字符长度调用“unicode&#x2F;utf8包”，RuneCountInString(str)</p><h5 id="4-7strings和strconv包"><a href="#4-7strings和strconv包" class="headerlink" title="4.7strings和strconv包"></a>4.7strings和strconv包</h5><p>​作为一种基本数据结构，每种语言都有一些对于字符串的预定义处理函数。Go 中使用 <code>strings</code> 包来完成对字符串的主要操作</p><h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><p>​Go 语言为程序员提供了控制数据结构的指针的能力；但是，你不能进行指针运算。通过给予程序员基本内存布局，Go 语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这些对构建运行良好的系统是非常重要的：指针对于性能的影响是不言而喻的，而如果你想要做的是系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。</p><p>​Go 语言的取地址符是 <code>&amp;</code>，放到一个变量前使用就会返回相应变量的内存地址</p><p>​var intP *int</p><p>​然后使用 <code>intP = &amp;i1</code> 是合法的，此时 intP 指向 i1。</p><p>​指针的格式化标识符为 <code>%p</code></p><p>​<strong>一个指针变量可以指向任何一个值的内存地址</strong> 它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。当然，可以声明指针指向任何类型的值来表明它的原始性或结构性；你可以在指针类型前面加上 * 号（前缀）来获取指针所指向的内容，这里的 * 号是一个类型更改器。使用一个指针引用一个值被称为间接引用。</p><h4 id="5-0-控制结构"><a href="#5-0-控制结构" class="headerlink" title="5.0 控制结构"></a>5.0 控制结构</h4><p>​if-else结构</p><p>​switch结构</p><p>​select结构，用于channel的选择</p><p>​for（range）结构</p><p>​for pos, char :&#x3D; range str{}  pos为索引，char为字符</p><p>​一些如 <code>break</code> 和 <code>continue</code> 这样的关键字可以用于中途改变循环的状态</p><p>​此外，你还可以使用 <code>return</code> 来结束某个函数的执行，或使用 <code>goto</code> 和标签来调整程序的执行位置</p><h4 id="6-0-函数（function）"><a href="#6-0-函数（function）" class="headerlink" title="6.0 函数（function）"></a>6.0 函数（function）</h4><p>​Go 里面有三种类型的函数：</p><ul><li>普通的带有名字的函数</li><li>匿名函数或者lambda函数（参考 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/06.8.md">第 6.8 节</a>）</li><li>方法（Methods，参考 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/10.6.md">第 10.6 节</a>）</li></ul><p>​除了main()、init()函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为函数签名</p><p>​如果一个函数需要返回四到五个值，我们可以传递一个切片给函数（如果返回值具有相同类型）或者是传递一个结构体（如果返回值具有不同的类型）。因为传递一个指针允许直接修改变量的值，消耗也更少。</p><h5 id="6-3-（！！！6-4倒数第一、二个例子）"><a href="#6-3-（！！！6-4倒数第一、二个例子）" class="headerlink" title="(6.3)（！！！6.4倒数第一、二个例子）"></a>(6.3)（！！！6.4倒数第一、二个例子）</h5><h6 id="6-4-defer和追踪"><a href="#6-4-defer和追踪" class="headerlink" title="6.4 defer和追踪"></a>6.4 defer和追踪</h6><p>​1、关键字 defer 允许我们进行一些函数执行完成后的收尾工作，例如：</p><p>​关闭文件流、解锁一个加锁的资源、打印最终报告、关闭数据库连接</p><p>​2、使用defer语句实现代码追踪</p><h6 id="6-5-内置函数"><a href="#6-5-内置函数" class="headerlink" title="6.5 内置函数"></a>6.5 内置函数</h6><h6 id="6-6递归函数"><a href="#6-6递归函数" class="headerlink" title="6.6递归函数"></a>6.6递归函数</h6><p>​当一个函数在其函数体内调用自身，则称之为递归。最经典的例子便是计算斐波那契数列，即前两个数为1，从第三个数开始每个数均为前两个数之和。</p><h6 id="6-7将函数作为参数（！！！）"><a href="#6-7将函数作为参数（！！！）" class="headerlink" title="6.7将函数作为参数（！！！）"></a>6.7将函数作为参数（！！！）</h6><p>​函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，一般称之为回调。</p><h6 id="6-8闭包"><a href="#6-8闭包" class="headerlink" title="6.8闭包"></a>6.8闭包</h6><p>​当我们不希望给函数起名字的时候，可以使用匿名函数，例如：<code>func(x, y int) int &#123; return x + y &#125;</code>。</p><pre><code class="hljs">func() &#123;        sum := 0        for i := 1; i &lt;= 1e6; i++ &#123;                sum += i        &#125;&#125;()</code></pre><p>​表示参数列表的第一对括号必须紧挨着关键字 <code>func</code>，因为匿名函数没有名称。花括号 <code>&#123;&#125;</code> 涵盖着函数体，最后的一对括号表示对该匿名函数的调用。</p><p>​所以我们实际上拥有的是一个函数值：匿名函数可以被赋值给变量并作为值使用</p><h6 id="6-9应用闭包：将函数作为返回值"><a href="#6-9应用闭包：将函数作为返回值" class="headerlink" title="6.9应用闭包：将函数作为返回值"></a>6.9应用闭包：将函数作为返回值</h6><h6 id="6-10使用闭包调试"><a href="#6-10使用闭包调试" class="headerlink" title="6.10使用闭包调试"></a>6.10使用闭包调试</h6><h6 id="6-11计算函数执行时间"><a href="#6-11计算函数执行时间" class="headerlink" title="6.11计算函数执行时间"></a>6.11计算函数执行时间</h6><h6 id="6-12通过内存缓存来提升性能"><a href="#6-12通过内存缓存来提升性能" class="headerlink" title="6.12通过内存缓存来提升性能"></a>6.12通过内存缓存来提升性能</h6><h4 id="7-0-数组与切片"><a href="#7-0-数组与切片" class="headerlink" title="7.0 数组与切片"></a>7.0 数组与切片</h4><h6 id="7-1声明和初始化"><a href="#7-1声明和初始化" class="headerlink" title="7.1声明和初始化"></a>7.1声明和初始化</h6><h6 id="7-2切片"><a href="#7-2切片" class="headerlink" title="7.2切片"></a>7.2切片</h6><p>​多个切片如果表示同一个数组的片段，它们可以共享数据；因此一个切片和相关数组的其他切片是共享存储的，相反，不同的数组总是代表不同的存储。数组实际上是切片的构建块。</p><p>​<strong>优点</strong> 因为切片是引用，所以它们不需要使用额外的内存并且比使用数组更有效率，所以在 Go 代码中切片比数组更常用。</p><p>​声明切片的格式是： <code>var identifier []type</code>（不需要说明长度）</p><p>​切片的初始化格式是：<code>var slice1 []type = arr1[start:end]</code></p><p>​这表示 slice1 是由数组 arr1 从 <code>start</code> 索引到 <code>end-1</code> 索引之间的元素构成的子集（切分数组，start:end 被称为 slice 表达式）</p><p>​<code>var slice1 []type = arr1[:]</code> 那么 slice1 就等于完整的 arr1 数组（<code>arr1[0:len(arr1)]</code> 的一种缩写）</p><p>​对于每一个切片（包括 string），以下状态总是成立的：</p><pre><code class="hljs">s == s[:i] + s[i:] // i是一个整数且: 0 &lt;= i &lt;= len(s)</code></pre><p>​len(s) &lt;&#x3D; cap(s)</p><p>7.3for-range</p><p>7.4切片重组（reslice)</p><p>​改变切片长度的过程称之为切片重组 <strong>reslicing</strong>，做法如下：<code>slice1 = slice1[0:end]</code>，其中 end 是新的末尾索引（即长度）。</p><p>​将切片扩展 1 位可以这么做：</p><p>​sl &#x3D; sl[0:len(sl)+1]</p><p>7.5切片的复制与追加</p><p>7.6字符串、数组和切片的应用</p><p>​7.6.1从字符串生成字节切片</p><p>​7.6.2 获取字符串的某一部分</p><p>​7.6.3 字符串和切片的内存结构</p><p>​7.6.4 修改字符串中的某个字符</p><p>​7.6.5 字节数组对比函数</p><p>​7.6.6 搜索及排序切片和数组</p><p>​7.6.7 append 函数常见操作</p><p>​7.6.8 切片和垃圾回收</p><h4 id="8-0-Map（引用类型）"><a href="#8-0-Map（引用类型）" class="headerlink" title="8.0 Map（引用类型）"></a>8.0 Map（引用类型）</h4><p>map 是一种特殊的数据结构：一种元素对（pair）的无序集合，pair 的一个元素是 key，对应的另一个元素是 value，所以这个结构也称为关联数组或字典。这是一种快速寻找值的理想结构：给定 key，对应的 value 可以迅速定位。</p><p>map 这种数据结构在其他编程语言中也称为字典（Python）、hash 和 HashTable 等。</p><h6 id="8-1声明、初始化和make"><a href="#8-1声明、初始化和make" class="headerlink" title="8.1声明、初始化和make"></a>8.1声明、初始化和make</h6><p>​8.1.1概念</p><p>​声明：var map1 map[keytype]valuetype</p><p>​在声明的时候不需要知道 map 的长度，map 是可以动态增长的。</p><p>​未初始化的 map 的值是 nil。</p><p>​初始化：var map1 &#x3D; make(map[keytype]valuetype)map1 :&#x3D; make(map[keytype]valuetype)</p><p>​8.1.2 map 容量</p><p>​make(map[keytype]valuetype,cap)</p><p>​8.1.3 用切片作为 map 的值</p><h6 id="8-2测试键值对是否存在及删除元素"><a href="#8-2测试键值对是否存在及删除元素" class="headerlink" title="8.2测试键值对是否存在及删除元素"></a>8.2测试键值对是否存在及删除元素</h6><p>​val1, isPresent &#x3D; map1[key1]</p><h6 id="8-3for-range的配套用法"><a href="#8-3for-range的配套用法" class="headerlink" title="8.3for-range的配套用法"></a>8.3for-range的配套用法</h6><p>​可以用for循环构建map：</p><p>​for key,value:&#x3D;range map1{</p><p>​…</p><p>​}</p><h6 id="8-4map类型的切片"><a href="#8-4map类型的切片" class="headerlink" title="8.4map类型的切片"></a>8.4map类型的切片</h6><p>​假设我们想获取一个 map 类型的切片，我们必须使用两次 <code>make()</code> 函数，第一次分配切片，第二次分配切片中每个 map 元素</p><h6 id="8-5map的排序"><a href="#8-5map的排序" class="headerlink" title="8.5map的排序"></a>8.5map的排序</h6><p>​map 默认是无序的，不管是按照 key 还是按照 value 默认都不排序</p><p>​如果你想为 map 排序，需要将 key（或者 value）拷贝到一个切片，再对切片排序（使用 sort 包，详见第 7.6.6 节），然后可以使用切片的 for-range 方法打印出所有的 key 和 value</p><h6 id="8-6将map的键值对调"><a href="#8-6将map的键值对调" class="headerlink" title="8.6将map的键值对调"></a>8.6将map的键值对调</h6><p>​这里对调是指调换 key 和 value。如果 map 的值类型可以作为 key 且所有的 value 是唯一的可以进行简单的对调。</p><p>​如果原始 value 值不唯一那这么做肯定会出问题；这种情况下不会报错，但是当遇到不唯一的 key 时应当直接停止对调，且此时对调后的 map 很可能没有包含原 map 的所有键值对！一种解决方法就是仔细检查唯一性并且使用多值 map，比如使用 <code>map[int][]string</code> 类型。</p><h5 id="9-包（package）"><a href="#9-包（package）" class="headerlink" title="9 包（package）"></a>9 包（package）</h5><h6 id="9-1标准库概述"><a href="#9-1标准库概述" class="headerlink" title="9.1标准库概述"></a>9.1标准库概述</h6><h6 id="9-2Regexp包"><a href="#9-2Regexp包" class="headerlink" title="9.2Regexp包"></a>9.2Regexp包</h6><h6 id="9-3锁和sync包"><a href="#9-3锁和sync包" class="headerlink" title="9.3锁和sync包"></a>9.3锁和sync包</h6><p>​在 Go 语言中这种锁的机制是通过 sync 包中 Mutex 来实现的。</p><p>​<code>sync.Mutex</code> 是一个互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。</p><p>​假设 info 是一个需要上锁的放在共享内存中的变量。通过包含 <code>Mutex</code> 来实现的一个典型例子如下：</p><p>​import  “sync”</p><p>​type Info struct {<br>​mu sync.Mutex<br>​&#x2F;&#x2F; … other fields, e.g.: Str string<br>​}</p><p>​在 sync 包中还有一个 <code>RWMutex</code> 锁：它能通过 <code>RLock()</code> 来允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作。如果使用 <code>Lock()</code> 将和普通的 <code>Mutex</code> 作用相同。包中还有一个方便的 <code>Once</code> 类型变量的方法 <code>once.Do(call)</code>，这个方法确保被调用函数只能被调用一次。</p><h6 id="9-4精密计算和big包"><a href="#9-4精密计算和big包" class="headerlink" title="9.4精密计算和big包"></a>9.4精密计算和big包</h6><p>​对于整数的高精度计算 Go 语言中提供了 big 包，被包含在 math 包下：有用来表示大整数的 <code>big.Int</code> 和表示大有理数的 <code>big.Rat</code> 类型（可以表示为 2&#x2F;5 或 3.1416 这样的分数，而不是无理数或 π）。这些类型可以实现任意位类型的数字，只要内存足够大。缺点是更大的内存和处理开销使它们使用起来要比内置的数字类型慢很多。</p><p>​大的整型数字是通过 <code>big.NewInt(n)</code> 来构造的，其中 n 为 int64 类型整数。而大有理数是通过 <code>big.NewRat(n, d)</code> 方法构造。n（分子）和 d（分母）都是 int64 型整数。因为 Go 语言不支持运算符重载，所以所有大数字类型都有像是 <code>Add()</code> 和 <code>Mul()</code> 这样的方法。它们作用于作为 receiver 的整数和有理数，大多数情况下它们修改 receiver 并以 receiver 作为返回结果。因为没有必要创建 <code>big.Int</code> 类型的临时变量来存放中间结果，所以运算可以被链式地调用，并节省内存。</p><h6 id="9-5自定义包和可见性"><a href="#9-5自定义包和可见性" class="headerlink" title="9.5自定义包和可见性"></a>9.5自定义包和可见性</h6><p>​当写自己包的时候，要使用短小的不含有 <code>_</code>（下划线）的小写单词来为文件命名。</p><p>​主程序利用的包必须在主程序编写之前被编译。主程序中每个 pack1 项目都要通过包名来使用：<code>pack1.Item</code></p><p>​子目录和包之间有着密切的联系：为了区分，不同包存放在不同的目录下，每个包（所有属于这个包中的 go 文件）都存放在和包名相同的子目录下：Import with <code>.</code> :</p><p>​import . “.&#x2F;pack1”</p><p>导入外部安装包</p><p>​如果你要在你的应用中使用一个或多个外部包，首先你必须使用 <code>go install</code>（参见第 9.7 节）在你的本地机器上安装它们。</p><p>​假设你想使用 <code>http://codesite.ext/author/goExample/goex</code> 这种托管在 Google Code、GitHub 和 Launchpad 等代码网站上的包。</p><p>​你可以通过如下命令安装：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">go install codesite.ext<span class="hljs-regexp">/author/g</span>oExample/goex<br></code></pre></td></tr></table></figure><p>​将一个名为 <code>codesite.ext/author/goExample/goex</code> 的 map 安装在 <code>$GOROOT/src/</code> 目录下。</p><p>通过以下方式，一次性安装，并导入到你的代码中：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">import</span> goex <span class="hljs-string">&quot;codesite.ext/author/goExample/goex&quot;</span><br></code></pre></td></tr></table></figure><p>​因此该包的 URL 将用作导入路径。</p><p>​在 <code>http://golang.org/cmd/goinstall/</code> 的 <code>go install</code> 文档中列出了一些广泛被使用的托管在网络代码仓库的包的导入路径</p><h6 id="9-6为自定义包使用godoc"><a href="#9-6为自定义包使用godoc" class="headerlink" title="9.6为自定义包使用godoc"></a>9.6为自定义包使用godoc</h6><p>​godoc 工具在显示自定义包中的注释也有很好的效果：注释必须以 <code>//</code> 开始并无空行放在声明（包，类型，函数）前。godoc 会为每个文件生成一系列的网页。</p><p>​如果你在一个团队中工作，并且源代码树被存储在网络硬盘上，就可以使用 godoc 给所有团队成员连续文档的支持。通过设置 <code>sync_minutes=n</code>，你甚至可以让它每 n 分钟自动更新您的文档！</p><h6 id="9-7使用go-install安装自定义包"><a href="#9-7使用go-install安装自定义包" class="headerlink" title="9.7使用go install安装自定义包"></a>9.7使用go install安装自定义包</h6><p>​go install 是 Go 中自动包安装工具：如需要将包安装到本地它会从远端仓库下载包：检出、编译和安装</p><p>​从 Go1 起 go install 安装 Google Code 的导入路径形式是：<code>&quot;code.google.com/p/tideland-cgl&quot;</code></p><h6 id="9-8自定义包的目录结构、go-install和go-test"><a href="#9-8自定义包的目录结构、go-install和go-test" class="headerlink" title="9.8自定义包的目录结构、go install和go test"></a>9.8自定义包的目录结构、go install和go test</h6><p>​自定义包的目录结构</p><p>​下面的结构给了你一个好的示范（uc 代表通用包名, 名字为粗体的代表目录，斜体代表可执行文件）:</p><pre><code class="hljs">/home/user/goprogramsucmain.go(uc 包主程序)Makefile (ucmain 的 makefile)ucmainsrc/uc (包含 uc 包的 go 源码)    uc.go uc_test.go Makefile (包的 makefile) uc.a _obj        uc.a    _test        uc.abin(包含最终的执行文件)    ucmainpkg/linux_amd64    uc.a(包的目标文件)</code></pre><h6 id="9-9通过git打包和安装"><a href="#9-9通过git打包和安装" class="headerlink" title="9.9通过git打包和安装"></a>9.9通过git打包和安装</h6><p>安装到Github</p><p>从Github安装</p><h6 id="9-10Go的外部包和项目"><a href="#9-10Go的外部包和项目" class="headerlink" title="9.10Go的外部包和项目"></a>9.10Go的外部包和项目</h6><p>​当着手自己的 Go 项目时，最好先查找下是否有些存在的第三方的包或者项目能不能使用。大多数可以通过 go install 来进行安装。</p><p>​<a href="https://gowalker.org/">Go Walker</a> 支持根据包名在海量数据中查询。</p><p>​目前已经有许多非常好的外部库，如：</p><ul><li>MySQL(GoMySQL), PostgreSQL(go-pgsql), MongoDB (mgo, gomongo), CouchDB (couch-go), ODBC (godbcl), Redis (redis.go) and SQLite3 (gosqlite) database drivers</li><li>SDL bindings</li><li>Google’s Protocal Buffers(goprotobuf)</li><li>XML-RPC(go-xmlrpc)</li><li>Twitter(twitterstream)</li><li>OAuth libraries(GoAuth)</li></ul><h6 id="9-11在Go程序中使用外部库"><a href="#9-11在Go程序中使用外部库" class="headerlink" title="9.11在Go程序中使用外部库"></a>9.11在Go程序中使用外部库</h6><h5 id="10-0-结构（struct）方法（method）"><a href="#10-0-结构（struct）方法（method）" class="headerlink" title="10.0 结构（struct）方法（method）"></a>10.0 结构（struct）方法（method）</h5><p>​Go 通过类型别名（alias types）和结构体的形式支持用户自定义类型，或者叫定制类型。一个带属性的结构体试图表示一个现实世界中的实体。结构体是复合类型（composite types），当需要定义一个类型，它由一系列属性组成，每个属性都有自己的类型和值的时候，就应该使用结构体，它把数据聚集在一起。然后可以访问这些数据，就好像它是一个独立实体的一部分。结构体也是值类型，因此可以通过 <strong>new</strong> 函数来创建。</p><p>​组成结构体类型的那些数据称为 <strong>字段（fields）</strong>。每个字段都有一个类型和一个名字；在一个结构体中，字段名字必须是唯一的。</p><h6 id="10-1结构体定义"><a href="#10-1结构体定义" class="headerlink" title="10.1结构体定义"></a>10.1结构体定义</h6><p>结构体定义的一般方式如下：</p><p>​type identifier struct{</p><p>​field1 type1</p><p>​field2 type2</p><p>​…</p><p>​}</p><p>​type T struct {a,b int}也是合法的语句，适用于简单的结构体</p><p>​结构体的字段可以是任何类型，甚至是结构体本身，也可以是函数或者接口。</p><p>​可以声明结构体类型的一个变量，然后像下面这样给它的字段赋值：</p><p>​var s T</p><p>​s.a&#x3D;5</p><p>​s.b&#x3D;8</p><p>使用new</p><p>​使用new函数给一个新的结构体变量分配内存，他返回指向一份分配地址的指针：var t *T&#x3D;new(T)，如果需要，可以把这条语句放在不同行（比如定义是包范围的，但是分配却没有必要再开始就做）</p><p>​var t *T</p><p>​t&#x3D;new(T)</p><p>​写这条语句的惯用方法是：t:&#x3D;new(T)，变量t是一个指向T的指针，此时结构体字段的值是它们所属类型的零值</p><p>​声明var t T也会给t分配内存，并零值化内存，但是这个时候t是类型T。在这两种方法中，t通常被叫做类型t的一个实例（instance）和（object）。</p><p>​使用new初始化：</p><p><img src="https://raw.githubusercontent.com/unknwon/the-way-to-go_ZH_CN/master/eBook/images/10.1_fig10.1-1.jpg" alt="img"></p><p>​作为结构体字面量初始化：</p><p><img src="https://raw.githubusercontent.com/unknwon/the-way-to-go_ZH_CN/master/eBook/images/10.1_fig10.1-2.jpg" alt="img"></p><p>​</p><p>时间间隔（开始和结束时间以秒为单位）是使用结构体的一个典型的例子</p><p>​type Interval struct{</p><p>​   start int</p><pre><code class="hljs">           end int</code></pre><p>​}</p><h6 id="结构体的内存布局"><a href="#结构体的内存布局" class="headerlink" title="结构体的内存布局"></a>结构体的内存布局</h6><p>​Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体，这在性能上带来了很大的优势。不像 Java 中的引用类型，一个对象和它里面包含的对象可能会在不同的内存空间中，这点和 Go 语言中的指针很像。下面的例子清晰地说明了这些情况：</p><p>​type Rect1 struct {Min, Max Point }</p><p>​type Rect2 struct {Min, Max *Point }</p><p><img src="https://raw.githubusercontent.com/unknwon/the-way-to-go_ZH_CN/master/eBook/images/10.1_fig10.2.jpg" alt="img"></p><h6 id="递归结构体"><a href="#递归结构体" class="headerlink" title="递归结构体"></a>递归结构体</h6><p>​结构体类型可以通过引用自身来定义。这在定义链表或二叉树的元素（通常叫节点）时特别有用，此时节点包含指向临近节点的链接（地址）。如下所示，链表中的 <code>su</code>，树中的 <code>ri</code> 和 <code>le</code> 分别是指向别的节点的指针。</p><p>​链表：</p><p><img src="https://raw.githubusercontent.com/unknwon/the-way-to-go_ZH_CN/master/eBook/images/10.1_fig10.3.jpg" alt="img"></p><p>​这块的 <code>data</code> 字段用于存放有效数据（比如 float64），<code>su</code> 指针指向后继节点</p><p>​Go 代码：</p><pre><code class="hljs">    type Node struct &#123;        data    float64        su      *Node    &#125;</code></pre><p>​二叉树：</p><p>​<img src="https://raw.githubusercontent.com/unknwon/the-way-to-go_ZH_CN/master/eBook/images/10.1_fig10.4.jpg" alt="img"></p><p>​二叉树中每个节点最多能链接至两个节点：左节点（le）和右节点（ri），这两个节点本身又可以有左右节点，依次类推。树的顶层节点叫根节点（<strong>root</strong>），底层没有子节点的节点叫叶子节点（<strong>leaves</strong>），叶子节点的 <code>le</code> 和 <code>ri</code> 指针为 nil 值。在 Go 中可以如下定义二叉树：</p><pre><code class="hljs">type Tree struct &#123;    le      *Tree    data    float64    ri      *Tree&#125;</code></pre><h6 id="结构体转换"><a href="#结构体转换" class="headerlink" title="结构体转换"></a>结构体转换</h6><p>​Go 中的类型转换遵循严格的规则。当为结构体定义了一个 alias 类型时，此结构体类型和它的 alias 类型都有相同的底层类型，它们可以如示例 10.3 那样互相转换，同时需要注意其中非法赋值或转换引起的编译错误。</p><p>示例 10.3：</p><pre><code class="hljs">package mainimport &quot;fmt&quot;type number struct &#123;    f float32&#125;type nr number   // alias typefunc main() &#123;    a := number&#123;5.0&#125;    b := nr&#123;5.0&#125;    // var i float32 = b   // compile-error: cannot use b (type nr) as type float32 in assignment    // var i = float32(b)  // compile-error: cannot convert b (type nr) to type float32    // var c number = b    // compile-error: cannot use b (type nr) as type number in assignment    // needs a conversion:    var c = number(b)    fmt.Println(a, b, c)&#125;</code></pre><p>输出：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="hljs-template-variable">&#123;5&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;5&#125;</span><span class="language-xml"> </span><span class="hljs-template-variable">&#123;5&#125;</span><br></code></pre></td></tr></table></figure><h5 id="10-2使用工厂方法创建结构体实例"><a href="#10-2使用工厂方法创建结构体实例" class="headerlink" title="10.2使用工厂方法创建结构体实例"></a>10.2使用工厂方法创建结构体实例</h5><h6 id="10-2-1结构体工厂"><a href="#10-2-1结构体工厂" class="headerlink" title="10.2.1结构体工厂"></a>10.2.1结构体工厂</h6><p>​Go 语言不支持面向对象编程语言中那样的构造子方法，但是可以很容易的在 Go 中实现 “构造子工厂”方法。</p><pre><code class="hljs">    type File struct &#123;        fd      int     // 文件描述符        name    string  // 文件名    &#125;</code></pre><p>​下面是这个结构体类型对应的工厂方法，它返回一个指向结构体实例的指针：</p><pre><code class="hljs">    func NewFile(fd int, name string) *File &#123;        if fd &lt; 0 &#123;   return nil        &#125;        return &amp;File&#123;fd, name&#125;    &#125;</code></pre><p>​然后这样调用它：</p><pre><code class="hljs">    f := NewFile(10, &quot;./test.txt&quot;)</code></pre><p>​在 Go 语言中常常像上面这样在工厂方法里使用初始化来简便的实现构造函数。</p><h6 id="10-2-2map和struct-vs-new-和make"><a href="#10-2-2map和struct-vs-new-和make" class="headerlink" title="10.2.2map和struct vs new()和make()"></a>10.2.2map和struct vs new()和make()</h6><h6 id="10-3使用自定义包中的结构体"><a href="#10-3使用自定义包中的结构体" class="headerlink" title="10.3使用自定义包中的结构体"></a>10.3使用自定义包中的结构体</h6><h6 id="10-4带标签的结构体"><a href="#10-4带标签的结构体" class="headerlink" title="10.4带标签的结构体"></a>10.4带标签的结构体</h6><p>​结构体中的字段除了有名字和类型外，还可以有一个可选的标签（tag）：它是一个附属于字段的字符串，可以是文档或其他的重要标记。标签的内容不可以在一般的编程中使用，只有包 <code>reflect</code> 能获取它。</p><h6 id="10-5匿名字段和内嵌结构体"><a href="#10-5匿名字段和内嵌结构体" class="headerlink" title="10.5匿名字段和内嵌结构体"></a>10.5匿名字段和内嵌结构体</h6><p>​10.5.1定义</p><p>​结构体可以包含一个或多个 <strong>匿名（或内嵌）字段</strong>，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 <strong>结构体可以包含内嵌结构体</strong>。</p><p>​10.5.2内嵌结构体</p><p>​结构体也是一种数据类型，所以它也可以作为一个匿名字段来使用，内层结构体被简单的插入或者内嵌进外层结构体。这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。</p><p>​10.5.3命名冲突</p><p>​当两个字段拥有相同的名字（可能是继承来的名字）时该怎么办呢？</p><p>​1.外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；</p><p>​2.如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。</p><p>​例子：</p><pre><code class="hljs">        type A struct &#123;a int&#125;        type B struct &#123;a, b int&#125;        type C struct &#123;A; B&#125;        var c C</code></pre><p>​规则 2：使用 <code>c.a</code> 是错误的，到底是 <code>c.A.a</code> 还是 <code>c.B.a</code> 呢？会导致编译器错误：ambiguous DOT reference c.a disambiguate with either c.A.a or c.B.a</p><h6 id="10-6方法"><a href="#10-6方法" class="headerlink" title="10.6方法"></a>10.6方法</h6><p>​10.6.1方法是什么</p><p>​在 Go 语言中，结构体就像是类的一种简化形式，那么面向对象程序员可能会问：类的方法在哪里呢？在 Go 中有一个概念，它和方法有着同样的名字，并且大体上意思相同：Go 方法是作用在接收者（receiver）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。</p><p>​接收者类型可以是（几乎）任何类型，不仅仅是结构体类型：任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型。但是接收者不能是一个接口类型（参考 第 11 章），因为接口是一个抽象定义，但是方法却是具体实现；如果这样做会引发一个编译错误：<strong>invalid receiver type…</strong>。</p><p>​最后接收者不能是一个指针类型，但是它可以是任何其他允许类型的指针。</p><p>​一个类型加上它的方法等价于面向对象中的一个类。一个重要的区别是：在 Go 中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在在不同的源文件，唯一的要求是：它们必须是同一个包的。</p><p>​类型 T（或 *T）上的所有方法的集合叫做类型 T（或 *T）的方法集（method set）。</p><p>​因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法。但是如果基于接收者类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收者类型上存在，比如在同一个包里这么做是允许的：</p><pre><code class="hljs">    func (a *denseMatrix) Add(b Matrix) Matrix    func (a *sparseMatrix) Add(b Matrix) Matrix</code></pre><p>​别名类型没有原始类型上已经定义过的方法。</p><p>​定义方法的一般格式如下：</p><pre><code class="hljs">func (recv receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125;      接收者  接收者类型     方法名      参数列表          返回值列表</code></pre><p>​在方法名之前，<code>func</code> 关键字之后的括号中指定 receiver。</p><p>​如果 <code>recv</code> 是 receiver 的实例，Method1 是它的方法名，那么方法调用遵循传统的 <code>object.name</code> 选择器符号：**recv.Method1()**。</p><p>​如果 <code>recv</code> 是一个指针，Go 会自动解引用。</p><p>​如果方法不需要使用 <code>recv</code> 的值，可以用 <strong>_</strong> 替换它，比如：</p><pre><code class="hljs">func (_ receiver_type) methodName(parameter_list) (return_value_list) &#123; ... &#125;`recv` 就像是面向对象语言中的 `this` 或 `self`，但是 Go 中并没有这两个关键字。随个人喜好，你可以使用 `this` 或 `self` 作为 receiver 的名字。</code></pre><p>​10.6.2函数和方法的区别</p><p>​函数将变量作为参数：<strong>Function1(recv)</strong></p><pre><code class="hljs">    在接收者是指针时，方法可以改变接收者的值（或状态），这点函数也可以做到（当参数作为指针传递，即通过引用调用时，函数也可以改变参数的状态）。方法在变量上被调用：**recv.Method1()**</code></pre><p>​<strong>不要忘记 Method1 后边的括号 ()，否则会引发编译器错误：<code>method recv.Method1 is not an expression, must be called</code></strong></p><p>​接收者必须有一个显式的名字，这个名字必须在方法中被使用。</p><p>​<strong>receiver_type</strong> 叫做 <strong>（接收者）基本类型</strong>，这个类型必须在和方法同样的包中被声明。</p><p>​在 Go 中，（接收者）类型关联的方法不写在类型结构里面，就像类那样；耦合更加宽松；类型和方法之间的关联由接收者来建立。</p><p>​<strong>方法没有和数据定义（结构体）混在一起：它们是正交的类型；表示（数据）和行为（方法）是独立的。</strong></p><p>​10.6.3指针或值作为接收者</p><p>​鉴于性能的原因，<code>recv</code> 最常见的是一个指向 receiver_type 的指针（因为我们不想要一个实例的拷贝，如果按值调用的话就会是这样），特别是在 receiver 类型是结构体时，就更是如此了。</p><p>如果想要方法改变接收者的数据，就在接收者的指针类型上定义该方法。否则，就在普通的值类型上定义方法。</p><p>​在值和指针上调用方法：</p><p>​可以有连接到类型的方法，也可以有连接到类型指针的方法。</p><p>​但是这没关系：对于类型 T，如果在 *T 上存在方法 <code>Meth()</code>，并且 <code>t</code> 是这个类型的变量，那么 <code>t.Meth()</code> 会被自动转换为 <code>(&amp;t).Meth()</code>。</p><p>​<strong>指针方法和值方法都可以在指针或非指针上被调用</strong></p><p>​10.6.4方法和为导出字段</p><p>​考虑 <code>person2.go</code> 中的 <code>person</code> 包：类型 <code>Person</code> 被明确的导出了，但是它的字段没有被导出。例如在 <code>use_person2.go</code> 中 <code>p.firstName</code> 就是错误的。该如何在另一个程序中修改或者只是读取一个 <code>Person</code> 的名字呢？</p><p>​这可以通过面向对象语言一个众所周知的技术来完成：提供 getter 和 setter 方法。对于 setter 方法使用 Set 前缀，对于 getter 方法只使用成员名。</p><p>​<strong>并发访问对象</strong></p><p>​对象的字段（属性）不应该由 2 个或 2 个以上的不同线程在同一时间去改变。如果在程序发生这种情况，为了安全并发访问，可以使用包 <code>sync</code>（参考第 9.3 节）中的方法。</p><p>​10.6.5内嵌类型的方法和继承</p><p>​当一个匿名类型被内嵌在结构体中时，匿名类型的可见方法也同样被内嵌，这在效果上等同于外层类型 <strong>继承</strong> 了这些方法：<strong>将父类型放在子类型中来实现亚型</strong>。这个机制提供了一种简单的方式来模拟经典面向对象语言中的子类和继承相关的效果，也类似 Ruby 中的混入（mixin）。</p><p>​内嵌将一个已存在类型的字段和方法注入到了另一个类型里：匿名字段上的方法“晋升”成为了外层类型的方法。当然类型可以有只作用于本身实例而不作用于内嵌“父”类型上的方法。</p><p>​可以覆写方法（像字段一样）：和内嵌类型方法具有同样名字的外层类型的方法会覆写内嵌类型对应的方法。</p><p>​结构体内嵌和自己在同一个包中的结构体时，可以彼此访问对方所有的字段和方法。</p><p>​10.6.6如何在类型中嵌入功能</p><p>​主要有两种方法来实现在类型中嵌入功能：</p><p>​A：聚合（或组合）：包含一个所需功能类型的具名字段。</p><p>​B：内嵌：内嵌（匿名地）所需功能类型，像前一节 10.6.5 所演示的那样。</p><p>​为了使这些概念具体化，假设有一个 <code>Customer</code> 类型，我们想让它通过 <code>Log</code> 类型来包含日志功能，<code>Log</code> 类型只是简单地包含一个累积的消息（当然它可以是复杂的）。如果想让特定类型都具备日志功能，你可以实现一个这样的 <code>Log</code> 类型，然后将它作为特定类型的一个字段，并提供 <code>Log()</code>，它返回这个日志的引用。</p><p>​内嵌的类型不需要指针，<code>Customer</code> 也不需要 <code>Add</code> 方法，它使用 <code>Log</code> 的 <code>Add</code> 方法，<code>Customer</code> 有自己的 <code>String</code> 方法，并且在它里面调用了 <code>Log</code> 的 <code>String</code> 方法。</p><p>​如果内嵌类型嵌入了其他类型，也是可以的，那些类型的方法可以直接在外层类型中使用。</p><p>​因此一个好的策略是创建一些小的、可复用的类型作为一个工具箱，用于组成域类型。</p><p>​10.6.7多重继承</p><p>​多重继承指的是类型获得多个父类型行为的能力，它在传统的面向对象语言中通常是不被实现的（C++ 和 Python 例外）。因为在类继承层次中，多重继承会给编译器引入额外的复杂度。但是在 Go 语言中，通过在类型中嵌入所有必要的父类型，可以很简单的实现多重继承。</p><p>​10.6.8通用方法和方法命名</p><p>​在编程中一些基本操作会一遍又一遍的出现，比如打开（Open）、关闭（Close）、读（Read）、写（Write）、排序（Sort）等等，并且它们都有一个大致的意思：打开（Open）可以作用于一个文件、一个网络连接、一个数据库连接等等。具体的实现可能千差万别，但是基本的概念是一致的。在 Go 语言中，通过使用接口（参考 第 11 章），标准库广泛的应用了这些规则，在标准库中这些通用方法都有一致的名字，比如 <code>Open()</code>、<code>Read()</code>、<code>Write()</code>等。想写规范的 Go 程序，就应该遵守这些约定，给方法合适的名字和签名，就像那些通用方法那样。这样做会使 Go 开发的软件更加具有一致性和可读性。比如：如果需要一个 convert-to-string 方法，应该命名为 <code>String()</code>，而不是 <code>ToString()</code></p><p>​10.6.9和其他面向对象语言比较Go的类型和方法</p><p>​在如 C++、Java、C# 和 Ruby 这样的面向对象语言中，方法在类的上下文中被定义和继承：在一个对象上调用方法时，运行时会检测类以及它的超类中是否有此方法的定义，如果没有会导致异常发生。</p><p>​在 Go 语言中，这样的继承层次是完全没必要的：如果方法在此类型定义了，就可以调用它，和其他类型上是否存在这个方法没有关系。在这个意义上，Go 具有更大的灵活性。</p><p><img src="https://raw.githubusercontent.com/unknwon/the-way-to-go_ZH_CN/master/eBook/images/10.6.9_fig10.4.jpg" alt="img"></p><p>​Go 不需要一个显式的类定义，如同 Java、C++、C# 等那样，相反地，“类”是通过提供一组作用于一个共同类型的方法集来隐式定义的。类型可以是结构体或者任何用户自定义类型。</p><p>​<strong>总结</strong></p><p>​在 Go 中，类型就是类（数据和关联的方法）。Go 不知道类似面向对象语言的类继承的概念。继承有两个好处：代码复用和多态。</p><p>​在 Go 中，代码复用通过组合和委托实现，多态通过接口的使用来实现：有时这也叫 <strong>组件编程（Component Programming）</strong>。</p><p>​许多开发者说相比于类继承，Go 的接口提供了更强大、却更简单的多态行为。</p><p>​10.7类型的String()方法和格式化描述符</p><p>​当定义了一个有很多方法的类型时，十之八九你会使用 <code>String()</code> 方法来定制类型的字符串形式的输出，换句话说：一种可阅读性和打印性的输出。如果类型定义了 <code>String()</code> 方法，它会被用在 <code>fmt.Printf()</code> 中生成默认的输出：等同于使用格式化描述符 <code>%v</code> 产生的输出。还有 <code>fmt.Print()</code> 和 <code>fmt.Println()</code> 也会自动使用 <code>String()</code> 方法。</p><p>​当你广泛使用一个自定义类型时，最好为它定义 <code>String()</code>方法。从上面的例子也可以看到，格式化描述符 <code>%T</code> 会给出类型的完全规格，<code>%#v</code> 会给出实例的完整输出，包括它的字段（在程序自动生成 <code>Go</code> 代码时也很有用）。</p><h6 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h6><p>​不要在 <code>String()</code> 方法里面调用涉及 <code>String()</code> 方法的方法，它会导致意料之外的错误。</p><p>​10.8垃圾回收和SetFinalizer</p><p>​Go 开发者不需要写代码来释放程序中不再使用的变量和结构占用的内存，在 Go 运行时中有一个独立的进程，即垃圾收集器（GC），会处理这些事情，它搜索不再使用的变量然后释放它们的内存。可以通过 <code>runtime</code> 包访问 GC 进程。</p><p>​通过调用 <code>runtime.GC()</code> 函数可以显式的触发 GC，但这只在某些罕见的场景下才有用，比如当内存资源不足时调用 <code>runtime.GC()</code>，它会在此函数执行的点上立即释放一大片内存，此时程序可能会有短时的性能下降（因为 <code>GC</code> 进程在执行）。</p><p>​如果想知道当前的内存状态，可以使用：</p><pre><code class="hljs">// fmt.Printf(&quot;%d\n&quot;, runtime.MemStats.Alloc/1024)// 此处代码在 Go 1.5.1下不再有效，更正为var m runtime.MemStatsruntime.ReadMemStats(&amp;m)fmt.Printf(&quot;%d Kb\n&quot;, m.Alloc / 1024)</code></pre><p>​上面的程序会给出已分配内存的总量，单位是 Kb。</p><p>​如果需要在一个对象 obj 被从内存移除前执行一些特殊操作，比如写到日志文件中，可以通过如下方式调用函数来实现：</p><pre><code class="hljs">runtime.SetFinalizer(obj, func(obj *typeObj))</code></pre><p>​<code>func(obj *typeObj)</code> 需要一个 <code>typeObj</code> 类型的指针参数 <code>obj</code>，特殊操作会在它上面执行。<code>func</code> 也可以是一个匿名函数。</p><p>​在对象被 GC 进程选中并从内存中移除以前，<code>SetFinalizer</code> 都不会执行，即使程序正常结束或者发生错误。</p><p>​如果需要在一个对象 obj 被从内存移除前执行一些特殊操作，比如写到日志文件中，可以通过如下方式调用函数来实现：</p><pre><code class="hljs">runtime.SetFinalizer(obj, func(obj *typeObj))</code></pre><p>​<code>func(obj *typeObj)</code> 需要一个 <code>typeObj</code> 类型的指针参数 <code>obj</code>，特殊操作会在它上面执行。<code>func</code> 也可以是一个匿名函数。</p><p>在对象被 GC 进程选中并从内存中移除以前，<code>SetFinalizer</code> 都不会执行，即使程序正常结束或者发生错误。</p><p>11.0 接口（interface）与反射（reflection）</p><p>​11.1接口是什么</p><p>​通过如下格式来定义接口：</p><pre><code class="hljs">type Namer interface &#123;Method1(param_list) return_typeMethod2(param_list) return_type...&#125;</code></pre><p>​上面的Namer是一个接口类型</p><p>​（按照约定，只包含一个方法的）接口的名字由方法名加 <code>er</code> 后缀组成，例如 <code>Printer</code>、<code>Reader</code>、<code>Writer</code>、<code>Logger</code>、<code>Converter</code> 等等。还有一些不常用的方式（当后缀 <code>er</code> 不合适时），比如 <code>Recoverable</code>，此时接口名以 <code>able</code> 结尾，或者以 <code>I</code> 开头（像 <code>.NET</code> 或 <code>Java</code> 中那样）。</p><p>​不像大多数面向对象编程语言，在 Go 语言中接口可以有值，一个接口类型的变量或一个 <strong>接口值</strong> ：<code>var ai Namer</code>，<code>ai</code> 是一个多字（multiword）数据结构，它的值是 <code>nil</code>。它本质上是一个指针，虽然不完全是一回事。指向接口值的指针是非法的，它们不仅一点用也没有，还会导致代码错误。</p><p><img src="https://raw.githubusercontent.com/unknwon/the-way-to-go_ZH_CN/master/eBook/images/11.1_fig11.1.jpg" alt="img"></p><p>​类型（比如结构体）可以实现某个接口的方法集；这个实现可以描述为，该类型的变量上的每一个具体方法所组成的集合，包含了该接口的方法集。实现了 <code>Namer</code> 接口的类型的变量可以赋值给 <code>ai</code>（即 <code>receiver</code> 的值），方法表指针（method table ptr）就指向了当前的方法实现。当另一个实现了 <code>Namer</code> 接口的类型的变量被赋给 <code>ai</code>，<code>receiver</code> 的值和方法表指针也会相应改变。</p><h6 id="类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。"><a href="#类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。" class="headerlink" title="类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。"></a>类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。</h6><h6 id="实现某个接口的类型（除了实现接口方法外）可以有其他的方法。"><a href="#实现某个接口的类型（除了实现接口方法外）可以有其他的方法。" class="headerlink" title="实现某个接口的类型（除了实现接口方法外）可以有其他的方法。"></a>实现某个接口的类型（除了实现接口方法外）可以有其他的方法。</h6><h6 id="一个类型可以实现多个接口。"><a href="#一个类型可以实现多个接口。" class="headerlink" title="一个类型可以实现多个接口。"></a>一个类型可以实现多个接口。</h6><h6 id="接口类型可以包含一个实例的引用，-该实例的类型实现了此接口（接口是动态类型）。"><a href="#接口类型可以包含一个实例的引用，-该实例的类型实现了此接口（接口是动态类型）。" class="headerlink" title="接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。"></a>接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。</h6><h5 id="一个标准库的例子："><a href="#一个标准库的例子：" class="headerlink" title="一个标准库的例子："></a>一个标准库的例子：</h5><p>​io包里有一个接口类型：</p><pre><code class="hljs">type Reader interface &#123;Read(p []byte) (n int, err error)&#125;</code></pre><p>​定义变量r : var r io.Reader</p><p>​那么就可以写如下代码：</p><pre><code class="hljs">    var r io.Reader    r = os.Stdin    // see 12.1    r = bufio.NewReader(r)    r = new(bytes.Buffer)    f,_ := os.Open(&quot;test.txt&quot;)    r = bufio.NewReader(f)</code></pre><p>​上面 <code>r</code> 右边的类型都实现了 <code>Read()</code> 方法，并且有相同的方法签名，<code>r</code> 的静态类型是 <code>io.Reader</code>。</p><p>​11.2接口嵌套接口</p><p>​一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。</p><p>​比如接口 <code>File</code> 包含了 <code>ReadWrite</code> 和 <code>Lock</code> 的所有方法，它还额外有一个 <code>Close()</code> 方法。</p><pre><code class="hljs">type ReadWrite interface &#123;Read(b Buffer) boolWrite(b Buffer) bool&#125;type Lock interface &#123;    Lock()    Unlock()&#125;type File interface &#123;    ReadWrite    Lock    Close()&#125;</code></pre><p>​11.3类型断言：如何检测和转换接口变量的类型</p><p>​一个接口类型的变量 <code>varI</code> 中可以包含任何类型的值，必须有一种方式来检测它的 <strong>动态</strong> 类型，即运行时在变量中存储的值的实际类型。在执行过程中动态类型可能会有所不同，但是它总是可以分配给接口变量本身的类型。通常我们可以使用 <strong>类型断言</strong> 来测试在某个时刻 <code>varI</code> 是否包含类型 <code>T</code> 的值：</p><pre><code class="hljs">v := varI.(T)       // unchecked type assertion</code></pre><p>​varI 必须是一个接口变量，否则编译器会报错：<code>invalid type assertion: varI.(T) (non-interface type (type of varI) on left)</code> 。</p><p>​类型断言可能是无效的，虽然编译器会尽力检查转换是否有效，但是它不可能预见所有的可能性。如果转换在程序运行时失败会导致错误发生。更安全的方式是使用以下形式来进行类型断言：</p><pre><code class="hljs">if v, ok := varI.(T); ok &#123;  // checked type assertionProcess(v)return&#125;// varI is not of type T</code></pre><p>​如果转换合法，<code>v</code> 是 <code>varI</code> 转换到类型 <code>T</code> 的值，<code>ok</code> 会是 <code>true</code>；否则 <code>v</code> 是类型 <code>T</code> 的零值，<code>ok</code> 是 <code>false</code>，也没有运行时错误发生。</p><h6 id="应该总是使用上面的方式来进行类型断言。"><a href="#应该总是使用上面的方式来进行类型断言。" class="headerlink" title="应该总是使用上面的方式来进行类型断言。"></a>应该总是使用上面的方式来进行类型断言。</h6><p>​多数情况下，我们可能只是想在 <code>if</code> 中测试一下 <code>ok</code> 的值，此时使用以下的方法会是最方便的：</p><pre><code class="hljs">if _, ok := varI.(T); ok &#123;// ...&#125;</code></pre><p>​11.4类型判断：type-swith</p><p>​接口变量的类型也可以使用一种特殊形式的 <code>switch</code> 来检测：<strong>type-switch</strong> </p><pre><code class="hljs">switch t := areaIntf.(type) &#123;case *Square:    fmt.Printf(&quot;Type Square %T with value %v\n&quot;, t, t)case *Circle:    fmt.Printf(&quot;Type Circle %T with value %v\n&quot;, t, t)case nil:    fmt.Printf(&quot;nil value: nothing to check?\n&quot;)default:    fmt.Printf(&quot;Unexpected type %T\n&quot;, t)&#125;</code></pre><p>​输出：</p><p>​Type Square *main.Square with value &amp;{5}</p><p>​变量 <code>t</code> 得到了 <code>areaIntf</code> 的值和类型，所有 <code>case</code> 语句中列举的类型（<code>nil</code> 除外）都必须实现对应的接口（在上例中即 <code>Shaper</code>），如果被检测类型没有在 <code>case</code> 语句列举的类型中，就会执行 <code>default</code> 语句。</p><p>可以用 <code>type-switch</code> 进行运行时类型分析，但是在 <code>type-switch</code> 不允许有 <code>fallthrough</code> 。</p><p>如果仅仅是测试变量的类型，不用它的值，那么就可以不需要赋值语句，比如：</p><pre><code class="hljs">switch areaIntf.(type) &#123;case *Square:    // TODOcase *Circle:    // TODO...default:    // TODO&#125;</code></pre><p>​在处理来自于外部的、类型未知的数据时，比如解析诸如 JSON 或 XML 编码的数据，类型测试和转换会非常有用。</p><p>​11.5测试一个值是否实现了接口</p><p>​这是 11.3 类型断言中的一个特例：假定 <code>v</code> 是一个值，然后我们想测试它是否实现了 <code>Stringer</code> 接口，可以这样做：</p><pre><code class="hljs">type Stringer interface &#123;String() string&#125;if sv, ok := v.(Stringer); ok &#123;    fmt.Printf(&quot;v implements String(): %s\n&quot;, sv.String()) // note: sv, not v&#125;</code></pre><p>​<code>Print</code> 函数就是如此检测类型是否可以打印自身的。</p><p>接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。</p><p>​编写参数是接口变量的函数，这使得它们更具有一般性。</p><p>​<strong>使用接口使代码更具有普适性。</strong></p><p>​标准库里到处都使用了这个原则，如果对接口概念没有良好的把握，是不可能理解它是如何构建的。</p><p>​11.6使用方法集和接口</p><p>​作用于变量上的方法实际上是不区分变量到底是指针还是值的。当碰到接口类型值时，这会变得有点复杂，原因是接口变量中存储的具体值是不可寻址的，幸运的是，如果使用不当编译器会给出错误。</p><p>​<strong>总结</strong></p><p>在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以根据具体类型 <code>P</code> 直接辨识的：</p><ul><li>指针方法可以通过指针调用</li><li>值方法可以通过值调用</li><li>接收者是值的方法可以通过指针调用，因为指针会首先被解引用</li><li>接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址</li></ul><p>将一个值赋值给一个接口时，编译器会确保所有可能的接口方法都可以在此值上被调用，因此不正确的赋值在编译期就会失败。</p><p>​11.7第一个例子：使用Sorter接口排序</p><p>​11.8第二个例子：读和写</p><p>​读和写是软件中很普遍的行为，提起它们会立即想到读写文件、缓存（比如字节或字符串切片）、标准输入输出、标准错误以及网络连接、管道等等，或者读写我们的自定义类型。为了让代码尽可能通用，Go 采取了一致的方式来读写数据。</p><p>​<code>io</code> 包提供了用于读和写的接口 <code>io.Reader</code> 和 <code>io.Writer</code>：</p><pre><code class="hljs">type Reader interface &#123;Read(p []byte) (n int, err error)&#125;type Writer interface &#123;    Write(p []byte) (n int, err error)&#125;</code></pre><p>​只要类型实现了读写接口，提供 <code>Read</code> 和 <code>Write</code> 方法，就可以从它读取数据，或向它写入数据。一个对象要是可读的，它必须实现 <code>io.Reader</code> 接口，这个接口只有一个签名是 <code>Read(p []byte) (n int, err error)</code> 的方法，它从调用它的对象上读取数据，并把读到的数据放入参数中的字节切片中，然后返回读取的字节数和一个 <code>error</code> 对象，如果没有错误发生返回 <code>nil</code>，如果已经到达输入的尾端，会返回 <code>io.EOF(&quot;EOF&quot;)</code>，如果读取的过程中发生了错误，就会返回具体的错误信息。类似地，一个对象要是可写的，它必须实现 <code>io.Writer</code> 接口，这个接口也只有一个签名是 <code>Write(p []byte) (n int, err error)</code> 的方法，它将指定字节切片中的数据写入调用它的对象里，然后返回实际写入的字节数和一个 <code>error</code> 对象（如果没有错误发生就是 <code>nil</code>）。</p><p><code>io</code> 包里的 <code>Readers</code> 和 <code>Writers</code> 都是不带缓冲的，<code>bufio</code> 包里提供了对应的带缓冲的操作，在读写 <code>UTF-8</code> 编码的文本文件时它们尤其有用。在 第12章 我们会看到很多在实战中使用它们的例子。</p><p>​在实际编程中尽可能的使用这些接口，会使程序变得更通用，可以在任何实现了这些接口的类型上使用读写方法。</p><p>​例如一个 <code>JPEG</code> 图形解码器，通过一个 <code>Reader</code> 参数，它可以解码来自磁盘、网络连接或以 <code>gzip</code> 压缩的 <code>HTTP</code> 流中的 <code>JPEG</code> 图形数据，或者其他任何实现了 <code>Reader</code> 接口的对象。</p><p>​11.9空接口</p><p>​11.9.1概念</p><p>​<strong>空接口或者最小接口</strong> 不包含任何方法，它对实现不做任何要求：</p><pre><code class="hljs">type Any interface &#123;&#125;</code></pre><p>​任何其他类型都实现了空接口（它不仅仅像 <code>Java/C#</code> 中 <code>Object</code> 引用类型），<code>any</code> 或 <code>Any</code> 是空接口一个很好的别名或缩写。</p><p>​空接口类似 <code>Java/C#</code> 中所有类的基类： <code>Object</code> 类，二者的目标也很相近。</p><p>​可以给一个空接口类型的变量 <code>var val interface &#123;&#125;</code> 赋任何类型的值。</p><p>​11.9.2构建通用类型或包含不同类型变量的数组</p><p>​给空接口定一个别名类型 <code>Element</code>：<code>type Element interface&#123;&#125;</code></p><p>​然后定义一个容器类型的结构体 <code>Vector</code>，它包含一个 <code>Element</code> 类型元素的切片：</p><pre><code class="hljs">type Vector struct &#123;a []Element&#125;</code></pre><p>​<code>Vector</code> 里能放任何类型的变量，因为任何类型都实现了空接口，实际上 <code>Vector</code> 里放的每个元素可以是不同类型的变量。我们为它定义一个 <code>At()</code> 方法用于返回第 <code>i</code> 个元素：</p><pre><code class="hljs">func (p *Vector) At(i int) Element &#123;return p.a[i]&#125;</code></pre><p>​再定一个 <code>Set()</code> 方法用于设置第 <code>i</code> 个元素的值：</p><pre><code class="hljs">func (p *Vector) Set(i int, e Element) &#123;p.a[i] = e&#125;</code></pre><p>​<code>Vector</code> 中存储的所有元素都是 <code>Element</code> 类型，要得到它们的原始类型（unboxing：拆箱）需要用到类型断言。TODO：The compiler rejects assertions guaranteed to fail，类型断言总是在运行时才执行，因此它会产生运行时错误。</p><p>​11.9.3复制数据切片至接口切片</p><p>​假设你有一个 <code>myType</code> 类型的数据切片，你想将切片中的数据复制到一个空接口切片中，类似：</p><pre><code class="hljs">var dataSlice []myType = FuncReturnSlice()var interfaceSlice []interface&#123;&#125; = dataSlice</code></pre><p>​编译时会出错：<code>cannot use dataSlice (type []myType) as type []interface &#123; &#125; in assignment</code>。</p><p>​原因是它们俩在内存中的布局是不一样的（参考 <a href="https://github.com/golang/go/wiki/InterfaceSlice">Go wiki</a>）。</p><p>​必须使用 <code>for-range</code> 语句来一个一个显式地赋值：</p><pre><code class="hljs">var dataSlice []myType = FuncReturnSlice()var interfaceSlice []interface&#123;&#125; = make([]interface&#123;&#125;, len(dataSlice))for i, d := range dataSlice &#123;    interfaceSlice[i] = d&#125;</code></pre><p>​11.9.4通用类型的节点数据结构</p><p>​下面是实现一个二叉树的部分代码：通用定义、用于创建空节点的 <code>NewNode</code> 方法，及设置数据的 <code>SetData</code> 方法。</p><p>​11.9.5接口到接口</p><p>​一个接口的值可以赋值给另一个接口变量，只要底层类型实现了必要的方法。这个转换是在运行时进行检查的，转换失败会导致一个运行时错误：这是 <code>Go</code> 语言动态的一面，可以拿它和 <code>Ruby</code> 和 <code>Python</code> 这些动态语言相比较。</p><p>​110.10反射包</p><p>​11.10.1方法和类型的反射</p><p>​11.10.2</p><p>​反射是用程序检查其所拥有的结构，尤其是类型的一种能力；这是元编程的一种形式。反射可以在运行时检查类型和变量，例如它的大小、方法和 <code>动态</code> 的调用这些方法。这对于没有源代码的包尤其有用。这是一个强大的工具，除非真得有必要，否则应当避免使用或小心使用。</p><p>​变量的最基本信息就是类型和值：反射包的 <code>Type</code> 用来表示一个 Go 类型，反射包的 <code>Value</code> 为 Go 值提供了反射接口。</p><p>​两个简单的函数，<code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code>，返回被检查对象的类型和值。例如，x 被定义为：<code>var x float64 = 3.4</code>，那么 <code>reflect.TypeOf(x)</code> 返回 <code>float64</code>，<code>reflect.ValueOf(x)</code> 返回 <code>&lt;float64 Value&gt;</code></p><p>​实际上，反射是通过检查一个接口的值，变量首先被转换成空接口。这从下面两个函数签名能够很明显的看出来：</p><pre><code class="hljs">func TypeOf(i interface&#123;&#125;) Typefunc ValueOf(i interface&#123;&#125;) Value</code></pre><p>​接口的值包含一个 type 和 value。</p><p>​反射可以从接口值反射到对象，也可以从对象反射回接口值。</p><p>​reflect.Type 和 reflect.Value 都有许多方法用于检查和操作它们。一个重要的例子是 Value 有一个 Type 方法返回 reflect.Value 的 Type。另一个是 Type 和 Value 都有 Kind 方法返回一个常量来表示类型：Uint、Float64、Slice 等等。同样 Value 有叫做 Int 和 Float 的方法可以获取存储在内部的值（跟 int64 和 float64 一样）</p><p>​11.10.3反射结构</p><p>​有些时候需要反射一个结构类型。<code>NumField()</code> 方法返回结构内的字段数量；通过一个 for 循环用索引取得每个字段的值 <code>Field(i)</code>。</p><p>​我们同样能够调用签名在结构上的方法，例如，使用索引 n 来调用：<code>Method(n).Call(nil)</code>。</p><p>​11.11Printf和反射</p><p>​在 Go 语言的标准库中，前几节所述的反射的功能被大量地使用。举个例子，fmt 包中的 Printf（以及其他格式化输出函数）都会使用反射来分析它的 <code>...</code> 参数。</p><p>​Printf 的函数声明为：</p><pre><code class="hljs">func Printf(format string, args ... interface&#123;&#125;) (n int, err error)</code></pre><p>​11.12接口和动态类型</p><p>​11.12.1Go的动态类型</p><p>​在经典的面向对象语言（像 C++，Java 和 C#）中数据和方法被封装为 <code>类</code> 的概念：类包含它们两者，并且不能剥离。</p><p>​Go 没有类：数据（结构体或更一般的类型）和方法是一种松耦合的正交关系。</p><p>​Go 中的接口跟 Java&#x2F;C# 类似：都是必须提供一个指定方法集的实现。但是更加灵活通用：任何提供了接口方法实现代码的类型都隐式地实现了该接口，而不用显式地声明。</p><p>​和其它语言相比，Go 是唯一结合了接口值，静态类型检查（是否该类型实现了某个接口），运行时动态转换的语言，并且不需要显式地声明类型是否满足某个接口。该特性允许我们在不改变已有的代码的情况下定义和使用新接口。</p><p>​接收一个（或多个）接口类型作为参数的函数，其<strong>实参</strong>可以是任何实现了该接口的类型的变量。 <code>实现了某个接口的类型可以被传给任何以此接口为参数的函数</code> 。</p><p>​类似于 Python 和 Ruby 这类动态语言中的 <code>动态类型（duck typing）</code>；这意味着对象可以根据提供的方法被处理（例如，作为参数传递给函数），而忽略它们的实际类型：它们能做什么比它们是什么更重要。</p><p>​11.12.2动态方法调用</p><p>​像 Python，Ruby 这类语言，动态类型是延迟绑定的（在运行时进行）：方法只是用参数和变量简单地调用，然后在运行时才解析（它们很可能有像 <code>responds_to</code> 这样的方法来检查对象是否可以响应某个方法，但是这也意味着更大的编码量和更多的测试工作）</p><p>​Go 的实现与此相反，通常需要编译器静态检查的支持：当变量被赋值给一个接口类型的变量时，编译器会检查其是否实现了该接口的所有函数。如果方法调用作用于像 <code>interface&#123;&#125;</code> 这样的“泛型”上，你可以通过类型断言（参见 11.3 节）来检查变量是否实现了相应接口。</p><p>​例如，你用不同的类型表示 XML 输出流中的不同实体。然后我们为 XML 定义一个如下的“写”接口（甚至可以把它定义为私有接口）：</p><pre><code class="hljs">type xmlWriter interface &#123;WriteXML(w io.Writer) error&#125;</code></pre><p>​现在我们可以实现适用于该流类型的任何变量的 <code>StreamXML</code> 函数，并用类型断言检查传入的变量是否实现了该接口；如果没有，我们就调用内建的 <code>encodeToXML</code> 来完成相应工作：</p><pre><code class="hljs">// Exported XML streaming function.func StreamXML(v interface&#123;&#125;, w io.Writer) error &#123;    if xw, ok := v.(xmlWriter); ok &#123;        // It’s an  xmlWriter, use method of asserted type.        return xw.WriteXML(w)    &#125;    // No implementation, so we have to use our own function (with perhaps reflection):    return encodeToXML(v, w)&#125;// Internal XML encoding function.func encodeToXML(v interface&#123;&#125;, w io.Writer) error &#123;    // ...&#125;</code></pre><p>​Go 在这里用了和 <code>gob</code> 相同的机制：定义了两个接口 <code>GobEncoder</code> 和 <code>GobDecoder</code>。这样就允许类型自己实现从流编解码的具体方式；如果没有实现就使用标准的反射方式。</p><p>​因此 Go 提供了动态语言的优点，却没有其他动态语言在运行时可能发生错误的缺点。</p><p>​对于动态语言非常重要的单元测试来说，这样即可以减少单元测试的部分需求，又可以发挥相当大的作用。</p><p>​Go 的接口提高了代码的分离度，改善了代码的复用性，使得代码开发过程中的设计模式更容易实现。用 Go 接口还能实现 <code>依赖注入模式</code>。</p><p>​11.12.3接口的提取</p><p>​<code>提取接口</code> 是非常有用的设计模式，可以减少需要的类型和方法数量，而且不需要像传统的基于类的面向对象语言那样维护整个的类层次结构。</p><p>​Go 接口可以让开发者找出自己写的程序中的类型。假设有一些拥有共同行为的对象，并且开发者想要抽象出这些行为，这时就可以创建一个接口来使用。</p><p>​所以你不用提前设计出所有的接口；<code>整个设计可以持续演进，而不用废弃之前的决定</code>。类型要实现某个接口，它本身不用改变，你只需要在这个类型上实现新的方法。</p><p>​11.12.4显示地指明类型实现了某个接口</p><p>​如果你希望满足某个接口的类型显式地声明它们实现了这个接口，你可以向接口的方法集中添加一个具有描述性名字的方法。例如：</p><pre><code class="hljs">type Fooer interface &#123;Foo()ImplementsFooer()&#125;</code></pre><p>​类型 Bar 必须实现 <code>ImplementsFooer</code> 方法来满足 <code>Fooer</code> 接口，以清楚地记录这个事实。</p><pre><code class="hljs">type Bar struct&#123;&#125;func (b Bar) ImplementsFooer() &#123;&#125;func (b Bar) Foo() &#123;&#125;</code></pre><p>​大部分代码并不使用这样的约束，因为它限制了接口的实用性。</p><p>​但是有些时候，这样的约束在大量相似的接口中被用来解决歧义。</p><p>​11.12.5空接口和函数重载</p><p>​在 Go 语言中函数重载可以用可变参数 <code>...T</code> 作为函数最后一个参数来实现（参见 6.3 节）。如果我们把 T 换为空接口，那么可以知道任何类型的变量都是满足 T (空接口）类型的，这样就允许我们传递任何数量任何类型的参数给函数，即重载的实际含义。</p><p>​函数 <code>fmt.Printf</code> 就是这样做的：</p><pre><code class="hljs">fmt.Printf(format string, a ...interface&#123;&#125;) (n int, errno error)</code></pre><p>​这个函数通过枚举 <code>slice</code> 类型的实参动态确定所有参数的类型，并查看每个类型是否实现了 <code>String()</code> 方法，如果是就用于产生输出信息。</p><p>​11.12.6接口的继承</p><p>​当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。</p><p>​例如：</p><pre><code class="hljs">type Task struct &#123;Command string*log.Logger&#125;</code></pre><p>​这个类型的工厂方法像这样：</p><pre><code class="hljs">func NewTask(command string, logger *log.Logger) *Task &#123;return &amp;Task&#123;command, logger&#125;&#125;</code></pre><p>​当 <code>log.Logger</code> 实现了 <code>Log()</code> 方法后，Task 的实例 task 就可以调用该方法：</p><pre><code class="hljs">task.Log()</code></pre><p>​类型可以通过继承多个接口来提供像 <code>多重继承</code> 一样的特性：</p><pre><code class="hljs">type ReaderWriter struct &#123;*io.Reader*io.Writer&#125;</code></pre><p>​上面概述的原理被应用于整个 Go 包，多态用得越多，代码就相对越少（参见 12.8 节）。这被认为是 Go 编程中的重要的最佳实践。</p><p>​有用的接口可以在开发的过程中被归纳出来。添加新接口非常容易，因为已有的类型不用变动（仅仅需要实现新接口的方法）。已有的函数可以扩展为使用接口类型的约束性参数：通常只有函数签名需要改变。对比基于类的 OO 类型的语言在这种情况下则需要适应整个类层次结构的变化。</p><p>​11.13总结：Go中的面向对象</p><p>​我们总结一下前面看到的：Go 没有类，而是松耦合的类型、方法对接口的实现。</p><p>OO 语言最重要的三个方面分别是：封装，继承和多态，在 Go 中它们是怎样表现的呢？</p><ul><li><p>封装（数据隐藏）：和别的 OO 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层（参见 4.2 节的可见性规则）:</p><p>1）包范围内的：通过标识符首字母小写，<code>对象</code> 只在它所在的包内可见</p><p>2）可导出的：通过标识符首字母大写，<code>对象</code> 对所在包以外也可见</p></li></ul><p>类型只拥有自己所在包中定义的方法。</p><ul><li><p>继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现</p></li><li><p>多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。Go 接口不是 Java 和 C# 接口的变体，而且接口间是不相关的，并且是大规模编程和可适应的演进型设计的关键。</p><p>11.14结构体、集合和高阶函数</p><p>通常你在应用中定义了一个结构体，那么你也可能需要这个结构体的（指针）对象集合，比如：</p><p>type Any interface{}<br>type Car struct {<br>Model        string<br>Manufacturer string<br>BuildYear    int<br>&#x2F;&#x2F; …<br>}</p><p>type Cars []*Car<br>​然后我们就可以使用高阶函数，实际上也就是把函数作为定义所需方法（其他函数）的参数，例如：</p></li></ul><p>​1）定义一个通用的 <code>Process()</code> 函数，它接收一个作用于每一辆 car 的 f 函数作参数：</p><pre><code class="hljs">// Process all cars with the given function f:func (cs Cars) Process(f func(car *Car)) &#123;    for _, c := range cs &#123;        f(c)    &#125;&#125;</code></pre><p>​2）在上面的基础上，实现一个查找函数来获取子集合，并在 <code>Process()</code> 中传入一个闭包执行（这样就可以访问局部切片 <code>cars</code>）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Find all cars matching a given criteria.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs Cars)</span></span> FindAll(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(car *Car)</span></span> <span class="hljs-type">bool</span>) Cars &#123;<br><br>cars := <span class="hljs-built_in">make</span>([]*Car, <span class="hljs-number">0</span>)<br>cs.Process(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Car)</span></span> &#123;<br><span class="hljs-keyword">if</span> f(c) &#123;<br>cars = <span class="hljs-built_in">append</span>(cars, c)<br>&#125;<br>&#125;)<br><span class="hljs-keyword">return</span> cars<br>&#125;<br></code></pre></td></tr></table></figure><p>​3）实现 Map 功能，产出除 car 对象以外的东西：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Process cars and create new data.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs Cars)</span></span> Map(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(car *Car)</span></span> Any) []Any &#123;<br>result := <span class="hljs-built_in">make</span>([]Any, <span class="hljs-number">0</span>)<br>ix := <span class="hljs-number">0</span><br>cs.Process(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Car)</span></span> &#123;<br>result[ix] = f(c)<br>ix++<br>&#125;)<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>​现在我们可以定义下面这样的具体查询：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">allNewBMWs := allCars.FindAll(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(car *Car)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> (car.Manufacturer == <span class="hljs-string">&quot;BMW&quot;</span>) &amp;&amp; (car.BuildYear &gt; <span class="hljs-number">2010</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>​4）我们也可以根据参数返回不同的函数。也许我们想根据不同的厂商添加汽车到不同的集合，但是这（这种映射关系）可能会是会改变的。所以我们可以定义一个函数来产生特定的添加函数和 map 集：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeSortedAppender</span><span class="hljs-params">(manufacturers []<span class="hljs-type">string</span>)</span></span>(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(car *Car)</span></span>,<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Cars) &#123;<br><span class="hljs-comment">// Prepare maps of sorted cars.</span><br>sortedCars := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Cars)<br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> manufacturers &#123;<br>sortedCars[m] = <span class="hljs-built_in">make</span>([]*Car, <span class="hljs-number">0</span>)<br>&#125;<br>sortedCars[<span class="hljs-string">&quot;Default&quot;</span>] = <span class="hljs-built_in">make</span>([]*Car, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Prepare appender function:</span><br>appender := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Car)</span></span> &#123;<br><span class="hljs-keyword">if</span> _, ok := sortedCars[c.Manufacturer]; ok &#123;<br>sortedCars[c.Manufacturer] = <span class="hljs-built_in">append</span>(sortedCars[c.Manufacturer], c)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>sortedCars[<span class="hljs-string">&quot;Default&quot;</span>] = <span class="hljs-built_in">append</span>(sortedCars[<span class="hljs-string">&quot;Default&quot;</span>], c)<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> appender, sortedCars<br>&#125;<br></code></pre></td></tr></table></figure><p>​现在我们可以用它把汽车分类为独立的集合，像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">manufacturers := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Ford&quot;</span>, <span class="hljs-string">&quot;Aston Martin&quot;</span>, <span class="hljs-string">&quot;Land Rover&quot;</span>, <span class="hljs-string">&quot;BMW&quot;</span>, <span class="hljs-string">&quot;Jaguar&quot;</span>&#125;<br>sortedAppender, sortedCars := MakeSortedAppender(manufacturers)<br>allUnsortedCars.Process(sortedAppender)<br>BMWCount := <span class="hljs-built_in">len</span>(sortedCars[<span class="hljs-string">&quot;BMW&quot;</span>])<br></code></pre></td></tr></table></figure><p>​我们让这些代码在下面的程序 cars.go 中执行：</p><h5 id="12-0-读取数据"><a href="#12-0-读取数据" class="headerlink" title="12.0 读取数据"></a>12.0 读取数据</h5><p>​12.1读取用户的输入</p><p>​<code>Scanln</code> 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。<code>Scanf</code> 与其类似，除了 <code>Scanf</code> 的第一个参数用作格式字符串，用来决定如何读取。<code>Sscan</code> 和以 <code>Sscan</code> 开头的函数则是从字符串读取，除此之外，与 <code>Scanf</code> 相同。如果这些函数读取到的结果与您预想的不同，您可以检查成功读入数据的个数和返回的错误。</p><p>​12.2文件读写</p><p>​12.2.1读文件</p><p>​在 Go 语言中，文件使用指向 <code>os.File</code> 类型的指针来表示的，也叫做文件句柄。我们在前面章节使用到过标准输入 <code>os.Stdin</code> 和标准输出 <code>os.Stdout</code>，他们的类型都是 <code>*os.File</code>。</p><p>​变量 <code>inputFile</code> 是 <code>*os.File</code> 类型的。该类型是一个结构，表示一个打开文件的描述符（文件句柄）。然后，使用 <code>os</code> 包里的 <code>Open</code> 函数来打开一个文件。该函数的参数是文件名，类型为 <code>string</code>。在上面的程序中，我们以只读模式打开 <code>input.dat</code> 文件。</p><p>​如果文件不存在或者程序没有足够的权限打开这个文件，Open函数会返回一个错误：<code>inputFile, inputError = os.Open(&quot;input.dat&quot;)</code>。如果文件打开正常，我们就使用 <code>defer inputFile.Close()</code> 语句确保在程序退出前关闭该文件。然后，我们使用 <code>bufio.NewReader</code> 来获得一个读取器变量。</p><p>​通过使用 <code>bufio</code> 包提供的读取器（写入器也类似），如上面程序所示，我们可以很方便的操作相对高层的 string 对象，而避免了去操作比较底层的字节。</p><p>​接着，我们在一个无限循环中使用 <code>ReadString(&#39;\n&#39;)</code> 或 <code>ReadBytes(&#39;\n&#39;)</code> 将文件的内容逐行（行结束符 ‘\n’）读取出来。</p><p>​<strong>注意：</strong> 在之前的例子中，我们看到，Unix 和 Linux 的行结束符是 \n，而 Windows 的行结束符是 \r\n。在使用 <code>ReadString</code> 和 <code>ReadBytes</code> 方法的时候，我们不需要关心操作系统的类型，直接使用 \n 就可以了。另外，我们也可以使用 <code>ReadLine()</code> 方法来实现相同的功能。</p><p>​一旦读取到文件末尾，变量 <code>readerError</code> 的值将变成非空（事实上，其值为常量 <code>io.EOF</code>），我们就会执行 <code>return</code> 语句从而退出循环。</p><p>​其他类似函数：</p><p>​1) 将整个文件的内容读到一个字符串里：</p><p>​如果您想这么做，可以使用 <code>io/ioutil</code> 包里的 <code>ioutil.ReadFile()</code> 方法，该方法第一个返回值的类型是 <code>[]byte</code>，里面存放读取到的内容，第二个返回值是错误，如果没有错误发生，第二个返回值为 nil。请看示例 12.5。类似的，函数 <code>WriteFile()</code> 可以将 <code>[]byte</code> 的值写入文件。</p><p>​2)带缓冲的读取</p><p>​在很多情况下，文件的内容是不按行划分的，或者干脆就是一个二进制文件。在这种情况下，<code>ReadString()</code>就无法使用了，我们可以使用 <code>bufio.Reader</code> 的 <code>Read()</code>，它只接收一个参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br>...<br>n, err := inputReader.Read(buf)<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">break</span>&#125;<br></code></pre></td></tr></table></figure><p>​变量 n 的值表示读取到的字节数.</p><p>​3) 按列读取文件中的数据</p><p>如果数据是按列排列并用空格分隔的，你可以使用 <code>fmt</code> 包提供的以 FScan 开头的一系列函数来读取他们。请看以下程序，我们将 3 列的数据分别读入变量 v1、v2 和 v3 内，然后分别把他们添加到切片的尾部。</p><p>​12.2.2compress包：读取压缩文件</p><p>​<code>compress</code>包提供了读取压缩文件的功能，支持的压缩文件格式为：bzip2、flate、gzip、lzw 和 zlib。</p><p>​12.2.3写文件</p><p>​除了文件句柄，我们还需要 <code>bufio</code> 的 <code>Writer</code>。我们以只写模式打开文件 <code>output.dat</code>，如果文件不存在则自动创建：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">outputFile, outputError := <span class="hljs-built_in">os</span>.OpenFile(<span class="hljs-string">&quot;output.dat&quot;</span>, <span class="hljs-built_in">os</span>.O_WRONLY|<span class="hljs-built_in">os</span>.O_CREATE, <span class="hljs-number">0666</span>)<br></code></pre></td></tr></table></figure><p>​可以看到，<code>OpenFile</code> 函数有三个参数：文件名、一个或多个标志（使用逻辑运算符“|”连接），使用的文件权限。</p><p>​我们通常会用到以下标志：</p><ul><li><code>os.O_RDONLY</code>：只读</li><li><code>os.O_WRONLY</code>：只写</li><li><code>os.O_CREATE</code>：创建：如果指定文件不存在，就创建该文件。</li><li><code>os.O_TRUNC</code>：截断：如果指定文件已存在，就将该文件的长度截为 0 。</li></ul><p></p><p>​在读文件的时候，文件的权限是被忽略的，所以在使用 <code>OpenFile</code> 时传入的第三个参数可以用 。而在写文件时，不管是 Unix 还是 Windows，都需要使用 0666。</p><p>​然后，我们创建一个写入器（缓冲区）对象：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">outputWriter := bufio.<span class="hljs-built_in">NewWriter</span>(outputFile)<br></code></pre></td></tr></table></figure><p>​接着，使用一个 for 循环，将字符串写入缓冲区，写 10 次：<code>outputWriter.WriteString(outputString)</code></p><p>​缓冲区的内容紧接着被完全写入文件：<code>outputWriter.Flush()</code></p><p>​如果写入的东西很简单，我们可以使用 <code>fmt.Fprintf(outputFile, &quot;Some test data.\n&quot;)</code> 直接将内容写入文件。<code>fmt</code> 包里的 F 开头的 Print 函数可以直接写入任何 <code>io.Writer</code>，包括文件（请参考<a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/12.8.md">章节12.8</a>)。</p><p>​ 12.3文件拷贝</p><p>​如何拷贝一个文件到另一个文件？最简单的方式就是使用 io 包：</p><p>​注意 <code>defer</code> 的使用：当打开 dst 文件时发生了错误，那么 <code>defer</code> 仍然能够确保 <code>src.Close()</code> 执行。如果不这么做，src 文件会一直保持打开状态并占用资源。</p><p>​12.4从命令行读取参数</p><p>​12.4.1 os包</p><p>​os 包中有一个 string 类型的切片变量 <code>os.Args</code>，用来处理一些基本的命令行参数，它在程序启动后读取命令行输入的参数。</p><p>​12.4.2flag包</p><p>​flag 包有一个扩展功能用来解析命令行选项。但是通常被用来替换基本常量，例如，在某些情况下我们希望在命令行给常量一些不一样的值。</p><p>​在 flag 包中有一个 Flag 被定义成一个含有如下字段的结构体：</p><pre><code class="hljs">type Flag struct &#123;                Name     string // name as it appears on command line                Usage    string // help message                Value    Value  // value as set                DefValue string // default value (as text); for usage message&#125;</code></pre><p>​12.5用buffer读取文件</p><p>​12.6用切片读写文件</p><p>​切片提供了 Go 中处理 I&#x2F;O 缓冲的标准方式</p><p>​12.7用defer关闭文件</p><p>​<code>defer</code> 关键字（参看 6.4）对于在函数结束时关闭打开的文件非常有用，例如下面的代码片段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">data</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>f, _ := os.OpenFile(name, os.O_RDONLY, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">defer</span> f.Close() <span class="hljs-comment">// idiomatic Go code!</span><br>contents, _ := ioutil.ReadAll(f)<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(contents)<br>&#125;<br></code></pre></td></tr></table></figure><p>​在函数 return 后执行了 <code>f.Close()</code></p><p>​12.8使用接口的实际例子：fmt:Fprintf</p><p>​例子程序 <code>io_interfaces.go</code> 很好的阐述了 io 包中的接口概念。</p><p>​下面是 <code>fmt.Fprintf()</code> 函数的实际签名</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">Fprintf(<span class="hljs-params">w</span> <span class="hljs-params">io</span>.Writer, <span class="hljs-params">format</span> <span class="hljs-params">string</span>, <span class="hljs-params">a</span> <span class="hljs-operator">...</span><span class="hljs-params">interface</span>&#123;&#125;)</span> (n <span class="hljs-built_in">int</span>, err error)<br></code></pre></td></tr></table></figure><p>​不是写入一个文件，而是写入一个 <code>io.Writer</code> 接口类型的变量，下面是 <code>Writer</code> 接口在 io 包中的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>fmt.Fprintf()</code> 依据指定的格式向第一个参数内写入字符串，第一个参数必须实现了 <code>io.Writer</code> 接口。<code>Fprintf()</code> 能够写入任何类型，只要其实现了 <code>Write</code> 方法，包括 <code>os.Stdout</code>，文件（例如 os.File），管道，网络连接，通道等等，同样的也可以使用 bufio 包中缓冲写入。bufio 包中定义了 <code>type Writer struct&#123;...&#125;</code> 。</p><p>​bufio.Writer 实现了 Write 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Writer)</span></span> Write(p []<span class="hljs-type">byte</span>) (nn <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>​它还有一个工厂函数：传给它一个 <code>io.Writer</code> 类型的参数，它会返回一个带缓冲的 <code>bufio.Writer</code> 类型的 <code>io.Writer</code> ：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-keyword">func</span> <span class="hljs-title function_">NewWriter</span><span class="hljs-params">(wr io.Writer)</span> <span class="hljs-params">(b *Writer)</span><br></code></pre></td></tr></table></figure><p>​适合任何形式的缓冲写入。</p><p>​在缓冲写入的最后千万不要忘了使用 <code>Flush()</code>，否则最后的输出不会被写入。</p><p>​12.9JSON数据格式</p><p>​数据结构要在网络中传输或保存到文件，就必须对其编码和解码；目前存在很多编码格式：JSON，XML，gob，Google 缓冲协议等等。Go 语言支持所有这些编码格式；在后面的章节，我们将讨论前三种格式。</p><p>​结构可能包含二进制数据，如果将其作为文本打印，那么可读性是很差的。另外结构内部可能包含匿名字段，而不清楚数据的用意。</p><p>​通过把数据转换成纯文本，使用命名的字段来标注，让其具有可读性。这样的数据格式可以通过网络传输，而且是与平台无关的，任何类型的应用都能够读取和输出，不与操作系统和编程语言的类型相关。</p><p>​下面是一些术语说明：</p><ul><li>数据结构 –&gt; 指定格式 &#x3D; <code>序列化</code> 或 <code>编码</code>（传输之前）</li><li>指定格式 –&gt; 数据结构 &#x3D; <code>反序列化</code> 或 <code>解码</code>（传输之后）</li></ul><p>​序列化是在内存中把数据转换成指定格式（data -&gt; string），反之亦然（string -&gt; data structure）</p><p>​编码也是一样的，只是输出一个数据流（实现了 io.Writer 接口）；解码是从一个数据流（实现了 io.Reader）输出到一个数据结构。</p><p>​我们都比较熟悉 XML 格式(参阅 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/12.9.md">12.10</a>)；但有些时候 JSON（JavaScript Object Notation，参阅 <a href="http://json.org/">http://json.org</a>）被作为首选，主要是由于其格式上非常简洁。通常 JSON 被用于 web 后端和浏览器之间的通讯，但是在其它场景也同样的有用。</p><p>​出于安全考虑，在 web 应用中最好使用 <code>json.MarshalforHTML()</code> 函数，其对数据执行 HTML 转码，所以文本可以被安全地嵌在 HTML <code>&lt;script&gt;</code> 标签中。</p><p>​<code>json.NewEncoder()</code> 的函数签名是 <code>func NewEncoder(w io.Writer) *Encoder</code>，返回的 Encoder 类型的指针可调用方法 <code>Encode(v interface&#123;&#125;)</code>，将数据对象 v 的 json 编码写入 <code>io.Writer</code> w 中。</p><p>​JSON 与 Go 类型对应如下：</p><ul><li><p>bool 对应 JSON 的 boolean</p></li><li><p>float64 对应 JSON 的 number</p></li><li><p>string 对应 JSON 的 string</p></li><li><p>nil 对应 JSON 的 null</p><p>不是所有的数据都可以编码为 JSON 类型，只有验证通过的数据结构才能被编码：</p></li><li><p>JSON 对象只支持字符串类型的 key；要编码一个 Go map 类型，map 必须是 map[string]T（T是 <code>json</code> 包中支持的任何类型）</p></li><li><p>Channel，复杂类型和函数类型不能被编码</p></li><li><p>不支持循环数据结构；它将引起序列化进入一个无限循环</p></li><li><p>指针可以被编码，实际上是对指针指向的值进行编码（或者指针是 nil）</p><h3 id="反序列化："><a href="#反序列化：" class="headerlink" title="反序列化："></a>反序列化：</h3><p><code>UnMarshal()</code> 的函数签名是 <code>func Unmarshal(data []byte, v interface&#123;&#125;) error</code> 把 JSON 解码为数据结构。</p><p>​示例 12.16 中对 vc 编码后的数据为 <code>js</code> ，对其解码时，我们首先创建结构 VCard 用来保存解码的数据：<code>var v VCard</code> 并调用 <code>json.Unmarshal(js, &amp;v)</code>，解析 []byte 中的 JSON 数据并将结果存入指针 &amp;v 指向的值。</p><p>​虽然反射能够让 JSON 字段去尝试匹配目标结构字段；但是只有真正匹配上的字段才会填充数据。字段没有匹配不会报错，而是直接忽略掉。</p><p>（练习 15.2b <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/exercises/chapter_15/twitter_status_json.go">twitter_status_json.go</a> 中用到了 Unmarshal</p><h3 id="解码任意的数据："><a href="#解码任意的数据：" class="headerlink" title="解码任意的数据："></a>解码任意的数据：</h3><p>​json 包使用 <code>map[string]interface&#123;&#125;</code> 和 <code>[]interface&#123;&#125;</code> 储存任意的 JSON 对象和数组；其可以被反序列化为任何的 JSON blob 存储到接口值中。</p><p>来看这个 JSON 数据，被存储在变量 b 中：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">b</span> := <span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(`&#123;<span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Wednesday&quot;</span>, <span class="hljs-string">&quot;Age&quot;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&quot;Parents&quot;</span>: <span class="hljs-selector-attr">[<span class="hljs-string">&quot;Gomez&quot;</span>, <span class="hljs-string">&quot;Morticia&quot;</span>]</span>&#125;`)<br></code></pre></td></tr></table></figure><p>不用理解这个数据的结构，我们可以直接使用 Unmarshal 把这个数据编码并保存在接口值中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-keyword">interface</span>&#123;&#125;<br>err := json.Unmarshal(b, &amp;f)<br></code></pre></td></tr></table></figure><p>f 指向的值是一个 map，key 是一个字符串，value 是自身存储作为空接口类型的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br><span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Wednesday&quot;</span>,<br><span class="hljs-string">&quot;Age&quot;</span>:  <span class="hljs-number">6</span>,<br><span class="hljs-string">&quot;Parents&quot;</span>: []<span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br><span class="hljs-string">&quot;Gomez&quot;</span>,<br><span class="hljs-string">&quot;Morticia&quot;</span>,<br>&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>要访问这个数据，我们可以使用类型断言</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">m := f.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><p>我们可以通过 for range 语法和 type switch 来访问其实际类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br><span class="hljs-keyword">switch</span> vv := v.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>fmt.Println(k, <span class="hljs-string">&quot;is string&quot;</span>, vv)<br><span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>fmt.Println(k, <span class="hljs-string">&quot;is int&quot;</span>, vv)<br><br><span class="hljs-keyword">case</span> []<span class="hljs-keyword">interface</span>&#123;&#125;:<br>fmt.Println(k, <span class="hljs-string">&quot;is an array:&quot;</span>)<br><span class="hljs-keyword">for</span> i, u := <span class="hljs-keyword">range</span> vv &#123;<br>fmt.Println(i, u)<br>&#125;<br><span class="hljs-keyword">default</span>:<br>fmt.Println(k, <span class="hljs-string">&quot;is of a type I don’t know how to handle&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方式，你可以处理未知的 JSON 数据，同时可以确保类型安全。</p><h3 id="解码数据到结构"><a href="#解码数据到结构" class="headerlink" title="解码数据到结构"></a>解码数据到结构</h3><p>​如果我们事先知道 JSON 数据，我们可以定义一个适当的结构并对 JSON 数据反序列化。下面的例子中，我们将定义：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">FamilyMember</span> struct &#123;<br><span class="hljs-type">Name</span>    string<br><span class="hljs-type">Age</span>     int<br><span class="hljs-type">Parents</span> []string<br>&#125;<br></code></pre></td></tr></table></figure><p>并对其反序列化：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> m FamilyMember<br>err := json<span class="hljs-selector-class">.Unmarshal</span>(<span class="hljs-selector-tag">b</span>, &amp;m)<br></code></pre></td></tr></table></figure><p>​程序实际上是分配了一个新的切片。这是一个典型的反序列化引用类型（指针、切片和 map）的例子。</p><h3 id="编码和解码流"><a href="#编码和解码流" class="headerlink" title="编码和解码流"></a>编码和解码流</h3><p>​json 包提供 Decoder 和 Encoder 类型来支持常用 JSON 数据流读写。NewDecoder 和 NewEncoder 函数分别封装了 io.Reader 和 io.Writer 接口。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">NewDecoder(<span class="hljs-params">r</span> <span class="hljs-params">io</span>.Reader)</span> *Decoder<br>func <span class="hljs-constructor">NewEncoder(<span class="hljs-params">w</span> <span class="hljs-params">io</span>.Writer)</span> *Encoder<br></code></pre></td></tr></table></figure><p>​要想把 JSON 直接写入文件，可以使用 json.NewEncoder 初始化文件（或者任何实现 io.Writer 的类型），并调用 Encode()；反过来与其对应的是使用 json.NewDecoder 和 Decode() 函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDecoder</span><span class="hljs-params">(r io.Reader)</span></span> *Decoder<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dec *Decoder)</span></span> Decode(v <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span><br></code></pre></td></tr></table></figure><p>​来看下接口是如何对实现进行抽象的：数据结构可以是任何类型，只要其实现了某种接口，目标或源数据要能够被编码就必须实现 io.Writer 或 io.Reader 接口。由于 Go 语言中到处都实现了 Reader 和 Writer，因此 Encoder 和 Decoder 可被应用的场景非常广泛，例如读取或写入 HTTP 连接、websockets 或文件。</p><p>12.10XML数据格式</p><p>下面是与 12.9 节 JSON 例子等价的 XML 版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Person</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">FirstName</span>&gt;</span>Laura<span class="hljs-tag">&lt;/<span class="hljs-name">FirstName</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">LastName</span>&gt;</span>Lynn<span class="hljs-tag">&lt;/<span class="hljs-name">LastName</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Person</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​如同 json 包一样，也有 <code>Marshal()</code> 和 <code>UnMarshal()</code> 从 XML 中编码和解码数据；但这个更通用，可以从文件中读取和写入（或者任何实现了 io.Reader 和 io.Writer 接口的类型）</p><p>​和 JSON 的方式一样，XML 数据可以序列化为结构，或者从结构反序列化为 XML 数据；这些可以在例子 15.8（<a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_15/twitter_status.go">twitter_status.go</a>）中看到。</p><p>​encoding&#x2F;xml 包实现了一个简单的 XML 解析器（SAX），用来解析 XML 数据内容。</p><p>​包中定义了若干 XML 标签类型：StartElement，Chardata（这是从开始标签到结束标签之间的实际文本），EndElement，Comment，Directive 或 ProcInst。</p><p>​包中同样定义了一个结构解析器：<code>NewParser</code> 方法持有一个 io.Reader（这里具体类型是 strings.NewReader）并生成一个解析器类型的对象。还有一个 <code>Token()</code> 方法返回输入流里的下一个 XML token。在输入流的结尾处，会返回（nil，io.EOF）</p><p>​XML 文本被循环处理直到 <code>Token()</code> 返回一个错误，因为已经到达文件尾部，再没有内容可供处理了。通过一个 type-switch 可以根据一些 XML 标签进一步处理。Chardata 中的内容只是一个 []byte，通过字符串转换让其变得可读性强一些。</p><p>12.11用Gob传输数据</p><p>​Gob 是 Go 自己的以二进制形式序列化和反序列化程序数据的格式；可以在 <code>encoding</code> 包中找到。这种格式的数据简称为 Gob （即 Go binary 的缩写）。类似于 Python 的 “pickle” 和 Java 的 “Serialization”。</p><p>​Gob 通常用于远程方法调用（RPCs，参见 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/15.9.md">15.9节</a> 的 rpc 包）参数和结果的传输，以及应用程序和机器之间的数据传输。 它和 JSON 或 XML 有什么不同呢？Gob 特定地用于纯 Go 的环境中，例如，两个用 Go 写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。 Gob 不是可外部定义，语言无关的编码方式。因此它的首选格式是二进制，而不是像 JSON 和 XML 那样的文本格式。 Gob 并不是一种不同于 Go 的语言，而是在编码和解码过程中用到了 Go 的反射。</p><p>​Gob 文件或流是完全自描述的：里面包含的所有类型都有一个对应的描述，并且总是可以用 Go 解码，而不需要了解文件的内容。</p><p>​只有可导出的字段会被编码，零值会被忽略。在解码结构体的时候，只有同时匹配名称和可兼容类型的字段才会被解码。当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作：解码客户端会继续识别以前存在的字段。并且还提供了很大的灵活性，比如在发送者看来，整数被编码成没有固定长度的可变长度，而忽略具体的 Go 类型。</p><p>假如在发送者这边有一个有结构 T：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">T</span> struct &#123; <span class="hljs-type">X</span>, <span class="hljs-type">Y</span>, <span class="hljs-type">Z</span> int &#125;<br><span class="hljs-title">var</span> t = <span class="hljs-type">T</span>&#123;<span class="hljs-type">X</span>: <span class="hljs-number">7</span>, <span class="hljs-type">Y</span>: <span class="hljs-number">0</span>, <span class="hljs-type">Z</span>: <span class="hljs-number">8</span>&#125;<br></code></pre></td></tr></table></figure><p>而在接收者这边可以用一个结构体 U 类型的变量 u 来接收这个值：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">U</span> struct &#123; <span class="hljs-type">X</span>, <span class="hljs-type">Y</span> *int8 &#125;<br><span class="hljs-title">var</span> u <span class="hljs-type">U</span><br></code></pre></td></tr></table></figure><p>​在接收者中，X 的值是7，Y 的值是0（Y的值并没有从 t 中传递过来，因为它是零值）</p><p>​和 JSON 的使用方式一样，Gob 使用通用的 <code>io.Writer</code> 接口，通过 <code>NewEncoder()</code> 函数创建 <code>Encoder</code> 对象并调用 <code>Encode()</code>；相反的过程使用通用的 <code>io.Reader</code> 接口，通过 <code>NewDecoder()</code> 函数创建 <code>Decoder</code> 对象并调用 <code>Decode()</code>。</p><p>​我们把示例 12.12 的信息写进名为 vcard.gob 的文件作为例子。这会产生一个文本可读数据和二进制数据的混合，当你试着在文本编辑中打开的时候会看到。</p><p>12.12Go中的密码学</p><p>​通过网络传输的数据必须加密，以防止被 hacker（黑客）读取或篡改，并且保证发出的数据和收到的数据检验和一致。 鉴于 Go 母公司的业务，我们毫不惊讶地看到 Go 的标准库为该领域提供了超过 30 个的包：</p><ul><li><code>hash</code> 包：实现了 <code>adler32</code>、<code>crc32</code>、<code>crc64</code> 和 <code>fnv</code> 校验；</li><li><code>crypto</code> 包：实现了其它的 hash 算法，比如 <code>md4</code>、<code>md5</code>、<code>sha1</code> 等。以及完整地实现了 <code>aes</code>、<code>blowfish</code>、<code>rc4</code>、<code>rsa</code>、<code>xtea</code> 等加密算法。</li></ul></li></ul><h5 id="13-0-错误处理与测试"><a href="#13-0-错误处理与测试" class="headerlink" title="13.0 错误处理与测试"></a>13.0 错误处理与测试</h5><p>​Go 没有像 Java 和 .NET 那样的 <code>try/catch</code> 异常机制：不能执行抛异常操作。但是有一套 <code>defer-panic-and-recover</code> 机制（参见 13.2-13.3 节）。</p><p>​Go 的设计者觉得 <code>try/catch</code> 机制的使用太泛滥了，而且从底层向更高的层级抛异常太耗费资源。他们给 Go 设计的机制也可以 “捕捉” 异常，但是更轻量，并且只应该作为（处理错误的）最后的手段。</p><p>​Go 是怎么处理普通错误的呢？通过在函数和方法中返回错误对象作为它们的唯一或最后一个返回值——如果返回 nil，则没有错误发生——并且主调（calling）函数总是应该检查收到的错误。</p><p>​<strong>永远不要忽略错误，否则可能会导致程序崩溃！！</strong></p><p>​处理错误并且在函数发生错误的地方给用户返回错误信息：照这样处理就算真的出了问题，你的程序也能继续运行并且通知给用户。<code>panic and recover</code> 是用来处理真正的异常（无法预测的错误）而不是普通的错误。</p><p>​库函数通常必须返回某种错误提示给主调（calling）函数。</p><p>​在前面的章节中我们了解了 Go 检查和报告错误条件的惯有方式：</p><p>​1)产生错误的函数会返回两个变量，一个值和一个错误码；如果后者是 nil 就是成功，非 nil 就是发生了错误。</p><p>​2)为了防止发生错误时正在执行的函数（如果有必要的话甚至会是整个程序）被中止，在调用函数后必须检查错误。</p><p>​13.1错误处理</p><p>​Go 有一个预先定义的 error 接口类型</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">type <span class="hljs-built_in">error</span><span class="hljs-built_in"> interface </span>&#123;<br><span class="hljs-built_in">Error</span>() string<br>&#125;<br></code></pre></td></tr></table></figure><p>​13.1.1定义错误</p><p>​任何时候当你需要一个新的错误类型，都可以用 <code>errors</code> 包（必须先 import）的 <code>errors.New</code> 函数接收合适的错误信息来创建，像下面这样：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">err := errors.<span class="hljs-keyword">New</span>(<span class="hljs-string">&quot;math - square root of negative number&quot;</span>)<br></code></pre></td></tr></table></figure><p>​13.1.2用fmt创建错误对象</p><p>​通常你想要返回包含错误参数的更有信息量的字符串，例如：可以用 <code>fmt.Errorf()</code> 来实现：它和 fmt.Printf() 完全一样，接收一个或多个格式占位符的格式化字符串和相应数量的占位变量。和打印信息不同的是它用信息生成错误对象。</p><p>​13.2运行时异常和panic</p><p>​当发生像数组下标越界或类型断言失败这样的运行错误时，Go 运行时会触发<em>运行时 panic</em>，伴随着程序的崩溃抛出一个 <code>runtime.Error</code> 接口类型的值。这个错误值有个 <code>RuntimeError()</code> 方法用于区别普通错误。</p><p>​<code>panic</code> 可以直接从代码初始化：当错误条件（我们所测试的代码）很严苛且不可恢复，程序不能继续运行时，可以使用 <code>panic</code> 函数产生一个中止程序的运行时错误。<code>panic</code> 接收一个做任意类型的参数，通常是字符串，在程序死亡时被打印出来。Go 运行时负责中止程序并给出调试信息。</p><p>​Go panicking：</p><p>​在多层嵌套的函数调用中调用 panic，可以马上中止当前函数的执行，所有的 defer 语句都会保证执行并把控制权交还给接收到 panic 的函数调用者。这样向上冒泡直到最顶层，并执行（每层的） defer，在栈顶处程序崩溃，并在命令行中用传给 panic 的值报告错误情况：这个终止过程就是 <em>panicking</em>。</p><p>​标准库中有许多包含 <code>Must</code> 前缀的函数，像 <code>regexp.MustComplie</code> 和 <code>template.Must</code>；当正则表达式或模板中转入的转换字符串导致错误时，这些函数会 panic。</p><p>​不能随意地用 panic 中止程序，必须尽力补救错误让程序能继续执行。</p><p>​13.3从panic中恢复（Recover）</p><p>​正如名字一样，这个（recover）内建函数被用于从 panic 或 错误场景中恢复：让程序可以从 panicking 重新获得控制权，停止终止过程进而恢复正常执行。</p><p>​<code>recover</code> 只能在 defer 修饰的函数（参见 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/06.4.md">6.4 节</a>）中使用：用于取得 panic 调用中传递过来的错误值，如果是正常执行，调用 <code>recover</code> 会返回 nil，且没有其它效果。</p><p>​总结：panic 会导致栈被展开直到 defer 修饰的 recover() 被调用或者程序中止。</p><p>​log 包实现了简单的日志功能：默认的 log 对象向标准错误输出中写入并打印每条日志信息的日期和时间。除了 <code>Println</code> 和 <code>Printf</code> 函数，其它的致命性函数都会在写完日志信息后调用 os.Exit(1)，那些退出函数也是如此。而 Panic 效果的函数会在写完日志信息后调用 panic；可以在程序必须中止或发生了临界错误时使用它们，就像当 web 服务器不能启动时那样</p><p>​<code>defer-panic-recover</code> 在某种意义上也是一种像 <code>if</code>，<code>for</code> 这样的控制流机制。</p><p>​Go 标准库中许多地方都用了这个机制，例如，json 包中的解码和 regexp 包中的 Complie 函数。Go 库的原则是即使在包的内部使用了 panic，在它的对外接口（API）中也必须用 recover 处理成显式返回的错误。</p><p>​13.4自定义包中的错误处理和panicking</p><p>​这是所有自定义包实现者应该遵守的最佳实践：</p><p>​1）<em>在包内部，总是应该从 panic 中 recover</em>：不允许显式的超出包范围的 panic()</p><p>​2）<em>向包的调用者返回错误值（而不是 panic）。</em></p><p>​在包内部，特别是在非导出函数中有很深层次的嵌套调用时，将 panic 转换成 error 来告诉调用方为何出错，是很实用的（且提高了代码可读性）。</p><p>​下面的代码则很好地阐述了这一点。我们有一个简单的 parse 包（示例 13.4）用来把输入的字符串解析为整数切片；这个包有自己特殊的 <code>ParseError</code>。</p><p>​当没有东西需要转换或者转换成整数失败时，这个包会 panic（在函数 fields2numbers 中）。但是可导出的 Parse 函数会从 panic 中 recover 并用所有这些信息返回一个错误给调用者。为了演示这个过程，在 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_13/panic_recover.go">panic_recover.go</a> 中 调用了 parse 包（示例 13.5）；不可解析的字符串会导致错误并被打印出来。</p><p>​13.5一种用闭包处理错误的模式</p><p>​每当函数返回时，我们应该检查是否有错误发生：但是这会导致重复乏味的代码。结合 defer&#x2F;panic&#x2F;recover 机制和闭包可以得到一个我们马上要讨论的更加优雅的模式。不过这个模式只有当所有的函数都是同一种签名时可用，这样就有相当大的限制。一个很好的使用它的例子是 web 应用，所有的处理函数都是下面这样：</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">func</span> <span class="hljs-title function_">handler1</span>(<span class="hljs-params">w</span> <span class="hljs-params">http</span>.<span class="hljs-params">ResponseWriter</span>, <span class="hljs-params">r</span> *<span class="hljs-params">http</span>.<span class="hljs-params">Request</span>) &#123; <span class="hljs-operator">...</span> &#125;<br></code></pre></td></tr></table></figure><p>​假设所有的函数都有这样的签名：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">f</span>(<span class="hljs-selector-tag">a</span> type1, <span class="hljs-selector-tag">b</span> type2)<br></code></pre></td></tr></table></figure><p>​参数的数量和类型是不相关的。</p><p>​我们给这个类型一个名字：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fType1 = func <span class="hljs-built_in">f</span>(<span class="hljs-selector-tag">a</span> type1, <span class="hljs-selector-tag">b</span> type2)<br></code></pre></td></tr></table></figure><p>​在我们的模式中使用了两个帮助函数：</p><p>​1）check：这是用来检查是否有错误和 panic 发生的函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> &#123; <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-built_in">panic</span>(err) &#125; &#125;<br></code></pre></td></tr></table></figure><p>​2）errorhandler：这是一个包装函数。接收一个 fType1 类型的函数 fn 并返回一个调用 fn 的函数。里面就包含有 defer&#x2F;recover 机制，这在 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.3.md">13.3 节</a> 中有相应描述。</p><p>​</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errorHandler</span><span class="hljs-params">(fn fType1)</span></span> fType1 &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a type1, b type2)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err, ok := <span class="hljs-built_in">recover</span>().(<span class="hljs-type">error</span>); ok &#123;<br>log.Printf(<span class="hljs-string">&quot;run time panic: %v&quot;</span>, err)<br>&#125;<br>&#125;()<br>fn(a, b)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​当错误发生时会 recover 并打印在日志中；除了简单的打印，应用也可以用 template 包（参见 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/15.7.md">15.7 节</a>）为用户生成自定义的输出。check() 函数会在所有的被调函数中调用，像这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> f1(a type1, b type2) &#123;<br>...<br>f, _, err := <span class="hljs-regexp">//</span> call <span class="hljs-keyword">function</span>/method<br>check(err)<br>t, err := <span class="hljs-regexp">//</span> call <span class="hljs-keyword">function</span>/method<br>check(err)<br>_, err2 := <span class="hljs-regexp">//</span> call <span class="hljs-keyword">function</span>/method<br>check(err2)<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>​通过这种机制，所有的错误都会被 recover，并且调用函数后的错误检查代码也被简化为调用 check(err) 即可。在这种模式下，不同的错误处理必须对应不同的函数类型；它们（错误处理）可能被隐藏在错误处理包内部。可选的更加通用的方式是用一个空接口类型的切片作为参数和返回值。</p><p>​13.6启动外部命令和程序</p><p>​os 包有一个 <code>StartProcess</code> 函数可以调用或启动外部系统命令和二进制可执行文件；它的第一个参数是要运行的进程，第二个参数用来传递选项或参数，第三个参数是含有系统环境基本信息的结构体。</p><p>​这个函数返回被启动进程的 id（pid），或者启动失败返回错误。</p><p>​exec 包中也有同样功能的更简单的结构体和函数；主要是 <code>exec.Command(name string, arg ...string)</code> 和 <code>Run()</code>。首先需要用系统命令或可执行文件的名字创建一个 <code>Command</code> 对象，然后用这个对象作为接收者调用 <code>Run()</code>。</p><p>​13.7Go中的单元测试和基准测试</p><p>​首先所有的包都应该有一定的必要文档，然后同样重要的是对包的测试。</p><p>​在第 3 章中提到了 Go 的测试工具 gotest， 我们已经在 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.8.md">9.8 节</a>中使用过了。这里我们会用更多的例子进行详细说明。</p><p>​名为 testing 的包被专门用来进行自动化测试，日志和错误报告。并且还包含一些基准测试函数的功能。</p><p>​备注：gotest 是 Unix bash 脚本，所以在 Windows 下你需要配置 MINGW 环境（参见 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/02.5.md">2.5 节</a>）；在 Windows 环境下把所有的 pkg&#x2F;linux_amd64 替换成 pkg&#x2F;windows。</p><p>​对一个包做（单元）测试，需要写一些可以频繁（每次更新后）执行的小块测试单元来检查代码的正确性。于是我们必须写一些 Go 源文件来测试代码。测试程序必须属于被测试的包，并且文件名满足这种形式 <code>*_test.go</code>，所以测试代码和包中的业务代码是分开的。</p><p>​<code>_test</code> 程序不会被普通的 Go 编译器编译，所以当放应用部署到生产环境时它们不会被部署；只有 gotest 会编译所有的程序：普通程序和测试程序。</p><p>​测试文件中必须导入 “testing” 包，并写一些名字以 <code>TestZzz</code> 打头的全局函数，这里的 <code>Zzz</code> 是被测试函数的字母描述，如 TestFmtInterface，TestPayEmployees 等。</p><p>​测试函数必须有这种形式的头部：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">TestAbcde(<span class="hljs-params">t</span> <span class="hljs-operator">*</span><span class="hljs-params">testing</span>.T)</span><br></code></pre></td></tr></table></figure><p>​T 是传给测试函数的结构类型，用来管理测试状态，支持格式化测试日志，如 t.Log，t.Error，t.ErrorF 等。在函数的结尾把输出跟想要的结果对比，如果不等就打印一个错误，成功的测试则直接返回。</p><p>​用下面这些函数来通知测试失败：</p><p>1）<code>func (t *T) Fail()</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">标记测试函数为失败，然后继续执行（剩下的测试）。<br></code></pre></td></tr></table></figure><p>2）<code>func (t *T) FailNow()</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">标记测试函数为失败并中止执行；文件中别的测试也被略过，继续执行下一个文件。<br></code></pre></td></tr></table></figure><p>3）<code>func (t *T) Log(args ...interface&#123;&#125;)</code></p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">args</span> 被用默认的格式格式化并打印到错误日志中。<br></code></pre></td></tr></table></figure><p>4）<code>func (t *T) Fatal(args ...interface&#123;&#125;)</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">结合 先执行 3），然后执行 2）的效果。<br></code></pre></td></tr></table></figure><p>​运行 go test 来编译测试程序，并执行程序中所有的 TestZZZ 函数。如果所有的测试都通过会打印出 PASS。</p><p>​gotest 可以接收一个或多个函数程序作为参数，并指定一些选项。</p><p>​结合 –chatty 或 -v 选项，每个执行的测试函数以及测试状态会被打印。例如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">go test fmt_test.go --chatty<br><span class="hljs-section">=== RUN fmt.TestFlagParser</span><br><span class="hljs-bullet">--- </span>PASS: fmt.TestFlagParser<br><span class="hljs-section">=== RUN fmt.TestArrayPrinter</span><br><span class="hljs-bullet">--- </span>PASS: fmt.TestArrayPrinter<br>...<br></code></pre></td></tr></table></figure><p>​testing 包中有一些类型和函数可以用来做简单的基准测试；测试代码中必须包含以 <code>BenchmarkZzz</code> 打头的函数并接收一个 <code>*testing.B</code> 类型的参数，比如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">func <span class="hljs-constructor">BenchmarkReverse(<span class="hljs-params">b</span> <span class="hljs-operator">*</span><span class="hljs-params">testing</span>.B)</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">...</span><br><span class="hljs-operator"></span>&#125;<br></code></pre></td></tr></table></figure><p>​命令 <code>go test –test.bench=.*</code> 会运行所有的基准测试函数；代码中的函数会被调用 N 次（N 是非常大的数，如 N &#x3D; 1000000），并展示 N 的值和函数执行的平均时间，单位为 ns（纳秒，ns&#x2F;op）。如果是用 testing.Benchmark 调用这些函数，直接运行程序即可。</p><p>​13.8测试的具体例子</p><p>​由于测试需要具体的输入用例且不可能测试到所有的用例（非常像一个无穷的数），所以我们必须对要使用的测试用例思考再三。</p><p>​至少应该包括：</p><p>​1)正常的用例</p><p>​1)反面的用例（错误的输入，如用负数或字母代替数字，没有输入等）</p><p>​1)边界检查用例（如果参数的取值范围是 0 到 1000，检查 0 和 1000 的情况）</p><p>​13.9用（测试数据）表驱动测试</p><p>​编写测试代码时，一个较好的办法是把测试的输入数据和期望的结果写在一起组成一个数据表：表中的每条记录都是一个含有输入和期望值的完整测试用例，有时还可以结合像测试名字这样的额外信息来让测试输出更多的信息。</p><p>​13.10性能调试：分析并优化Go程序</p><p>​13.10.1时间和内存消耗</p><p>​可以用这个便捷脚本 <em>xtime</em> 来测量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>/usr/bin/time -f <span class="hljs-string">&#x27;%Uu %Ss %er %MkB %C&#x27;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span><br></code></pre></td></tr></table></figure><p>​在 Unix 命令行中像这样使用 <code>xtime goprogexec</code>，这里的 progexec 是一个 Go 可执行程序，这句命令行输出类似：56.63u 0.26s 56.92r 1642640kB progexec，分别对应用户时间，系统时间，实际时间和最大内存占用。</p><p>​13.10.2用go test调试</p><p>​如果代码使用了 Go 中 testing 包的基准测试功能，我们可以用 gotest 标准的 <code>-cpuprofile</code> 和 <code>-memprofile</code> 标志向指定文件写入 CPU 或 内存使用情况报告。</p><p>​使用方式：<code>go test -x -v -cpuprofile=prof.out -file x_test.go</code></p><p>​编译执行 x_test.go 中的测试，并向 prof.out 文件中写入 cpu 性能分析信息。</p><p>13.10.3用pprof调试</p><p>​你可以在单机程序 progexec 中引入 runtime&#x2F;pprof 包；这个包以 pprof 可视化工具需要的格式写入运行时报告数据。对于 CPU 性能分析来说你需要添加一些代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> cpuprofile = flag<span class="hljs-selector-class">.String</span>(<span class="hljs-string">&quot;cpuprofile&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;write cpu profile to file&quot;</span>)<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br>flag<span class="hljs-selector-class">.Parse</span>()<br><span class="hljs-keyword">if</span> *cpuprofile != <span class="hljs-string">&quot;&quot;</span> &#123;<br>f, err := os<span class="hljs-selector-class">.Create</span>(*cpuprofile)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>log<span class="hljs-selector-class">.Fatal</span>(err)<br>&#125;<br>pprof<span class="hljs-selector-class">.StartCPUProfile</span>(f)<br>defer pprof<span class="hljs-selector-class">.StopCPUProfile</span>()<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>​代码定义了一个名为 cpuprofile 的 flag，调用 Go flag 库来解析命令行 flag，如果命令行设置了 cpuprofile flag，则开始 CPU 性能分析并把结果重定向到那个文件（os.Create 用拿到的名字创建了用来写入分析数据的文件）。这个分析程序最后需要在程序退出之前调用 StopCPUProfile 来刷新挂起的写操作到文件中；我们用 defer 来保证这一切会在 main 返回时触发。</p><p>​现在用这个 flag 运行程序：<code>progexec -cpuprofile=progexec.prof</code></p><p>​然后可以像这样用 gopprof 工具：<code>gopprof progexec progexec.prof</code></p><p>​gopprof 程序是 Google pprofC++ 分析器的一个轻微变种；关于此工具更多的信息，参见<a href="https://github.com/gperftools/gperftools">https://github.com/gperftools/gperftools</a> 。</p><p>​如果开启了 CPU 性能分析，Go 程序会以大约每秒 100 次的频率阻塞，并记录当前执行的 goroutine 栈上的程序计数器样本。</p><p>​此工具一些有趣的命令：</p><p>​1）<code>topN</code></p><p>​用来展示分析结果中最开头的 N 份样本，例如：<code>top5</code> 它会展示在程序运行期间调用最频繁的 5 个函数，输出如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">Total: <span class="hljs-number">3099</span> samples<br><span class="hljs-number">626 20.2</span>% <span class="hljs-number">20</span>.<span class="hljs-number">2</span>% <span class="hljs-number">626 20.2</span>% scanblock<br><span class="hljs-number">309 10.0</span>% <span class="hljs-number">30</span>.<span class="hljs-number">2</span>% <span class="hljs-number">2839 91.6</span>% main.FindLoops<br>...<br></code></pre></td></tr></table></figure><p>​第 5 列表示函数的调用频度。</p><p>​2）<code>web</code> 或 <code>web 函数名</code></p><p>​该命令生成一份 SVG 格式的分析数据图表，并在网络浏览器中打开它（还有一个 gv 命令可以生成 PostScript 格式的数据，并在 GhostView 中打开，这个命令需要安装 graphviz）。函数被表示成不同的矩形（被调用越多，矩形越大），箭头指示函数调用链。</p><p>​3）<code>list 函数名</code> 或 <code>weblist 函数名</code></p><p>​展示对应函数名的代码行列表，第 2 列表示当前行执行消耗的时间，这样就很好地指出了运行过程中消耗最大的代码。</p><p>​如果发现函数 <code>runtime.mallocgc</code>（分配内存并执行周期性的垃圾回收）调用频繁，那么是应该进行内存分析的时候了。找出垃圾回收频繁执行的原因，和内存大量分配的根源。</p><p>​为了做到这一点必须在合适的地方添加下面的代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> memprofile = flag<span class="hljs-selector-class">.String</span>(<span class="hljs-string">&quot;memprofile&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;write memory profile to this file&quot;</span>)<br>...<br><br><span class="hljs-function"><span class="hljs-title">CallToFunctionWhichAllocatesLotsOfMemory</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">if</span> *memprofile != <span class="hljs-string">&quot;&quot;</span> &#123;<br>f, err := os<span class="hljs-selector-class">.Create</span>(*memprofile)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>log<span class="hljs-selector-class">.Fatal</span>(err)<br>&#125;<br>pprof<span class="hljs-selector-class">.WriteHeapProfile</span>(f)<br>f<span class="hljs-selector-class">.Close</span>()<br>return<br>&#125;<br></code></pre></td></tr></table></figure><p>​用 -memprofile flag 运行这个程序：<code>progexec -memprofile=progexec.mprof</code></p><p>​然后你可以像这样再次使用 gopprof 工具：<code>gopprof progexec progexec.mprof</code></p><p>​<code>top5</code>，<code>list 函数名</code> 等命令同样适用，只不过现在是以 Mb 为单位测量内存分配情况，这是 top 命令输出的例子：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">Total: <span class="hljs-number">118</span>.<span class="hljs-number">3</span> MB<br><span class="hljs-number">66.1 55.8</span>% <span class="hljs-number">55</span>.<span class="hljs-number">8</span>% <span class="hljs-number">103.7 87.7</span>% main.FindLoops<br><span class="hljs-number">30.5 25.8</span>% <span class="hljs-number">81</span>.<span class="hljs-number">6</span>% <span class="hljs-number">30.5 25.8</span>% main.*LSG·NewLoop<br>...<br></code></pre></td></tr></table></figure><p>​从第 1 列可以看出，最上面的函数占用了最多的内存。</p><p>​同样有一个报告内存分配计数的有趣工具：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">gopprof <span class="hljs-comment">--inuse_objects progexec progexec.mprof</span><br></code></pre></td></tr></table></figure><p>​对于 web 应用来说，有标准的 HTTP 接口可以分析数据。在 HTTP 服务中添加</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> <span class="hljs-literal">_</span> <span class="hljs-string">&quot;http/pprof&quot;</span><br></code></pre></td></tr></table></figure><p>​会为 &#x2F;debug&#x2F;pprof&#x2F; 下的一些 URL 安装处理器。然后你可以用一个唯一的参数——你服务中的分析数据的 URL 来执行 gopprof 命令——它会下载并执行在线分析。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">gopprof http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">6060</span><span class="hljs-regexp">/debug/</span>pprof/profile <span class="hljs-comment"># 30-second CPU profile</span><br>gopprof http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">6060</span><span class="hljs-regexp">/debug/</span>pprof/heap <span class="hljs-comment"># heap profile</span><br></code></pre></td></tr></table></figure><p>​在 Go-blog（引用 15）中有一篇很好的文章用具体的例子进行了分析：分析 Go 程序（2011年6月）。</p><h5 id="14-0-协程-goroutine-与通道-channel"><a href="#14-0-协程-goroutine-与通道-channel" class="headerlink" title="14.0 协程(goroutine)与通道(channel)"></a>14.0 协程(goroutine)与通道(channel)</h5><p>​作为一门 21 世纪的语言，Go 原生支持应用之间的通信（网络，客户端和服务端，分布式计算，参见第 15 章）和程序的并发。程序可以在不同的处理器和计算机上同时执行不同的代码段。Go 语言为构建并发程序的基本代码块是协程 (goroutine) 与通道 (channel) 。他们需要语言，编译器，和 runtime 的支持。Go 语言提供的垃圾回收器对并发编程至关重要。</p><h5 id="不要通过共享内存来通信，而通过通信来共享内存。"><a href="#不要通过共享内存来通信，而通过通信来共享内存。" class="headerlink" title="不要通过共享内存来通信，而通过通信来共享内存。"></a>不要通过共享内存来通信，而通过通信来共享内存。</h5><p>​通信强制协作。</p><h6 id="14-1-1什么是协程"><a href="#14-1-1什么是协程" class="headerlink" title="14.1.1什么是协程"></a>14.1.1什么是协程</h6><p>​一个应用程序是运行在机器上的一个进程；进程是一个运行在自己内存地址空间里的独立执行体。一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间的一起工作的执行体。几乎所有’正式’的程序都是多线程的，以便让用户或计算机不必等待，或者能够同时服务多个请求（如 Web 服务器），或增加性能和吞吐量（例如，通过对不同的数据集并行执行代码）。一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，但是只有同一个程序在某个时间点同时运行在多核或者多处理器上才是真正的并行。</p><p>​并行是一种通过使用多处理器以提高速度的能力。所以并发程序可以是并行的，也可以不是。</p><p>​公认的，使用多线程的应用难以做到准确，最主要的问题是内存中的数据共享，它们会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果（称作 <code>竞态</code>）。</p><p>​<strong>不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险。</strong></p><p>​解决之道在于同步不同的线程，对数据加锁，这样同时就只有一个线程可以变更数据。在 Go 的标准库 <code>sync</code> 中有一些工具用来在低级别的代码中实现加锁；我们在第 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.3.md">9.3</a> 节中讨论过这个问题。不过过去的软件开发经验告诉我们这会带来更高的复杂度，更容易使代码出错以及更低的性能，所以这个经典的方法明显不再适合现代多核&#x2F;多处理器编程：<code>thread-per-connection</code> 模型不够有效。</p><p>​Go 更倾向于其他的方式，在诸多比较合适的范式中，有个被称作 <code>Communicating Sequential Processes（顺序通信处理）</code>（CSP, C. Hoare 发明的）还有一个叫做 <code>message passing-model（消息传递）</code>（已经运用在了其他语言中，比如 Erlang）。</p><p>​在 Go 中，应用程序并发处理的部分被称作 <code>goroutines（协程）</code>，它可以进行更有效的并发运算。在协程和操作系统线程之间并无一对一的关系：协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在他们之上的；协程调度器在 Go 运行时很好的完成了这个工作。</p><p>​协程工作在相同的地址空间中，所以共享内存的方式一定是同步的；这个可以使用 <code>sync</code> 包来实现（参见第 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.3.md">9.3</a> 节），不过我们很不鼓励这样做：Go 使用 <code>channels</code> 来同步协程（可以参见第 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.2.md">14.2</a> 节等章节）</p><p>​当系统调用（比如等待 I&#x2F;O）阻塞协程时，其他协程会继续在其他线程上工作。协程的设计隐藏了许多线程创建和管理方面的复杂工作。</p><p>​协程是轻量的，比线程更轻。它们痕迹非常不明显（使用少量的内存和资源）：使用 4K 的栈内存就可以在堆中创建它们。因为创建非常廉价，必要的时候可以轻松创建并运行大量的协程（在同一个地址空间中 100,000 个连续的协程）。并且它们对栈进行了分割，从而动态的增加（或缩减）内存的使用；栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。</p><p>​协程可以运行在多个操作系统线程之间，也可以运行在线程之内，让你可以很小的内存占用就可以处理大量的任务。由于操作系统线程上的协程时间片，你可以使用少量的操作系统线程就能拥有任意多个提供服务的协程，而且 Go 运行时可以聪明的意识到哪些协程被阻塞了，暂时搁置它们并处理其他协程。</p><p>​存在两种并发方式：确定性的（明确定义排序）和非确定性的（加锁&#x2F;互斥从而未定义排序）。Go 的协程和通道理所当然的支持确定性的并发方式（例如通道具有一个 sender 和一个 receiver）。我们会在第 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.7.md">14.7</a> 节中使用一个常见的算法问题（工人问题）来对比两种处理方式。</p><p>​协程是通过使用关键字 <code>go</code> 调用（执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）。这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，比如：<code>go sum(bigArray)</code>，在后台计算总和。</p><p>​协程的栈会根据需要进行伸缩，不出现栈溢出；开发者不需要关心栈的大小。当协程结束的时候，它会静默退出：用来启动这个协程的函数不会得到任何的返回值。</p><p>​任何 Go 程序都必须有的 <code>main()</code> 函数也可以看做是一个协程，尽管它并没有通过 <code>go</code> 来启动。协程可以在程序初始化的过程中运行（在 <code>init()</code> 函数中）。</p><p>​在一个协程中，比如它需要进行非常密集的运算，你可以在运算循环中周期的使用 <code>runtime.Gosched()</code>：这会让出处理器，允许运行其他协程；它并不会使当前协程挂起，所以它会自动恢复执行。使用 <code>Gosched()</code> 可以使计算均匀分布，使通信不至于迟迟得不到响应。</p><p>​14.1.2并发和并行的差异</p><p>​Go 的并发原语提供了良好的并发设计基础：表达程序结构以便表示独立地执行的动作；所以 Go 的重点不在于并行的首要位置：并发程序可能是并行的，也可能不是。并行是一种通过使用多处理器以提高速度的能力。但往往是，一个设计良好的并发程序在并行方面的表现也非常出色。</p><p>​在当前的运行时（2012 年一月）实现中，Go 默认没有并行指令，只有一个独立的核心或处理器被专门用于 Go 程序，不论它启动了多少个协程；所以这些协程是并发运行的，但他们不是并行运行的：同一时间只有一个协程会处在运行状态。</p><p>​这个情况在以后可能会发生改变，不过届时，为了使你的程序可以使用多个核心运行，这时协程就真正的是并行运行了，你必须使用 <code>GOMAXPROCS</code> 变量。</p><p>​这会告诉运行时有多少个协程同时执行。</p><p>​并且只有 gc 编译器真正实现了协程，适当的把协程映射到操作系统线程。使用 <code>gccgo</code> 编译器，会为每一个协程创建操作系统线程。</p><p>​14.1.3使用GOMAXPROCS</p><p>​在 gc 编译器下（6g 或者 8g）你必须设置 GOMAXPROCS 为一个大于默认值 1 的数值来允许运行时支持使用多于 1 个的操作系统线程，所有的协程都会共享同一个线程除非将 GOMAXPROCS 设置为一个大于 1 的数。当 GOMAXPROCS 大于 1 时，会有一个线程池管理许多的线程。通过 <code>gccgo</code> 编译器 GOMAXPROCS 有效的与运行中的协程数量相等。假设 n 是机器上处理器或者核心的数量。如果你设置环境变量 GOMAXPROCS&gt;&#x3D;n，或者执行 <code>runtime.GOMAXPROCS(n)</code>，接下来协程会被分割（分散）到 n 个处理器上。更多的处理器并不意味着性能的线性提升。有这样一个经验法则，对于 n 个核心的情况设置 GOMAXPROCS 为 n-1 以获得最佳性能，也同样需要遵守这条规则：协程的数量 &gt; 1 + GOMAXPROCS &gt; 1。</p><p>​所以如果在某一时间只有一个协程在执行，不要设置 GOMAXPROCS！</p><p>​还有一些通过实验观察到的现象：在一台 1 颗 CPU 的笔记本电脑上，增加 GOMAXPROCS 到 9 会带来性能提升。在一台 32 核的机器上，设置 GOMAXPROCS&#x3D;8 会达到最好的性能，在测试环境中，更高的数值无法提升性能。如果设置一个很大的 GOMAXPROCS 只会带来轻微的性能下降；设置 GOMAXPROCS&#x3D;100，使用 <code>top</code> 命令和 <code>H</code> 选项查看到只有 7 个活动的线程。</p><p>​增加 GOMAXPROCS 的数值对程序进行并发计算是有好处的；</p><p>​总结：GOMAXPROCS 等同于（并发的）线程数量，在一台核心数多于1个的机器上，会尽可能有等同于核心数的线程在并行运行。</p><p>​14.1.4如何用命令行指定使用的核心数量</p><p>​使用 <code>flags</code> 包，如下：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> numCores = flag.<span class="hljs-keyword">Int</span>(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;number of CPU cores to use&quot;</span>)<br></code></pre></td></tr></table></figure><p>​在 main() 中：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">flag.<span class="hljs-constructor">Parse()</span><br>runtime.<span class="hljs-constructor">GOMAXPROCS(<span class="hljs-operator">*</span><span class="hljs-params">numCores</span>)</span><br></code></pre></td></tr></table></figure><p>​协程可以通过调用<code>runtime.Goexit()</code>来停止，尽管这样做几乎没有必要。</p><p>​<code>main()</code>，<code>longWait()</code> 和 <code>shortWait()</code> 三个函数作为独立的处理单元按顺序启动，然后开始并行运行。每一个函数都在运行的开始和结束阶段输出了消息。为了模拟他们运算的时间消耗，我们使用了 <code>time</code> 包中的 <code>Sleep</code> 函数。<code>Sleep()</code> 可以按照指定的时间来暂停函数或协程的执行，这里使用了纳秒（ns，符号 1e9 表示 1 乘 10 的 9 次方，e&#x3D;指数）。</p><p>​他们按照我们期望的顺序打印出了消息，几乎都一样，可是我们明白这是模拟出来的，以并行的方式。我们让 <code>main()</code> 函数暂停 10 秒从而确定它会在另外两个协程之后结束。如果不这样（如果我们让 <code>main()</code> 函数停止 4 秒），<code>main()</code> 会提前结束，<code>longWait()</code> 则无法完成。如果我们不在 <code>main()</code> 中等待，协程会随着程序的结束而消亡。</p><p>​当 <code>main()</code> 函数返回的时候，程序退出：它不会等待任何其他非 main 协程的结束。这就是为什么在服务器程序中，每一个请求都会启动一个协程来处理，<code>server()</code> 函数必须保持运行状态。通常使用一个无限循环来达到这样的目的。</p><p>​另外，协程是独立的处理单元，一旦陆续启动一些协程，你无法确定他们是什么时候真正开始执行的。你的代码逻辑必须独立于协程调用的顺序。</p><p>​为了对比使用一个线程，连续调用的情况，移除 go 关键字，重新运行程序。</p><p>​现在输出：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable"><span class="hljs-keyword">In</span></span> <span class="hljs-function"><span class="hljs-title">main</span>()</span><br><span class="hljs-variable">Beginning</span> <span class="hljs-function"><span class="hljs-title">longWait</span>()</span><br><span class="hljs-variable">End</span> <span class="hljs-variable">of</span> <span class="hljs-function"><span class="hljs-title">longWait</span>()</span><br><span class="hljs-variable">Beginning</span> <span class="hljs-function"><span class="hljs-title">shortWait</span>()</span><br><span class="hljs-variable">End</span> <span class="hljs-variable">of</span> <span class="hljs-function"><span class="hljs-title">shortWait</span>()</span><br><span class="hljs-variable">About</span> <span class="hljs-variable">to</span> <span class="hljs-variable">sleep</span> <span class="hljs-variable"><span class="hljs-keyword">in</span></span> <span class="hljs-function"><span class="hljs-title">main</span>()</span><br><span class="hljs-variable">At</span> <span class="hljs-variable">the</span> <span class="hljs-variable">end</span> <span class="hljs-variable">of</span> <span class="hljs-function"><span class="hljs-title">main</span>() <span class="hljs-comment">// after 17 s</span></span><br></code></pre></td></tr></table></figure><p>​协程更有用的一个例子应该是在一个非常长的数组中查找一个元素。</p><p>​将数组分割为若干个不重复的切片，然后给每一个切片启动一个协程进行查找计算。这样许多并行的协程可以用来进行查找任务，整体的查找时间会缩短（除以协程的数量）。</p><p>​14.1.5Go协程(goroutines)和协程(coroutines)</p><p>​（译者注：标题中的“Go协程（goroutines）” 即是 14 章讲的协程指的是 Go 语言中的协程。而“协程（coroutines）”指的是其他语言中的协程概念，仅在本节出现。）</p><p>​在其他语言中，比如 C#，Lua 或者 Python 都有协程的概念。这个名字表明它和 Go协程有些相似，不过有两点不同：</p><p>​1)Go 协程意味着并行（或者可以以并行的方式部署），协程一般来说不是这样的</p><p>​2)Go 协程通过通道来通信；协程通过让出和恢复操作来通信</p><p>​Go 协程比协程更强大，也很容易从协程的逻辑复用到 Go 协程。</p><h6 id="14-2使用通道进行协程间通信"><a href="#14-2使用通道进行协程间通信" class="headerlink" title="14.2使用通道进行协程间通信"></a>14.2使用通道进行协程间通信</h6><p>​14.2.1概念</p><p>​在第一个例子中，协程是独立执行的，他们之间没有通信。他们必须通信才会变得更有用：彼此之间发送和接收信息并且协调&#x2F;同步他们的工作。协程可以使用共享变量来通信，但是很不提倡这样做，因为这种方式给所有的共享内存的多线程都带来了困难。</p><p>​而 Go 有一种特殊的类型，<em>通道（channel）</em>，就像一个可以用于发送类型化数据的管道，由其负责协程之间的通信，从而避开所有由共享内存导致的陷阱；这种通过通道进行通信的方式保证了同步性。数据在通道中进行传递：<em>在任何给定时间，一个数据被设计为只有一个协程可以对其访问，所以不会发生数据竞争。</em> 数据的所有权（可以读写数据的能力）也因此被传递。</p><p>​工厂的传送带是个很有用的例子。一个机器（生产者协程）在传送带上放置物品，另外一个机器（消费者协程）拿到物品并打包。</p><p>​通道服务于通信的两个目的：值的交换，同步的，保证了两个计算（协程）任何时候都是可知状态。</p><p><img src="https://raw.githubusercontent.com/unknwon/the-way-to-go_ZH_CN/master/eBook/images/14.2_fig14.1.png" alt="img"></p><p>​通常使用这样的格式来声明通道：<code>var identifier chan datatype</code></p><p>​未初始化的通道的值是 nil 。</p><p>​所以通道只能传输一种类型的数据，比如 <code>chan int</code> 或者 <code>chan string</code>，所有的类型都可以用于通道，空接口 <code>interface&#123;&#125;</code> 也可以，甚至可以（有时非常有用）创建通道的通道。</p><p>​通道实际上是类型化消息的队列：使数据得以传输。它是先进先出（FIFO）的结构所以可以保证发送给他们的元素的顺序（有些人知道，通道可以比作 Unix shells 中的双向管道（two-way pipe））。通道也是引用类型，所以我们使用 <code>make()</code> 函数来给它分配内存。这里先声明了一个字符串通道 ch1，然后创建了它（实例化）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span><br>ch1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure><p>​当然可以更短： <code>ch1 := make(chan string)</code>。</p><p>​这里我们构建一个 int 通道的通道： <code>chanOfChans := make(chan chan int)</code>。</p><p>​或者函数通道：<code>funcChan := make(chan func())</code>（相关示例请看第 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.17.md">14.17</a> 节）。</p><p>​所以通道是第一类对象：可以存储在变量中，作为函数的参数传递，从函数返回以及通过通道发送它们自身。另外它们是类型化的，允许类型检查，比如尝试使用整数通道发送一个指针。</p><p>​14.2.2通信操作符&lt;-</p><p>​这个操作符直观的标示了数据的传输：信息按照箭头的方向流动。</p><p>​流向通道（发送）</p><p>​<code>ch &lt;- int1</code> 表示：用通道 ch 发送变量 int1（双目运算符，中缀 &#x3D; 发送）</p><p>​从通道流出（接收），三种方式：</p><p>​<code>int2 = &lt;- ch</code> 表示：变量 int2 从通道 ch（一元运算的前缀操作符，前缀 &#x3D; 接收）接收数据（获取新值）；假设 int2 已经声明过了，如果没有的话可以写成：<code>int2 := &lt;- ch</code>。</p><p>​<code>&lt;- ch</code> 可以单独调用获取通道的（下一个）值，当前值会被丢弃，但是可以用来验证，所以以下代码是合法的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">if</span> <span class="hljs-string">&lt;-</span> <span class="hljs-string">ch</span> <span class="hljs-type">!=</span> <span class="hljs-number">1000</span>&#123;<br><span class="hljs-string">...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​同一个操作符 <code>&lt;-</code> 既用于<strong>发送</strong>也用于<strong>接收</strong>，但 Go 会根据操作对象弄明白该干什么 。虽非强制要求，但为了可读性通道的命名通常以 <code>ch</code> 开头或者包含 <code>chan</code> 。通道的发送和接收都是原子操作：它们总是互不干扰地完成。</p><p>​<code>main()</code> 函数中启动了两个协程：<code>sendData()</code> 通过通道 ch 发送了 5 个字符串，<code>getData()</code> 按顺序接收它们并打印出来。</p><p>​如果 2 个协程需要通信，你必须给他们同一个通道作为参数才行。</p><p>​尝试一下如果注释掉 <code>time.Sleep(1e9)</code> 会如何。</p><p>​我们发现协程之间的同步非常重要：</p><ul><li>main() 等待了 1 秒让两个协程完成，如果不这样，sendData() 就没有机会输出。</li><li>getData() 使用了无限循环：它随着 sendData() 的发送完成和 ch 变空也结束了。</li><li>如果我们移除一个或所有 <code>go</code> 关键字，程序无法运行，Go 运行时会抛出 panic：</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">---- Error run E:/Go/Goboek/<span class="hljs-keyword">code</span> examples/chapter <span class="hljs-number">14</span>/goroutine2.exe <span class="hljs-keyword">with</span> <span class="hljs-keyword">code</span> Crashed ---- Program exited <span class="hljs-keyword">with</span> <span class="hljs-keyword">code</span> <span class="hljs-number">-2147483645</span>: panic: all goroutines are asleep-deadlock!<br></code></pre></td></tr></table></figure><p>​为什么会这样？运行时(runtime)会检查所有的协程(像本例中只有一个)是否在等待着什么东西(可从某个通道读取或者写入某个通道)，这意味着程序将无法继续执行。这是死锁(deadlock)的一种形式，而运行时(runtime)可以为我们检测到这种情况。</p><p>​注意：不要使用打印状态来表明通道的发送和接收顺序：由于打印状态和通道实际发生读写的时间延迟会导致和真实发生的顺序不同。</p><p>​14.2.3通道阻塞</p><p>​默认情况下，通信是同步且无缓冲的：在有接受者接收数据之前，发送不会结束。可以想象一个无缓冲的通道在没有空间来保存数据的时候：必须要一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者。所以通道的发送&#x2F;接收操作在对方准备好之前是阻塞的：</p><p>​1）对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果 ch 中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。</p><p>​2）对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。</p><p>​尽管这看上去是非常严格的约束，实际在大部分情况下工作的很不错。</p><p>​程序 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_14/channel_block.go">channel_block.go</a> 验证了以上理论，一个协程在无限循环中给通道发送整数数据。不过因为没有接收者，只输出了一个数字 0。</p><p>​14.2.4通过一个(或多个)通道交换数据进行协程同步</p><p>​通信是一种同步形式：通过通道，两个协程在通信（协程会和）中某刻同步交换数据。无缓冲通道成为了多个协程同步的完美工具。</p><p>​甚至可以在通道两端互相阻塞对方，形成了叫做死锁的状态。Go 运行时会检查并 panic，停止程序。死锁几乎完全是由糟糕的设计导致的。</p><p>​无缓冲通道会被阻塞。设计无阻塞的程序可以避免这种情况，或者使用带缓冲的通道。</p><p>​14.2.5同步通道—使用带缓冲的通道</p><p>​一个无缓冲通道只能包含 1 个元素，有时显得很局限。我们给通道提供了一个缓存，可以在扩展的 <code>make</code> 命令中设置它的容量，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">buf := <span class="hljs-number">100</span><br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, buf)<br></code></pre></td></tr></table></figure><p>​buf 是通道可以同时容纳的元素（这里是 string）个数</p><p>​在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。</p><p>​缓冲容量和类型无关，所以可以（尽管可能导致危险）给一些通道设置不同的容量，只要他们拥有同样的元素类型。内置的 <code>cap</code> 函数可以返回缓冲区的容量。</p><p>​如果容量大于 0，通道就是异步的了：缓冲满载（发送）或变空（接收）之前通信不会阻塞，元素会按照发送的顺序被接收。如果容量是 0 或者未设置，通信仅在收发双方准备好的情况下才可以成功。</p><p>​同步：<code>ch :=make(chan type, value)</code></p><p>​1)value &#x3D;&#x3D; 0 -&gt; synchronous, unbuffered (阻塞）</p><p>​2)value &gt; 0 -&gt; asynchronous, buffered（非阻塞）取决于 value 元素</p><p>​若使用通道的缓冲，你的程序会在“请求”激增的时候表现更好：更具弹性，专业术语叫：更具有伸缩性（scalable）。在设计算法时首先考虑使用无缓冲通道，只在不确定的情况下使用缓冲。</p><p>​14.2.6协程中用通道输出结果</p><p>​为了知道计算何时完成，可以通过信道回报。在例子 <code>go sum(bigArray)</code> 中，要这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> sum(bigArray, ch) <span class="hljs-comment">// bigArray puts the calculated sum on ch</span><br><span class="hljs-comment">// .. do something else for a while</span><br>sum := &lt;- ch <span class="hljs-comment">// wait for, and retrieve the sum</span><br></code></pre></td></tr></table></figure><p>​也可以使用通道来达到同步的目的，这个很有效的用法在传统计算机中称为信号量（semaphore）。或者换个方式：通过通道发送信号告知处理已经完成（在协程中）。</p><p>​在其他协程运行时让 main 程序无限阻塞的通常做法是在 <code>main</code> 函数的最后放置一个 <code>select &#123;&#125;</code>。</p><p>​也可以使用通道让 <code>main</code> 程序等待协程完成，就是所谓的信号量模式，我们会在接下来的部分讨论。</p><p>​14.2.7信号量模式</p><p>​下边的片段阐明：协程通过在通道 <code>ch</code> 中放置一个值来处理结束的信号。<code>main</code> 协程等待 <code>&lt;-ch</code> 直到从中获取到值。</p><p>​我们期望从这个通道中获取返回的结果，像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compute</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span>&#123;<br>ch &lt;- someComputation() <span class="hljs-comment">// when it completes, signal on the channel.</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// allocate a channel.</span><br><span class="hljs-keyword">go</span> compute(ch)<span class="hljs-comment">// start something in a goroutines</span><br>doSomethingElseForAWhile()<br>result := &lt;- ch<br>&#125;<br></code></pre></td></tr></table></figure><p>​这个信号也可以是其他的，不返回结果，比如下面这个协程中的匿名函数（lambda）协程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">// doSomething</span><br>ch &lt;- <span class="hljs-number">1</span> <span class="hljs-comment">// Send a signal; value does not matter</span><br>&#125;()<br>doSomethingElseForAWhile()<br>&lt;- ch<span class="hljs-comment">// Wait for goroutine to finish; discard sent value.</span><br></code></pre></td></tr></table></figure><p>​或者等待两个协程完成，每一个都会对切片 s 的一部分进行排序，片段如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br><span class="hljs-comment">// doSort is a lambda function, so a closure which knows the channel done:</span><br>doSort := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s []<span class="hljs-type">int</span>)</span></span>&#123;<br>sort(s)<br>done &lt;- <span class="hljs-literal">true</span><br>&#125;<br>i := pivot(s)<br><span class="hljs-keyword">go</span> doSort(s[:i])<br><span class="hljs-keyword">go</span> doSort(s[i:])<br>&lt;-done<br>&lt;-done<br></code></pre></td></tr></table></figure><p>​下边的代码，用完整的信号量模式对长度为 N 的 float64 切片进行了 N 个 <code>doSomething()</code> 计算并同时完成，通道 sem 分配了相同的长度（且包含空接口类型的元素），待所有的计算都完成后，发送信号（通过放入值）。在循环中从通道 sem 不停的接收数据来等待所有的协程完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Empty <span class="hljs-keyword">interface</span> &#123;&#125;<br><span class="hljs-keyword">var</span> empty Empty<br>...<br>data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">float64</span>, N)<br>res := <span class="hljs-built_in">make</span>([]<span class="hljs-type">float64</span>, N)<br>sem := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Empty, N)<br>...<br><span class="hljs-keyword">for</span> i, xi := <span class="hljs-keyword">range</span> data &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i <span class="hljs-type">int</span>, xi <span class="hljs-type">float64</span>)</span></span> &#123;<br>res[i] = doSomething(i, xi)<br>sem &lt;- empty<br>&#125; (i, xi)<br>&#125;<br><span class="hljs-comment">// wait for goroutines to finish</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123; &lt;-sem &#125;<br></code></pre></td></tr></table></figure><p>​注意上述代码中闭合函数的用法：<code>i</code>、<code>xi</code> 都是作为参数传入闭合函数的，这一做法使得每个协程(译者注：在其启动时)获得一份 <code>i</code> 和 <code>xi</code> 的单独拷贝，从而向闭合函数内部屏蔽了外层循环中的 <code>i</code> 和 <code>xi</code> 变量；否则，for 循环的下一次迭代会更新所有协程中 <code>i</code> 和 <code>xi</code> 的值。另一方面，切片 <code>res</code> 没有传入闭合函数，因为协程不需要 <code>res</code> 的单独拷贝。切片 <code>res</code> 也在闭合函数中但并不是参数。</p><p>​14.2.8实现并行的for循环</p><p>​在上一部分章节 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.2.md#1427-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E5%BC%8F">14.2.7</a> 的代码片段中：for 循环的每一个迭代是并行完成的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> data &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i <span class="hljs-type">int</span>, v <span class="hljs-type">float64</span>)</span></span> &#123;<br>doSomething(i, v)<br>...<br>&#125; (i, v)<br>&#125;<br></code></pre></td></tr></table></figure><p>​在 for 循环中并行计算迭代可能带来很好的性能提升。不过所有的迭代都必须是独立完成的。有些语言比如 Fortress 或者其他并行框架以不同的结构实现了这种方式，在 Go 中用协程实现起来非常容易。</p><p>​14.2.9用带缓冲通道实现一个信号量</p><p>​信号量是实现互斥锁（排外锁）常见的同步机制，限制对资源的访问，解决读写问题，比如没有实现信号量的 <code>sync</code> 的 Go 包，使用带缓冲的通道可以轻松实现：</p><ul><li><p>带缓冲通道的容量和要同步的资源容量相同</p></li><li><p>通道的长度（当前存放的元素个数）与当前资源被使用的数量相同</p></li><li><p>容量减去通道的长度就是未处理的资源个数（标准信号量的整数值）</p><p>不用管通道中存放的是什么，只关注长度；因此我们创建了一个长度可变但容量为 0(字节)的通道：</p></li></ul><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">type</span> <span class="hljs-type">Empty </span><span class="hljs-keyword">interface</span> &#123;&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-type">semaphore </span>chan Empty<br></code></pre></td></tr></table></figure><p>​将可用资源的数量N来初始化信号量 <code>semaphore</code>：<code>sem = make(semaphore, N)</code></p><p>​然后直接对信号量进行操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// acquire n resources</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s semaphore)</span></span> P(n <span class="hljs-type">int</span>) &#123;<br>e := <span class="hljs-built_in">new</span>(Empty)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>s &lt;- e<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// release n resources</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s semaphore)</span></span> V(n <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i &lt; n; i++&#123;<br>&lt;- s<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​可以用来实现一个互斥的例子：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">/* mutexes */</span><br>func (s semaphore) <span class="hljs-built_in">Lock</span>() &#123;<br>s<span class="hljs-selector-class">.P</span>(<span class="hljs-number">1</span>)<br>&#125;<br><br>func (s semaphore) <span class="hljs-built_in">Unlock</span>()&#123;<br>s<span class="hljs-selector-class">.V</span>(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">/* signal-wait */</span><br>func (s semaphore) Wait(n int) &#123;<br>s<span class="hljs-selector-class">.P</span>(n)<br>&#125;<br><br>func (s semaphore) <span class="hljs-built_in">Signal</span>() &#123;<br>s<span class="hljs-selector-class">.V</span>(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>​14.2.10给通道使用for循环</p><p>​<code>for</code> 循环的 <code>range</code> 语句可以用在通道 <code>ch</code> 上，便可以从通道中获取值，像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Printf(<span class="hljs-string">&quot;The value is %v\n&quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure><p>​它从指定通道中读取数据直到通道关闭，才继续执行下边的代码。很明显，另外一个协程必须写入 <code>ch</code>（不然代码就阻塞在 for 循环了），而且必须在写入完成后才关闭。<code>suck</code> 函数可以这样写，且在协程中调用这个动作，程序变成了这样：</p><p>​习惯用法：通道迭代模式</p><p>​这个模式用到了后边 14.6 章示例 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/exercises/chapter_14/producer_consumer.go">producer_consumer.go</a> 的生产者-消费者模式，通常，需要从包含了地址索引字段 items 的容器给通道填入元素。为容器的类型定义一个方法 <code>Iter()</code>，返回一个只读的通道（参见第 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.2.md#14211-%E9%80%9A%E9%81%93%E7%9A%84%E6%96%B9%E5%90%91">14.2.11</a> 节）items，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *container)</span></span> Iter () &lt;- <span class="hljs-keyword">chan</span> item &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> item)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>; i &lt; c.Len(); i++&#123;<span class="hljs-comment">// or use a for-range loop</span><br>ch &lt;- c.items[i]<br>&#125;<br>&#125; ()<br><span class="hljs-keyword">return</span> ch<br>&#125;<br></code></pre></td></tr></table></figure><p>​在协程里，一个 for 循环迭代容器 c 中的元素（对于树或图的算法，这种简单的 for 循环可以替换为深度优先搜索）。</p><p>​调用这个方法的代码可以这样迭代容器：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">for x := range container.<span class="hljs-built_in">Iter</span>() &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>​其运行在自己启动的协程中，所以上边的迭代用到了一个通道和两个协程（可能运行在不同的线程上）。 这样我们就有了一个典型的生产者-消费者模式。如果在程序结束之前，向通道写值的协程未完成工作，则这个协程不会被垃圾回收；这是设计使然。这种看起来并不符合预期的行为正是由通道这种线程安全的通信方式所导致的。如此一来，一个协程为了写入一个永远无人读取的通道而被挂起就成了一个 bug ，而并非你预想中的那样被悄悄回收掉（garbage-collected）了。</p><p>​习惯用法：生产者消费者模式</p><p>​假设你有 <code>Produce()</code> 函数来产生 <code>Consume</code> 函数需要的值。它们都可以运行在独立的协程中，生产者在通道中放入给消费者读取的值。整个处理过程可以替换为无限循环：</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">for</span> &#123;<br><span class="hljs-function"><span class="hljs-title">Consume</span>(<span class="hljs-title">Produce</span>())</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​14.2.11通道的方向</p><p>​通道类型可以用注解来表示它只发送或者只接收：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> send_only <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span> <span class="hljs-comment">// channel can only receive data</span><br><span class="hljs-keyword">var</span> recv_only &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span><span class="hljs-comment">// channel can only send data</span><br></code></pre></td></tr></table></figure><p>​只接收的通道（&lt;-chan T）无法关闭，因为关闭通道是发送者用来表示不再给通道发送值了，所以对只接收通道是没有意义的。通道创建的时候都是双向的，但也可以分配有方向的通道变量，就像以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// bidirectional</span><br><span class="hljs-keyword">go</span> source(c)<br><span class="hljs-keyword">go</span> sink(c)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">source</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> &#123; ch &lt;- <span class="hljs-number">1</span> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sink</span><span class="hljs-params">(ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123; &lt;-ch &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​习惯用法：管道和选择器模式</p><p>​更具体的例子还有协程处理它从通道接收的数据并发送给输出通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">sendChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>receiveChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> processChannel(sendChan, receiveChan)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processChannel</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> inValue := <span class="hljs-keyword">range</span> in &#123;<br>result := ... <span class="hljs-comment">/// processing inValue</span><br>out &lt;- result<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​通过使用方向注解来限制协程对通道的操作。</p><p>​这里有一个来自 Go 指导的很赞的例子，打印了输出的素数，使用选择器（‘筛’）作为它的算法。每个 prime 都有一个选择器，如下图：</p><p><img src="https://github.com/unknwon/the-way-to-go_ZH_CN/raw/master/eBook/images/14.2_fig14.2.png?raw=true" alt="img"></p><p>​协程 <code>filter(in, out chan int, prime int)</code> 拷贝整数到输出通道，丢弃掉可以被 prime 整除的数字。然后每个 prime 又开启了一个新的协程，生成器和选择器并发请求。</p><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">7</span> <span class="hljs-number">11</span> <span class="hljs-number">13</span> <span class="hljs-number">17</span> <span class="hljs-number">19</span> <span class="hljs-number">23</span> <span class="hljs-number">29</span> <span class="hljs-number">31</span> <span class="hljs-number">37</span> <span class="hljs-number">41</span> <span class="hljs-number">43</span> <span class="hljs-number">47</span> <span class="hljs-number">53</span> <span class="hljs-number">59</span> <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">71</span> <span class="hljs-number">73</span> <span class="hljs-number">79</span> <span class="hljs-number">83</span> <span class="hljs-number">89</span> <span class="hljs-number">97</span> <span class="hljs-number">101</span><br><span class="hljs-attribute">103</span> <span class="hljs-number">107</span> <span class="hljs-number">109</span> <span class="hljs-number">113</span> <span class="hljs-number">127</span> <span class="hljs-number">131</span> <span class="hljs-number">137</span> <span class="hljs-number">139</span> <span class="hljs-number">149</span> <span class="hljs-number">151</span> <span class="hljs-number">157</span> <span class="hljs-number">163</span> <span class="hljs-number">167</span> <span class="hljs-number">173</span> <span class="hljs-number">179</span> <span class="hljs-number">181</span> <span class="hljs-number">191</span> <span class="hljs-number">193</span> <span class="hljs-number">197</span> <span class="hljs-number">199</span> <span class="hljs-number">211</span> <span class="hljs-number">223</span><br><span class="hljs-attribute">227</span> <span class="hljs-number">229</span> <span class="hljs-number">233</span> <span class="hljs-number">239</span> <span class="hljs-number">241</span> <span class="hljs-number">251</span> <span class="hljs-number">257</span> <span class="hljs-number">263</span> <span class="hljs-number">269</span> <span class="hljs-number">271</span> <span class="hljs-number">277</span> <span class="hljs-number">281</span> <span class="hljs-number">283</span> <span class="hljs-number">293</span> <span class="hljs-number">307</span> <span class="hljs-number">311</span> <span class="hljs-number">313</span> <span class="hljs-number">317</span> <span class="hljs-number">331</span> <span class="hljs-number">337</span> <span class="hljs-number">347</span> <span class="hljs-number">349</span><br><span class="hljs-attribute">353</span> <span class="hljs-number">359</span> <span class="hljs-number">367</span> <span class="hljs-number">373</span> <span class="hljs-number">379</span> <span class="hljs-number">383</span> <span class="hljs-number">389</span> <span class="hljs-number">397</span> <span class="hljs-number">401</span> <span class="hljs-number">409</span> <span class="hljs-number">419</span> <span class="hljs-number">421</span> <span class="hljs-number">431</span> <span class="hljs-number">433</span> <span class="hljs-number">439</span> <span class="hljs-number">443</span> <span class="hljs-number">449</span> <span class="hljs-number">457</span> <span class="hljs-number">461</span> <span class="hljs-number">463</span> <span class="hljs-number">467</span> <span class="hljs-number">479</span><br><span class="hljs-attribute">487</span> <span class="hljs-number">491</span> <span class="hljs-number">499</span> <span class="hljs-number">503</span> <span class="hljs-number">509</span> <span class="hljs-number">521</span> <span class="hljs-number">523</span> <span class="hljs-number">541</span> <span class="hljs-number">547</span> <span class="hljs-number">557</span> <span class="hljs-number">563</span> <span class="hljs-number">569</span> <span class="hljs-number">571</span> <span class="hljs-number">577</span> <span class="hljs-number">587</span> <span class="hljs-number">593</span> <span class="hljs-number">599</span> <span class="hljs-number">601</span> <span class="hljs-number">607</span> <span class="hljs-number">613</span> <span class="hljs-number">617</span> <span class="hljs-number">619</span><br><span class="hljs-attribute">631</span> <span class="hljs-number">641</span> <span class="hljs-number">643</span> <span class="hljs-number">647</span> <span class="hljs-number">653</span> <span class="hljs-number">659</span> <span class="hljs-number">661</span> <span class="hljs-number">673</span> <span class="hljs-number">677</span> <span class="hljs-number">683</span> <span class="hljs-number">691</span> <span class="hljs-number">701</span> <span class="hljs-number">709</span> <span class="hljs-number">719</span> <span class="hljs-number">727</span> <span class="hljs-number">733</span> <span class="hljs-number">739</span> <span class="hljs-number">743</span> <span class="hljs-number">751</span> <span class="hljs-number">757</span> <span class="hljs-number">761</span> <span class="hljs-number">769</span><br><span class="hljs-attribute">773</span> <span class="hljs-number">787</span> <span class="hljs-number">797</span> <span class="hljs-number">809</span> <span class="hljs-number">811</span> <span class="hljs-number">821</span> <span class="hljs-number">823</span> <span class="hljs-number">827</span> <span class="hljs-number">829</span> <span class="hljs-number">839</span> <span class="hljs-number">853</span> <span class="hljs-number">857</span> <span class="hljs-number">859</span> <span class="hljs-number">863</span> <span class="hljs-number">877</span> <span class="hljs-number">881</span> <span class="hljs-number">883</span> <span class="hljs-number">887</span> <span class="hljs-number">907</span> <span class="hljs-number">911</span> <span class="hljs-number">919</span> <span class="hljs-number">929</span><br><span class="hljs-attribute">937</span> <span class="hljs-number">941</span> <span class="hljs-number">947</span> <span class="hljs-number">953</span> <span class="hljs-number">967</span> <span class="hljs-number">971</span> <span class="hljs-number">977</span> <span class="hljs-number">983</span> <span class="hljs-number">991</span> <span class="hljs-number">997</span> <span class="hljs-number">1009</span> <span class="hljs-number">1013</span>...<br></code></pre></td></tr></table></figure><p>​第二个版本引入了上边的习惯用法：函数 <code>sieve</code>、<code>generate</code> 和 <code>filter</code> 都是工厂；它们创建通道并返回，而且使用了协程的 lambda 函数。<code>main</code> 函数现在短小清晰：它调用 <code>sieve()</code> 返回了包含素数的通道，然后通过 <code>fmt.Println(&lt;-primes)</code> 打印出来。</p><p>​14.3协程的同步：关闭通道-测试阻塞的通道</p><p>​通道可以被显式的关闭；尽管它们和文件不同：不必每次都关闭。只有在当需要告诉接收者不会再提供新的值的时候，才需要关闭通道。只有发送者需要关闭通道，接收者永远不会需要。</p><p>​继续看示例 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_14/goroutine2.go">goroutine2.go</a>（示例 14.2）：我们如何在通道的 <code>sendData()</code> 完成的时候发送一个信号，<code>getData()</code> 又如何检测到通道是否关闭或阻塞？</p><p>​第一个可以通过函数 <code>close(ch)</code> 来完成：这个将通道标记为无法通过发送操作 <code>&lt;-</code> 接受更多的值；给已经关闭的通道发送或者再次关闭都会导致运行时的 panic。在创建一个通道后使用 defer 语句是个不错的办法（类似这种情况）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">float64</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-built_in">close</span>(ch)<br></code></pre></td></tr></table></figure><p>​第二个问题可以使用逗号，ok 操作符：用来检测通道是否被关闭。</p><p>​如何来检测可以收到没有被阻塞（或者通道没有被关闭）？</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">v, ok := &lt;-ch   <span class="hljs-comment">// ok is true if v received value</span><br></code></pre></td></tr></table></figure><p>​通常和 if 语句一起使用：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">if v, ok := &lt;-ch; ok &#123;<br>  process(v)<br>&#125;<br></code></pre></td></tr></table></figure><p>​或者在 for 循环中接收的时候，当关闭的时候使用 break：</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">v, ok := &lt;-ch<br>if !ok &#123;<br>  break<br>&#125;<br>process(v)<br></code></pre></td></tr></table></figure><p>​而检测通道当前是否阻塞，需要使用 select（参见第 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.4.md">14.4</a> 节）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> v, ok := &lt;-ch:<br>  <span class="hljs-keyword">if</span> ok &#123;<br>    process(v)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;The channel is closed&quot;</span>)<br>  &#125;<br><span class="hljs-keyword">default</span>:<br>  fmt.Println(<span class="hljs-string">&quot;The channel is blocked&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>​在示例程序 14.2 中使用这些可以改进为版本 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_14/goroutine3.go">goroutine3.go</a>，输出相同。</p><p>​实现非阻塞通道的读取，需要使用 select</p><p>​改变了以下代码：</p><ul><li>现在只有 <code>sendData()</code> 是协程，<code>getData()</code> 和 <code>main()</code> 在同一个线程中：</li></ul><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">go</span> <span class="hljs-function"><span class="hljs-title">sendData</span>(<span class="hljs-variable">ch</span>)</span><br><span class="hljs-function"><span class="hljs-title">getData</span>(<span class="hljs-variable">ch</span>)</span><br></code></pre></td></tr></table></figure><ul><li>在 <code>sendData()</code> 函数的最后，关闭了通道：</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">func sendData(<span class="hljs-number">ch</span> chan string) &#123;<br><span class="hljs-number">ch</span> &lt;- <span class="hljs-string">&quot;Washington&quot;</span><br><span class="hljs-number">ch</span> &lt;- <span class="hljs-string">&quot;Tripoli&quot;</span><br><span class="hljs-number">ch</span> &lt;- <span class="hljs-string">&quot;London&quot;</span><br><span class="hljs-number">ch</span> &lt;- <span class="hljs-string">&quot;Beijing&quot;</span><br><span class="hljs-number">ch</span> &lt;- <span class="hljs-string">&quot;Tokio&quot;</span><br>close(<span class="hljs-number">ch</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在 for 循环的 <code>getData()</code> 中，在每次接收通道的数据之前都使用 <code>if !open</code> 来检测：</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-built_in">input</span>, <span class="hljs-built_in">open</span> := &lt;-ch<br><span class="hljs-keyword">if</span> !<span class="hljs-built_in">open</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s &quot;</span>, <span class="hljs-built_in">input</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>​使用 for-range 语句来读取通道是更好的办法，因为这会自动检测通道是否关闭：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">for <span class="hljs-selector-tag">input</span> := range ch &#123;<br>  process(<span class="hljs-selector-tag">input</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>​阻塞和生产者-消费者模式：</p><p>​在第 14.2.10 节的通道迭代器中，两个协程经常是一个阻塞另外一个。如果程序工作在多核心的机器上，大部分时间只用到了一个处理器。可以通过使用带缓冲（缓冲空间大于 0）的通道来改善。比如，缓冲大小为 100，迭代器在阻塞之前，至少可以从容器获得 100 个元素。如果消费者协程在独立的内核运行，就有可能让协程不会出现阻塞。</p><p>​由于容器中元素的数量通常是已知的，需要让通道有足够的容量放置所有的元素。这样，迭代器就不会阻塞（尽管消费者协程仍然可能阻塞）。然而，这实际上加倍了迭代容器所需要的内存使用量，所以通道的容量需要限制一下最大值。记录运行时间和性能测试可以帮助你找到最小的缓存容量带来最好的性能。</p><p>​14.4使用select切换协程</p><p>​从不同的并发执行的协程中获取值可以通过关键字 <code>select</code> 来完成，它和 <code>switch</code> 控制语句非常相似（章节5.3）也被称作通信开关；它的行为像是“你准备好了吗”的轮询机制；<code>select</code> 监听进入通道的数据，也可以是用通道发送值的时候。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> u:= &lt;- ch1:<br>        <span class="hljs-params">...</span><br><span class="hljs-keyword">case</span> v:= &lt;- ch2:<br>        <span class="hljs-params">...</span><br>        <span class="hljs-params">...</span><br>default: <span class="hljs-comment">// no value ready to be received</span><br>        <span class="hljs-params">...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>default</code> 语句是可选的；fallthrough 行为，和普通的 switch 相似，是不允许的。在任何一个 case 中执行 <code>break</code> 或者 <code>return</code>，select 就结束了。</p><p>​<code>select</code> 做的就是：选择处理列出的多个通信情况中的一个。</p><p>​1)如果都阻塞了，会等待直到其中一个可以处理</p><p>​2)如果多个可以处理，随机选择一个</p><p>​3)如果没有通道操作可以处理并且写了 <code>default</code> 语句，它就会执行：<code>default</code> 永远是可运行的（这就是准备好了，可以执行）。</p><p>​在 <code>select</code> 中使用发送操作并且有 <code>default</code> 可以确保发送不被阻塞！如果没有 <code>default</code>，select 就会一直阻塞。</p><p>​<code>select</code> 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 <code>break</code> 语句使循环退出。</p><p>​s在程序 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_14/goroutine_select.go">goroutine_select.go</a> 中有 2 个通道 <code>ch1</code> 和 <code>ch2</code>，三个协程 <code>pump1()</code>、<code>pump2()</code> 和 <code>suck()</code>。这是一个典型的生产者消费者模式。在无限循环中，<code>ch1</code> 和 <code>ch2</code> 通过 <code>pump1()</code> 和 <code>pump2()</code> 填充整数；<code>suck()</code> 也是在无限循环中轮询输入的，通过 <code>select</code> 语句获取 <code>ch1</code> 和 <code>ch2</code> 的整数并输出。选择哪一个 case 取决于哪一个通道收到了信息。程序在 main 执行 1 秒后结束。</p><p>​14.5通道、超时和计时器(Ticker)</p><p>​<code>time</code> 包中有一些有趣的功能可以和通道组合使用。</p><p>​其中就包含了 <code>time.Ticker</code> 结构体，这个对象以指定的时间间隔重复的向通道 C 发送时间值：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">type</span> Ticker <span class="hljs-keyword">struct</span> &#123;<br>    C &lt;-chan <span class="hljs-built_in">Time</span> <span class="hljs-comment">// the channel on which the ticks are delivered.</span><br>    <span class="hljs-comment">// contains filtered or unexported fields</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>​时间间隔的单位是 ns（纳秒，int64），在工厂函数 <code>time.NewTicker</code> 中以 <code>Duration</code> 类型的参数传入：<code>func NewTicker(dur) *Ticker</code>。</p><p>​在协程周期性的执行一些事情（打印状态日志，输出，计算等等）的时候非常有用。</p><p>​调用 <code>Stop()</code> 使计时器停止，在 <code>defer</code> 语句中使用。这些都很好地适应 <code>select</code> 语句:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">ticker := time.NewTicker(updateInterval)<br><span class="hljs-keyword">defer</span> ticker.Stop()<br>...<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> u:= &lt;-ch1:<br>    ...<br><span class="hljs-keyword">case</span> v:= &lt;-ch2:<br>    ...<br><span class="hljs-keyword">case</span> &lt;-ticker.C:<br>    logState(status) <span class="hljs-comment">// call some logging function logState</span><br><span class="hljs-keyword">default</span>: <span class="hljs-comment">// no value ready to be received</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>time.Tick()</code> 函数声明为 <code>Tick(d Duration) &lt;-chan Time</code>，当你想返回一个通道而不必关闭它的时候这个函数非常有用：它以 d 为周期给返回的通道发送时间，d 是纳秒数。如果需要像下边的代码一样，限制处理频率（函数 <code>client.Call()</code> 是一个 RPC 调用，这里暂不赘述（参见第 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/15.9.md">15.9</a> 节）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><br><br>rate_per_sec := <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> dur Duration = <span class="hljs-number">1e9</span> / rate_per_sec<br>chRate := time.Tick(dur) <span class="hljs-comment">// a tick every 1/10th of a second</span><br><span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> requests &#123;<br>    &lt;- chRate <span class="hljs-comment">// rate limit our Service.Method RPC calls</span><br>    <span class="hljs-keyword">go</span> client.Call(<span class="hljs-string">&quot;Service.Method&quot;</span>, req, ...)<br>&#125;<br></code></pre></td></tr></table></figure><p>​这样只会按照指定频率处理请求：<code>chRate</code> 阻塞了更高的频率。每秒处理的频率可以根据机器负载（和&#x2F;或）资源的情况而增加或减少。</p><p>​问题 14.1：扩展上边的代码，思考如何承载周期请求数的暴增（提示：使用带缓冲通道和计时器对象）。</p><p>​定时器（Timer）结构体看上去和计时器（Ticker）结构体的确很像（构造为 <code>NewTimer(d Duration)</code>），但是它只发送一次时间，在 <code>Dration d</code> 之后。</p><p>​还有 <code>time.After(d)</code> 函数，声明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">After</span><span class="hljs-params">(d Duration)</span></span> &lt;-<span class="hljs-keyword">chan</span> Time<br></code></pre></td></tr></table></figure><p>​在 <code>Duration d</code> 之后，当前时间被发到返回的通道；所以它和 <code>NewTimer(d).C</code> 是等价的；它类似 <code>Tick()</code>，但是 <code>After()</code> 只发送一次时间。下边有个很具体的示例，很好的阐明了 <code>select</code> 中 <code>default</code> 的作用：</p><p>​14.6协程和恢复(recover)</p><p>​一个用到 <code>recover</code> 的程序（参见第 13.3 节）停掉了服务器内部一个失败的协程而不影响其他协程的工作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">(workChan &lt;-<span class="hljs-keyword">chan</span> *Work)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> work := <span class="hljs-keyword">range</span> workChan &#123;<br>        <span class="hljs-keyword">go</span> safelyDo(work)   <span class="hljs-comment">// start the goroutine for that work</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">safelyDo</span><span class="hljs-params">(work *Work)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>            log.Printf(<span class="hljs-string">&quot;Work failed with %s in %v&quot;</span>, err, work)<br>        &#125;<br>    &#125;()<br>    do(work)<br>&#125;<br></code></pre></td></tr></table></figure><p>​上边的代码，如果 <code>do(work)</code> 发生 panic，错误会被记录且协程会退出并释放，而其他协程不受影响。</p><p>​因为 <code>recover</code> 总是返回 <code>nil</code>，除非直接在 <code>defer</code> 修饰的函数中调用，<code>defer</code> 修饰的代码可以调用那些自身可以使用 <code>panic</code> 和 <code>recover</code> 避免失败的库例程（库函数）。举例，<code>safelyDo()</code> 中 <code>defer</code> 修饰的函数可能在调用 <code>recover</code> 之前就调用了一个 <code>logging</code> 函数，<code>panicking</code> 状态不会影响 <code>logging</code> 代码的运行。因为加入了恢复模式，函数 <code>do</code>（以及它调用的任何东西）可以通过调用 <code>panic</code> 来摆脱不好的情况。但是恢复是在 <code>panicking</code> 的协程内部的：不能被另外一个协程恢复。</p><p>​14.7新旧模型对比：任务和worker</p><p>​假设我们需要处理很多任务；一个 worker 处理一项任务。任务可以被定义为一个结构体（具体的细节在这里并不重要）：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">type Task struct &#123;<br>    // some <span class="hljs-keyword">state</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​旧模式：使用共享内存进行同步</p><p>由各个任务组成的任务池共享内存；为了同步各个 worker 以及避免资源竞争，我们需要对任务池进行加锁保护：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">Pool</span> struct &#123;<br>    <span class="hljs-type">Mu</span>      sync.<span class="hljs-type">Mutex</span><br>    <span class="hljs-type">Tasks</span>   []*<span class="hljs-type">Task</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​sync.Mutex（<a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/09.3.md">参见9.3</a>）是互斥锁：它用来在代码中保护临界区资源：同一时间只有一个 go 协程（goroutine）可以进入该临界区。如果出现了同一时间多个 go 协程都进入了该临界区，则会产生竞争：Pool 结构就不能保证被正确更新。在传统的模式中（经典的面向对象的语言中应用得比较多，比如 C++，JAVA，C#），worker 代码可能这样写：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">Worker</span>(pool *Pool) &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        pool<span class="hljs-selector-class">.Mu</span><span class="hljs-selector-class">.Lock</span>()<br>        <span class="hljs-comment">// begin critical section:</span><br>        task := pool<span class="hljs-selector-class">.Tasks</span><span class="hljs-selector-attr">[0]</span>        <span class="hljs-comment">// take the first task</span><br>        pool<span class="hljs-selector-class">.Tasks</span> = pool<span class="hljs-selector-class">.Tasks</span><span class="hljs-selector-attr">[1:]</span>  <span class="hljs-comment">// update the pool of tasks</span><br>        <span class="hljs-comment">// end critical section</span><br>        pool<span class="hljs-selector-class">.Mu</span><span class="hljs-selector-class">.Unlock</span>()<br>        <span class="hljs-built_in">process</span>(task)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这些 worker 有许多都可以并发执行；他们可以在 go 协程中启动。一个 worker 先将 pool 锁定，从 pool 获取第一项任务，再解锁和处理任务。加锁保证了同一时间只有一个 go 协程可以进入到 pool 中：一项任务有且只能被赋予一个 worker 。如果不加锁，则工作协程可能会在 <code>task:=pool.Tasks[0]</code> 发生切换，导致 <code>pool.Tasks=pool.Tasks[1:]</code> 结果异常：一些 worker 获取不到任务，而一些任务可能被多个 worker 得到。加锁实现同步的方式在工作协程比较少时可以工作得很好，但是当工作协程数量很大，任务量也很多时，处理效率将会因为频繁的加锁&#x2F;解锁开销而降低。当工作协程数增加到一个阈值时，程序效率会急剧下降，这就成为了瓶颈。</p><p>​新模式：使用通道</p><p>​使用通道进行同步：使用一个通道接受需要处理的任务，一个通道接受处理完成的任务（及其结果）。worker 在协程中启动，其数量 N 应该根据任务数量进行调整。</p><p>​主线程扮演着 Master 节点角色，可能写成如下形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    pending, done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Task), <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Task)<br>    <span class="hljs-keyword">go</span> sendWork(pending)       <span class="hljs-comment">// put tasks with work on the channel</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; N; i++ &#123;   <span class="hljs-comment">// start N goroutines to do work</span><br>        <span class="hljs-keyword">go</span> Worker(pending, done)<br>    &#125;<br>    consumeWork(done)          <span class="hljs-comment">// continue with the processed tasks</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​worker 的逻辑比较简单：从 pending 通道拿任务，处理后将其放到done通道中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(in, out <span class="hljs-keyword">chan</span> *Task)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        t := &lt;-in<br>        process(t)<br>        out &lt;- t<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​这里并不使用锁：从通道得到新任务的过程没有任何竞争。随着任务数量增加，worker 数量也应该相应增加，同时性能并不会像第一种方式那样下降明显。在 pending 通道中存在一份任务的拷贝，第一个 worker 从 pending 通道中获得第一个任务并进行处理，这里并不存在竞争（对一个通道读数据和写数据的整个过程是原子性的：参见 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.2.md">14.2.2</a>）。某一个任务会在哪一个 worker 中被执行是不可知的，反过来也是。worker 数量的增多也会增加通信的开销，这会对性能有轻微的影响。</p><p>​从这个简单的例子中可能很难看出第二种模式的优势，但含有复杂锁运用的程序不仅在编写上显得困难，也不容易编写正确，使用第二种模式的话，就无需考虑这么复杂的东西了。</p><p>​因此，第二种模式对比第一种模式而言，不仅性能是一个主要优势，而且还有个更大的优势：代码显得更清晰、更优雅。一个更符合 go 语言习惯的 worker 写法：</p><p>​<strong>IDIOM: Use an in- and out-channel instead of locking</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Worker</span><span class="hljs-params">(in, out <span class="hljs-keyword">chan</span> *Task)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        t := &lt;-in<br>        process(t)<br>        out &lt;- t<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​对于任何可以建模为 Master-Worker 范例的问题，一个类似于 worker 使用通道进行通信和交互、Master 进行整体协调的方案都能完美解决。如果系统部署在多台机器上，各个机器上执行 Worker 协程，Master 和 Worker 之间使用 netchan 或者 RPC 进行通信（参见 15 章）。</p><p>​怎么选择是该使用锁还是通道？</p><p>​通道是一个较新的概念，本节我们着重强调了在 go 协程里通道的使用，但这并不意味着经典的锁方法就不能使用。go 语言让你可以根据实际问题进行选择：创建一个优雅、简单、可读性强、在大多数场景性能表现都能很好的方案。如果你的问题适合使用锁，也不要忌讳使用它。go语言注重实用，什么方式最能解决你的问题就用什么方式，而不是强迫你使用一种编码风格。下面列出一个普遍的经验法则：</p><p>​1)使用锁的情景：</p><p>​2)访问共享数据结构中的缓存信息</p><p>​3)保存应用程序上下文和状态信息数据</p><p>​4)使用通道的情景：</p><p>​5)与异步操作的结果进行交互</p><p>​6)分发任务</p><p>​7)传递数据所有权</p><p>​当你发现你的锁使用规则变得很复杂时，可以反省使用通道会不会使问题变得简单些。</p><p>​14.8惰性生成器的实现</p><p>​生成器是指当被调用时返回一个序列中下一个值的函数，例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">generateInteger</span><span class="hljs-params">()</span></span> =&gt; <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-title">generateInteger</span><span class="hljs-params">()</span></span> =&gt; <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-title">generateInteger</span><span class="hljs-params">()</span></span> =&gt; <span class="hljs-number">2</span><br>....<br></code></pre></td></tr></table></figure><p>​生成器每次返回的是序列中下一个值而非整个序列；这种特性也称之为惰性求值：只在你需要时进行求值，同时保留相关变量资源（内存和 CPU）：这是一项在需要时对表达式进行求值的技术。例如，生成一个无限数量的偶数序列：要产生这样一个序列并且在一个一个的使用可能会很困难，而且内存会溢出！但是一个含有通道和 go 协程的函数能轻易实现这个需求。</p><p>​在 14.12 的例子中，我们实现了一个使用 int 型通道来实现的生成器。通道被命名为 <code>yield</code> 和 <code>resume</code> ，这些词经常在协程代码中使用。</p><p>​有一个细微的区别是从通道读取的值可能会是稍早前产生的，并不是在程序被调用时生成的。如果确实需要这样的行为，就得实现一个请求响应机制。当生成器生成数据的过程是计算密集型且各个结果的顺序并不重要时，那么就可以将生成器放入到 go 协程实现并行化。但是得小心，使用大量的 go 协程的开销可能会超过带来的性能增益。</p><p>​这些原则可以概括为：通过巧妙地使用空接口、闭包和高阶函数，我们能实现一个通用的惰性生产器的工厂函数 <code>BuildLazyEvaluator</code>（这个应该放在一个工具包中实现）。工厂函数需要一个函数和一个初始状态作为输入参数，返回一个无参、返回值是生成序列的函数。传入的函数需要计算出下一个返回值以及下一个状态参数。在工厂函数中，创建一个通道和无限循环的 go 协程。返回值被放到了该通道中，返回函数稍后被调用时从该通道中取得该返回值。每当取得一个值时，下一个值即被计算。在下面的例子中，定义了一个 <code>evenFunc</code> 函数，其是一个惰性生成函数：在 main 函数中，我们创建了前 10 个偶数，每个都是通过调用 <code>even()</code> 函数取得下一个值的。为此，我们需要在 <code>BuildLazyIntEvaluator</code> 函数中具体化我们的生成函数，然后我们能够基于此做出定义。</p><p>​14.9实现Futures模式</p><p>​所谓 Futures 就是指：有时候在你使用某一个值之前需要先对其进行计算。这种情况下，你就可以在另一个处理器上进行该值的计算，到使用时，该值就已经计算完毕了。</p><p>​Futures 模式通过闭包和通道可以很容易实现，类似于生成器，不同地方在于 Futures 需要返回一个值。</p><p>​参考条目文献给出了一个很精彩的例子：假设我们有一个矩阵类型，我们需要计算两个矩阵 A 和 B 乘积的逆，首先我们通过函数 <code>Inverse(M)</code> 分别对其进行求逆运算，再将结果相乘。如下函数 <code>InverseProduct()</code> 实现了如上过程：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">func InverseProduct(<span class="hljs-selector-tag">a</span> Matrix, <span class="hljs-selector-tag">b</span> Matrix) &#123;<br>    a_inv := <span class="hljs-built_in">Inverse</span>(a)<br>    b_inv := <span class="hljs-built_in">Inverse</span>(b)<br>    return <span class="hljs-built_in">Product</span>(a_inv, b_inv)<br>&#125;<br></code></pre></td></tr></table></figure><p>​在这个例子中，a 和 b 的求逆矩阵需要先被计算。那么为什么在计算 b 的逆矩阵时，需要等待 a 的逆计算完成呢？显然不必要，这两个求逆运算其实可以并行执行的。换句话说，调用 <code>Product</code> 函数只需要等到 <code>a_inv</code> 和 <code>b_inv</code> 的计算完成。如下代码实现了并行计算方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InverseProduct</span><span class="hljs-params">(a Matrix, b Matrix)</span></span> &#123;<br>    a_inv_future := InverseFuture(a)   <span class="hljs-comment">// start as a goroutine</span><br>    b_inv_future := InverseFuture(b)   <span class="hljs-comment">// start as a goroutine</span><br>    a_inv := &lt;-a_inv_future<br>    b_inv := &lt;-b_inv_future<br>    <span class="hljs-keyword">return</span> Product(a_inv, b_inv)<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>InverseFuture</code> 函数以 <code>goroutine</code> 的形式起了一个闭包，该闭包会将矩阵求逆结果放入到 future 通道中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InverseFuture</span><span class="hljs-params">(a Matrix)</span></span> <span class="hljs-keyword">chan</span> Matrix &#123;<br>    future := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Matrix)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        future &lt;- Inverse(a)<br>    &#125;()<br>    <span class="hljs-keyword">return</span> future<br>&#125;<br></code></pre></td></tr></table></figure><p>​当开发一个计算密集型库时，使用 Futures 模式设计 API 接口是很有意义的。在你的包使用 Futures 模式，且能保持友好的 API 接口。此外，Futures 可以通过一个异步的 API 暴露出来。这样你可以以最小的成本将包中的并行计算移到用户代码中。</p><p>​14.10复用</p><p>​14.10.1典型的客户端&#x2F;服务端(c&#x2F;s)模式</p><p>​客户端-服务器应用正是 goroutines 和 channels 的亮点所在。</p><p>​客户端（Client）可以是运行在任意设备上的任意程序，它会按需发送请求（request）至服务器。服务器（Server）接收到这个请求后开始相应的工作，然后再将响应（response）返回给客户端。典型情况下一般是多个客户端（即多个请求）对应一个（或少量）服务器。例如我们日常使用的浏览器客户端，其功能就是向服务器请求网页。而 Web 服务器则会向浏览器响应网页数据。</p><p>​使用 Go 的服务器通常会在协程中执行向客户端的响应，故而会对每一个客户端请求启动一个协程。一个常用的操作方法是客户端请求自身中包含一个通道，而服务器则向这个通道发送响应。</p><p>​例如下面这个 <code>Request</code> 结构，其中内嵌了一个 <code>replyc</code> 通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> &#123;<br>    a, b      <span class="hljs-type">int</span>    <br>    replyc    <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span> <span class="hljs-comment">// reply channel inside the Request</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​或者更通俗的：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">type</span> <span class="hljs-type">Reply</span> struct<span class="hljs-meta">&#123;...&#125;</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">Request</span> struct&#123;<br>    arg1, arg2, arg3 some_type<br>    replyc chan *<span class="hljs-type">Reply</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​接下来先使用简单的形式,服务器会为每一个请求启动一个协程并在其中执行 <code>run()</code> 函数，此举会将类型为 <code>binOp</code> 的 <code>op</code> 操作返回的 int 值发送到 <code>replyc</code> 通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> binOp <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">run</span><span class="hljs-params">(op binOp, req *Request)</span></span> &#123;<br>    req.replyc &lt;- op(req.a, req.b)<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>server</code> 协程会无限循环以从 <code>chan *Request</code> 接收请求，并且为了避免被长时间操作所堵塞，它将为每一个请求启动一个协程来做具体的工作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">(op binOp, service <span class="hljs-keyword">chan</span> *Request)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        req := &lt;-service; <span class="hljs-comment">// requests arrive here  </span><br>        <span class="hljs-comment">// start goroutine for request:        </span><br>        <span class="hljs-keyword">go</span> run(op, req);  <span class="hljs-comment">// don’t wait for op to complete    </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>server</code> 本身则是以协程的方式在 <code>startServer</code> 函数中启动：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(op binOp)</span></span> <span class="hljs-keyword">chan</span> *Request &#123;<br>    reqChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Request);<br>    <span class="hljs-keyword">go</span> server(op, reqChan);<br>    <span class="hljs-keyword">return</span> reqChan;<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>startServer</code> 则会在 <code>main</code> 协程中被调用。</p><p>​14.10.2卸载（Teardown）：通过信号通道关闭服务器</p><p>​在上一个版本中 <code>server</code> 在 <code>main</code> 函数返回后并没有完全关闭，而被强制结束了。为了改进这一点，我们可以提供一个退出通道给 <code>server</code> ：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startServer</span><span class="hljs-params">(op binOp)</span></span> (service <span class="hljs-keyword">chan</span> *Request, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>) &#123;<br>    service = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Request)<br>    quit = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>    <span class="hljs-keyword">go</span> server(op, service, quit)<br>    <span class="hljs-keyword">return</span> service, quit<br>&#125;<br></code></pre></td></tr></table></figure><p>​<code>server</code> 函数现在则使用 <code>select</code> 在 <code>service</code> 通道和 <code>quit</code> 通道之间做出选择：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">(op binOp, service <span class="hljs-keyword">chan</span> *request, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> req := &lt;-service:<br>                <span class="hljs-keyword">go</span> run(op, req) <br>            <span class="hljs-keyword">case</span> &lt;-quit:<br>                <span class="hljs-keyword">return</span>   <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​当 <code>quit</code> 通道接收到一个 <code>true</code> 值时，<code>server</code> 就会返回并结束。</p><p>​在 <code>main</code> 函数中我们做出如下更改：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">adder, quit := startServer(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> a + b &#125;)<br></code></pre></td></tr></table></figure><p>​在 <code>main</code> 函数的结尾处我们放入这一行：<code>quit &lt;- true</code></p><p>​14.11限制同时处理的请求数</p><p>​使用带缓冲区的通道很容易实现这一点（参见 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.2.md#1425-%E5%90%8C%E6%AD%A5%E9%80%9A%E9%81%93-%E4%BD%BF%E7%94%A8%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93">14.2.5</a>），其缓冲区容量就是同时处理请求的最大数量。程序 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_14/max_tasks.go">max_tasks.go</a> 虽然没有做什么有用的事但是却包含了这个技巧：超过 <code>MAXREQS</code> 的请求将不会被同时处理，因为当信号通道表示缓冲区已满时 <code>handle</code> 函数会阻塞且不再处理其他请求，直到某个请求从 <code>sem</code> 中被移除。<code>sem</code> 就像一个信号量，这一专业术语用于在程序中表示特定条件的标志变量。</p><p>​通过这种方式，应用程序可以通过使用缓冲通道（通道被用作信号量）使协程同步其对该资源的使用，从而充分利用有限的资源（如内存）。</p><p>​14.12链式协程</p><p>​下面的演示程序 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/examples/chapter_14/chaining.go">chaining.go</a> 再次展示了启动巨量的 Go 协程是多么容易。这些协程已全部在 main 函数中的 for 循环里启动。当循环完成之后，一个 0 被写入到最右边的通道里，于是 100,000 个协程开始执行，接着 <code>1000000</code> 这个结果会在 1.5 秒之内被打印出来。</p><p>​程序同时也展示了如何通过 <code>flag.Int</code> 来解析命令行中的参数以指定协程数量，例如：<code>chaining -n=7000</code> 会生成 7000 个协程。</p><p>​14.13在多核心上并行运算</p><p>​假设我们有 <code>NCPU</code> 个 CPU 核心：<code>const NCPU = 4 //对应一个四核处理器</code> 然后我们想把计算量分成 <code>NCPU</code> 个部分，每一个部分都和其他部分并行运行。</p><p>​1)<code>DoAll()</code> 函数创建了一个 <code>sem</code> 通道，每个并行计算都将在对其发送完成信号；在一个 for 循环中 <code>NCPU</code> 个协程被启动了，每个协程会承担 <code>1/NCPU</code> 的工作量。每一个 <code>DoPart()</code> 协程都会向 <code>sem</code> 通道发送完成信号。</p><p>​2)<code>DoAll()</code> 会在 for 循环中等待 <code>NCPU</code> 个协程完成：<code>sem</code> 通道就像一个信号量，这份代码展示了一个经典的信号量模式。（参见 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.2.md#1427-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E5%BC%8F">14.2.7</a>）</p><p>​在以上运行模型中，您还需将 <code>GOMAXPROCS</code> 设置为 <code>NCPU</code>（参见 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/14.1.md#1413-%E4%BD%BF%E7%94%A8-gomaxprocs">14.1.3</a>）。</p><p>​14.14并行化大量数据的计算</p><p>​假设我们需要处理一些数量巨大且互不相关的数据项，它们从一个 <code>in</code> 通道被传递进来，当我们处理完以后又要将它们放入另一个 <code>out</code> 通道，就像一个工厂流水线一样。处理每个数据项也可能包含许多步骤：Preprocess（预处理） &#x2F; StepA（步骤A） &#x2F; StepB（步骤B） &#x2F; … &#x2F; PostProcess（后处理）</p><p>​一个典型的用于解决按顺序执行每个步骤的顺序流水线算法可以写成下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SerialProcessData</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> *Data, out <span class="hljs-keyword">chan</span>&lt;- *Data)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> data := <span class="hljs-keyword">range</span> in &#123;<br>        tmpA := PreprocessData(data)<br>        tmpB := ProcessStepA(tmpA)<br>        tmpC := ProcessStepB(tmpB)<br>        out &lt;- PostProcessData(tmpC)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​一次只执行一个步骤，并且按顺序处理每个项目：在第 1 个项目没有被 <code>PostProcess</code> 并放入 <code>out</code> 通道之前绝不会处理第 2 个项目。</p><p>​如果你仔细想想，你很快就会发现这将会造成巨大的时间浪费。</p><p>​一个更高效的计算方式是让每一个处理步骤作为一个协程独立工作。每一个步骤从上一步的输出通道中获得输入数据。这种方式仅有极少数时间会被浪费，而大部分时间所有的步骤都在一直执行中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParallelProcessData</span> <span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> *Data, out <span class="hljs-keyword">chan</span>&lt;- *Data)</span></span> &#123;<br>    <span class="hljs-comment">// make channels:</span><br>    preOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Data, <span class="hljs-number">100</span>)<br>    stepAOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Data, <span class="hljs-number">100</span>)<br>    stepBOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Data, <span class="hljs-number">100</span>)<br>    stepCOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Data, <span class="hljs-number">100</span>)<br>    <span class="hljs-comment">// start parallel computations:</span><br>    <span class="hljs-keyword">go</span> PreprocessData(in, preOut)<br>    <span class="hljs-keyword">go</span> ProcessStepA(preOut,StepAOut)<br>    <span class="hljs-keyword">go</span> ProcessStepB(StepAOut,StepBOut)<br>    <span class="hljs-keyword">go</span> ProcessStepC(StepBOut,StepCOut)<br>    <span class="hljs-keyword">go</span> PostProcessData(StepCOut,out)<br>&#125;   <br></code></pre></td></tr></table></figure><p>​通道的缓冲区大小可以用来进一步优化整个过程。</p><p>​14.15漏桶算法</p><p>​（译者注：翻译遵照原文，但是对于完全没听过这个算法的人来说比较晦涩，请配合代码片段理解）</p><p>​考虑以下的客户端-服务器结构：客户端协程执行一个无限循环从某个源头（也许是网络）接收数据；数据读取到 <code>Buffer</code> 类型的缓冲区。为了避免分配过多的缓冲区以及释放缓冲区，它保留了一份空闲缓冲区列表，并且使用一个缓冲通道来表示这个列表：<code>var freeList = make(chan *Buffer,100)</code></p><p>​这个可重用的缓冲区队列（freeList）与服务器是共享的。 当接收数据时，客户端尝试从 <code>freeList</code> 获取缓冲区；但如果此时通道为空，则会分配新的缓冲区。一旦消息被加载后，它将被发送到服务器上的 <code>serverChan</code> 通道：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> serverChan = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *Buffer)<br></code></pre></td></tr></table></figure><p>​以下是客户端的算法代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs stylus">func <span class="hljs-built_in">client</span>() &#123;<br>   <span class="hljs-keyword">for</span> &#123;<br>       <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> *Buffer<br>       <span class="hljs-comment">// Grab a buffer if available; allocate if not </span><br>       select &#123;<br>           case <span class="hljs-selector-tag">b</span> = &lt;-freeList:<br>               <span class="hljs-comment">// Got one; nothing more to do</span><br>           default:<br>               <span class="hljs-comment">// None free, so allocate a new one</span><br>               <span class="hljs-selector-tag">b</span> = <span class="hljs-built_in">new</span>(Buffer)<br>       &#125;<br>       <span class="hljs-built_in">loadInto</span>(b)         <span class="hljs-comment">// Read next message from the network</span><br>       serverChan &lt;- <span class="hljs-selector-tag">b</span>     <span class="hljs-comment">// Send to server</span><br>       <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​服务器的循环则接收每一条来自客户端的消息并处理它，之后尝试将缓冲返回给共享的空闲缓冲区：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">server</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        b := &lt;-serverChan       <span class="hljs-comment">// Wait for work.</span><br>        process(b)<br>        <span class="hljs-comment">// Reuse buffer if there&#x27;s room.</span><br>        <span class="hljs-keyword">select</span> &#123;<br>            <span class="hljs-keyword">case</span> freeList &lt;- b:<br>                <span class="hljs-comment">// Reuse buffer if free slot on freeList; nothing more to do</span><br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-comment">// Free list full, just carry on: the buffer is &#x27;dropped&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​但是这种方法在 <code>freeList</code> 通道已满的时候是行不通的，因为无法放入空闲 <code>freeList</code> 通道的缓冲区会被“丢到地上”由垃圾收集器回收（故名：漏桶算法）</p><p>​14.16对Go协程进行基准测试</p><p>​在 <a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/13.7.md">13.7 节</a> 我们提到了在 Go 语言中对你的函数进行基准测试。在此我们将其应用到一个用协程向通道写入整数再读出的实例中。这个函数将通过 <code>testing.Benchmark</code> 调用 <code>N</code> 次（例如：<code>N = 1,000,000</code>），<code>BenchMarkResult</code> 有一个 <code>String()</code> 方法来输出其结果。<code>N</code> 的值将由 <code>gotest</code> 来判断并取得一个足够大的数字，以获得合理的基准测试结果。当然同样的基准测试方法也适用于普通函数。</p><p>​如果你想排除指定部分的代码或者更具体的指定要测试的部分，可以使用 <code>testing.B.startTimer()</code> 和 <code>testing.B.stopTimer()</code> 来开始或结束计时器。基准测试只有在所有的测试通过后才能运行！</p><p>​14.17使用通道并发访问对象</p><p>​为了保护对象被并发访问修改，我们可以使用协程在后台顺序执行匿名函数来替代使用同步互斥锁。在下面的程序中我们有一个类型 <code>Person</code> 中包含一个字段 <code>chF</code> ，这是一个用于存放匿名函数的通道。</p><p>​这个结构在构造函数 <code>NewPerson()</code> 中初始化的同时会启动一个后台协程 <code>backend()</code>。<code>backend()</code> 方法会在一个无限循环中执行 <code>chF</code> 中放置的所有函数，有效地将它们序列化从而提供了安全的并发访问。更改和读取 <code>salary</code> 的方法会通过将一个匿名函数写入 <code>chF</code> 通道中，然后让<code>backend()</code>按顺序执行以达到其目的。需注意的是 <code>Salary</code> 方法创建的闭包函数是如何将 <code>fChan</code> 通道包含在其中的。</p><p>​当然，这是一个简化的例子，它不应该被用在这种案例下。但是它却向我们展示了在更复杂的场景中该如何解决这种问题。</p><h5 id="15-0-网络、模版与网页应用"><a href="#15-0-网络、模版与网页应用" class="headerlink" title="15.0 网络、模版与网页应用"></a>15.0 网络、模版与网页应用</h5><p>​Go 在编写 web 应用方面非常得力。因为目前它还没有GUI（Graphic User Interface 即图形化用户界面）的框架，通过文本或者模板展现的 html 页面是目前 Go 编写界面应用程序的唯一方式。（译者注：实际上在翻译的时候，已经有了一些不太成熟的 GUI 库，例如：go ui ）</p><p>​15.1tcp服务器</p><p>​这部分我们将使用 TCP 协议和在 14 章讲到的协程范式编写一个简单的客户端-服务器应用，一个（web）服务器应用需要响应众多客户端的并发请求：Go 会为每一个客户端产生一个协程用来处理请求。我们需要使用 net 包中网络通信的功能。它包含了处理 TCP&#x2F;IP 以及 UDP 协议、域名解析等方法。</p><p>​服务器端代码是一个单独的文件：</p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis学习与使用</title>
    <link href="/2023/04/11/redis%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/11/redis%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="redis学习与使用"><a href="#redis学习与使用" class="headerlink" title="redis学习与使用"></a>redis学习与使用</h2><h3 id="清空redis数据命令"><a href="#清空redis数据命令" class="headerlink" title="清空redis数据命令"></a>清空redis数据命令</h3><p>所有数据库的所有 key</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs redis">flushall<br></code></pre></td></tr></table></figure><p>查看数据库key的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs redis">DBSIZE<br></code></pre></td></tr></table></figure><p>切换到 1 号数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs redis">SELECT 1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go进阶之路</title>
    <link href="/2023/03/31/Go%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/"/>
    <url>/2023/03/31/Go%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="Go进阶之路"><a href="#Go进阶之路" class="headerlink" title="Go进阶之路"></a>Go进阶之路</h2><p><a href="https://zhuanlan.zhihu.com/p/421041738">大厂对Golang的要求，请问你所在公司对Golang的要求有哪些？</a></p><p><a href="https://zhuanlan.zhihu.com/p/584071700">开发时长一年半golang工程师应该具备什么样的技术能力？</a></p>]]></content>
    
    
    <categories>
      
      <category>Go进阶之路</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>apt-get工具使用</title>
    <link href="/2023/03/15/apt-get%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/03/15/apt-get%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="apt-get工具使用"><a href="#apt-get工具使用" class="headerlink" title="apt-get工具使用"></a>apt-get工具使用</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>更新软件源信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">apt-get update <br></code></pre></td></tr></table></figure><p>安装、卸载、更新软件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装一个软件包</span><br>apt-get install package<br><span class="hljs-comment"># 安装多个软件包之间用空格隔开</span><br>apt-get install package1 package2<br><span class="hljs-comment"># install -y</span><br>安装过程中需要输入时自动使用`<span class="hljs-built_in">yes</span>`<br><span class="hljs-comment"># install -d</span><br>全部包下载完后再执行一次命令后安装（不含`-d`）<br><br><span class="hljs-comment"># 卸载软件包（仅删除软件包本身）</span><br>apt-get remove package<br><span class="hljs-comment"># 卸载软件包以及相应的配置文件</span><br>apt-get purge package<br><span class="hljs-comment"># 自动删除多余、冲突的包</span><br>apt-get autoremove<br><br><span class="hljs-comment"># 更新所有软件包</span><br>apt-get upgrade package<br><span class="hljs-comment"># 解决更新过程中出现的依赖的问题</span><br>apt-get dist-upgrade package<br></code></pre></td></tr></table></figure><p>安装多个软件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 多个软件之间用空格隔开</span><br>apt-get install package1 package2<br></code></pre></td></tr></table></figure><p>更换国内软件源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sh">1.vim /etc/apt/sources.list<br>2.将文件中的内容替换为如下阿里云的：<br>```<br>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse<br>deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse<br>```<br>3.重新更新软件源：apt-get update<br></code></pre></td></tr></table></figure><p>查看已安装包的信息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 显示已安装的软件包</span><br>dpkg -l<br><span class="hljs-comment"># 显示某个具体的软件包的信息</span><br>dpkg -l | grep package<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>apt-get</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>github多账户配置</title>
    <link href="/2023/03/09/github%E5%A4%9A%E8%B4%A6%E6%88%B7%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/03/09/github%E5%A4%9A%E8%B4%A6%E6%88%B7%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="github多账户配置"><a href="#github多账户配置" class="headerlink" title="github多账户配置"></a>github多账户配置</h2><h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h3><p>不知是否有人像我一样，搞了两个GitHub账号，一个用来正常的和别人合作项目，另一个用来自己写一些代码，希望能做到两个本地账户和远程账号都完全隔离，没有联系，也不会被混淆使用。</p><p>但是这样就会有一个问题，设置本地用户<code>user.email</code>时候，如果你两个 GitHbu 账号仓库使用同一个本地用户，GitHub会将本地的用户自动与相应的 GitHub 账号关联起来，这样在 commit 记录里面就能看到是谁提交的了，这是我不想看到的结果。</p><p>当初的我以为只要把同一个 SSH 公钥分别添加到两个 GitHub 账户，再在不同的仓库设置不同的<code>user.name</code> 和 <code>user email</code> 就OK了.后来发现我太天真了，并不行，每个公钥只能用一次。然后我就考虑生成两个密钥，分别添加到不同的账户，但是电脑在连接远程仓库时，只能默认选择其中固定的一个来连接，并不会根据我不同仓库的设置选择不同的密钥，结果就是还是只能免密连接一个 GitHub 账户的仓库。</p><p><strong>你所使用的 SSH 密钥决定了你是否有权限访问某一个 GitHub 账号下面的仓库，而你本地仓库设置的 <code>use email</code> 决定了在 GitHub 的 commit 记录中的用户，而一般在没有进行以下配置的情况下，你的电脑只会默认使用一个 SHH 密钥进行连接，这就导致了你只能访问一个 GitHub 账号。</strong></p><p>然后就到处找教程，但是不知道是否是因为时间太久远了，都是错误的，而且错误都是一样的，最后终于七拼八凑整成功了。</p><p>下面将详细介绍方法。</p><h3 id="1-生成密钥"><a href="#1-生成密钥" class="headerlink" title="1. 生成密钥"></a>1. 生成密钥</h3><p>首先是先生成两个SSH密钥，对应你的两个身份(假设为 public 和 private)。</p><p>假设你当初已经用<code>ssh-keygen -t rsa -C “youremail@gmail.com”</code>生成了一对秘钥<code>id_rsa</code>和<code>id_rsa.pub</code> ， 保存在了<code>~/.ssh</code>文件夹内。</p><p>然后，你需要再用另一个邮箱生成一对 private 的秘钥<code>ssh-keygen -t rsa -C “private_email@gmail.com”</code>。这时候要注意重命名，否则会覆盖上面的密钥文件。假设我们生成了一对新的秘钥<code>private</code> 和<code>private.pub</code>。</p><p>然后分别将这两对密钥加入到对应的 GitHub 账户中，这个步骤就略过了。</p><h3 id="2-编辑配置文件"><a href="#2-编辑配置文件" class="headerlink" title="2. 编辑配置文件"></a>2. 编辑配置文件</h3><p>编辑<code>~/.ssh/config</code>文件。如果该文件不存在的话，直接创建一个就好。里面的内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text"># 公共<br>Host github_public<br>Hostname ssh.github.com<br>IdentityFile ~/.ssh/id_rsa<br>port 22<br><br>#个人<br>Host github_private<br>Hostname ssh.github.com<br>IdentityFile ~/.ssh/private<br>port 22<br></code></pre></td></tr></table></figure><blockquote><p>网上大部分教程的配置文件中<code>Hostname</code>都是<code>github.com</code>，配置成那样是不能正常SSH访问的。我也不知道大家为什么都那样写，难道之前的就是这样？</p></blockquote><p>修改完之后，在<code>git bash</code>运行以下命令（<code>@</code>后面的主机名为上面配置文件中填写的<code>Host</code>选项），检查是否正常。</p><p><strong>（先注意一下</strong>：这里一定是先把两个公钥添加到对应的 GitHub 账户，再进行下面的 ssh 连接测试，否则肯定是连接不上，会显示 permission denied。）</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs console">ssh -T git@github_public<br>ssh -T git@github_private<br></code></pre></td></tr></table></figure><p>如果都能正常返回如下信息，就说明配置正常。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.<br></code></pre></td></tr></table></figure><p>同样的方式你就可以配置更多的以SSH登录的不同git用户。</p><h3 id="3-配置仓库设置"><a href="#3-配置仓库设置" class="headerlink" title="3. 配置仓库设置"></a>3. 配置仓库设置</h3><p>首先要删除GIT配置的全局用户名和邮件地址，接着在每个项目仓库中按照需求设置不同的<code>user.name</code>和 <code>user.email</code>：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text"># 删除全局设置<br>git config --global --unset user.name<br>git config --global --unset user.email<br><br># 添加本地设置<br># 设置为私有仓库的GitHub账号邮箱和公有账号的GitHub邮箱。<br>git config --local user.name xxxx<br>git config --local user.email xxx<br></code></pre></td></tr></table></figure><p>之后在添加远程仓库的时候，把<code>github.com</code> 修改成<code>github_public</code> 或者<code>github_private</code>就好了（即上述文件中的HOST选项），用上面两个 Host 名称来代替原来的<code>github.com</code> ，（<strong>这一步很重要</strong>）如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git remote add origin git@github_public:xxx/example.git # public user<br>git remote add origin git@github_private:xxx/example.git # priavate user<br></code></pre></td></tr></table></figure><p>其实，上面的配置文件的意思就是，按照你设置远程仓库时使用不同的 Host 名称，查找<code>~/.ssh/config</code>文件，使用不同的 SSH 文件连接到 GitHub。这样你就将是以不同的身份访问 GitHub 仓库。</p><p><a href="https://zhuanlan.zhihu.com/p/62071906">参考文章</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac常用工具</title>
    <link href="/2023/02/23/mac%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/02/23/mac%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="mac开发环境常用工具"><a href="#mac开发环境常用工具" class="headerlink" title="mac开发环境常用工具"></a>mac开发环境常用工具</h2><h3 id="iTerm2"><a href="#iTerm2" class="headerlink" title="iTerm2"></a>iTerm2</h3><p>下载安装<a href="https://juejin.cn/post/6844904144277340168">iTerm2</a></p><h3 id="FinalShell-SSH工具"><a href="#FinalShell-SSH工具" class="headerlink" title="FinalShell SSH工具"></a>FinalShell SSH工具</h3><p>下载安装<a href="https://www.hostbuf.com/t/988.html">Hostbuf</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm2命令</title>
    <link href="/2023/02/22/iterm2%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/02/22/iterm2%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="iterm2命令"><a href="#iterm2命令" class="headerlink" title="iterm2命令"></a>iterm2命令</h2><h3 id="mac配置iterm2"><a href="#mac配置iterm2" class="headerlink" title="mac配置iterm2"></a><a href="https://juejin.cn/post/6844904144277340168">mac配置iterm2</a></h3><p><a href="https://zhuanlan.zhihu.com/p/435518571">参考文章</a></p><p>解决<code>～</code>前后的<code>问号</code>问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone git@github.com:powerline/fonts.git<br>cd ./fonts<br>./install.sh<br>然后在iTerm2中更换字体为 Meslo LG M Regular for Powerline<br>重启iTerm2<br></code></pre></td></tr></table></figure><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">command</span> + enter 进入与返回全屏模式<br><span class="hljs-built_in">command</span> + t 新建标签<br><span class="hljs-built_in">command</span> + w 关闭标签<br><span class="hljs-built_in">command</span> + 数字 <span class="hljs-built_in">command</span> + 左右方向键    切换标签<br><span class="hljs-built_in">command</span> + enter 切换全屏<br><span class="hljs-built_in">command</span> + f 查找<br><span class="hljs-built_in">command</span> + d 水平分屏<br><span class="hljs-built_in">command</span> + <span class="hljs-built_in">shift</span> + d 垂直分屏<br><span class="hljs-built_in">command</span> + option + 方向键 <span class="hljs-built_in">command</span> + [ 或 <span class="hljs-built_in">command</span> + ]    切换屏幕<br><span class="hljs-built_in">command</span> + ; 查看历史命令<br><span class="hljs-built_in">command</span> + <span class="hljs-built_in">shift</span> + h 查看剪贴板历史<br>ctrl + u    清除当前行<br>ctrl + l    清屏<br>ctrl + a    到行首<br>ctrl + e    到行尾<br>ctrl + f/b  前进后退<br>ctrl + p    上一条命令<br>ctrl + r    搜索命令历史<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>iterm2</tag>
      
      <tag>bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brew使用命令</title>
    <link href="/2023/02/22/brew%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/02/22/brew%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="brew使用命令"><a href="#brew使用命令" class="headerlink" title="brew使用命令"></a>brew使用命令</h2><ul><li>查看brew的帮助</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew –<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><ul><li>安装软件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew install git<br></code></pre></td></tr></table></figure><ul><li>卸载软件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew uninstall git<br></code></pre></td></tr></table></figure><ul><li>搜索软件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew search git<br></code></pre></td></tr></table></figure><ul><li>显示已经安装软件列表</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew list<br></code></pre></td></tr></table></figure><ul><li>更新软件，把所有的Formula目录更新，并且会对本机已经安装并有更新的软件用*标明</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew update<br></code></pre></td></tr></table></figure><ul><li>更新某具体软件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew upgrade git<br></code></pre></td></tr></table></figure><ul><li>显示软件内容信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew info git<br></code></pre></td></tr></table></figure><ul><li>用浏览器打开</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew home<br></code></pre></td></tr></table></figure><ul><li>显示包依赖</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew deps <br></code></pre></td></tr></table></figure><ul><li>显示包的依赖树</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew deps --installed --tree<br></code></pre></td></tr></table></figure><ul><li>启动web服务器，可以通过浏览器访问<a href="http://localhost:4567/">http://localhost:4567/</a> 来同网页来管理包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew server<br></code></pre></td></tr></table></figure><ul><li>删除程序，和upgrade一样，单个软件删除和所有程序老版删除</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew cleanup git <br>brew cleanup<br></code></pre></td></tr></table></figure><ul><li>查看那些已安装的程序需要更新</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">brew outdated<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>brew</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql、gorm笔记</title>
    <link href="/2023/02/14/mysql%E3%80%81gorm%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/02/14/mysql%E3%80%81gorm%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="mysql、gorm笔记"><a href="#mysql、gorm笔记" class="headerlink" title="mysql、gorm笔记"></a>mysql、gorm笔记</h2><h3 id="mysql基本操作"><a href="#mysql基本操作" class="headerlink" title="mysql基本操作"></a>mysql基本操作</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table user (<br>id int not null auto_increment comment &#x27;主键&#x27;,<br>name varchar(10) not null default &#x27;&#x27; comment &#x27;姓名&#x27;,<br>password varchar(50) not null default &#x27;123&#x27; comment &#x27;密码，默认值为123&#x27;,<br>gender char(3) default &#x27;0&#x27; check (gender in(&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;)) comment &#x27;性别，0:未知 1:男 2:女&#x27;,<br>phone varchar(11) default &#x27;&#x27; comment &#x27;11位手机号码&#x27;,<br>email varchar(128) default &#x27;&#x27; comment &#x27;邮箱&#x27;,<br>identity varchar(128) default &#x27;&#x27; comment &#x27;身份证号&#x27;,<br>client_ip varchar(128) default &#x27;&#x27; comment &#x27;连接ip地址&#x27;,<br>client_post varchar(128) default &#x27;&#x27; comment &#x27;连接端口号&#x27;,<br>login_time datetime(3) default now(3) comment &#x27;登陆时间&#x27;,<br>logout_time datetime(3) default now(3) comment &#x27;下线时间&#x27;,<br>is_login tinyint(1) default 0 comment &#x27;在线状态，0:离线 1:在线&#x27;,<br>heartbeat_time varchar(128) default &#x27;&#x27; comment &#x27;心跳速率&#x27;,<br>device_info varchar(128) default &#x27;&#x27; comment &#x27;设备信息&#x27;,<br>created_at datetime(3) default null comment &#x27;创建时间&#x27;,<br>updated_at datetime(3) default null comment &#x27;更新时间&#x27;,<br>deleted_at datetime(3) default null comment &#x27;删除时间&#x27;,<br>primary key (id)<br>)engine=InnoDB default charset=utf8;<br></code></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table table_name;<br></code></pre></td></tr></table></figure><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database db_name;<br></code></pre></td></tr></table></figure><h4 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h4><h3 id="修改表信息"><a href="#修改表信息" class="headerlink" title="修改表信息"></a>修改表信息</h3><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table table_oldname rename to table_newname;<br>eg: alter table user rename to user_info;<br></code></pre></td></tr></table></figure><h4 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table table_name change field_oldname field_newname type;<br>eg: alter table user change is_login is_logout tinyint(1);<br></code></pre></td></tr></table></figure><h4 id="修改字段属性"><a href="#修改字段属性" class="headerlink" title="修改字段属性"></a>修改字段属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table table_name modify column fieldname type not null default &#x27;&#x27; comment &#x27;字段信息&#x27;;<br>eg: alter table user modify column name varchar(128) not null default &#x27;&#x27; comment &#x27;姓名&#x27;;<br></code></pre></td></tr></table></figure><h4 id="显示表全部信息"><a href="#显示表全部信息" class="headerlink" title="显示表全部信息"></a>显示表全部信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show create table table_name;<br></code></pre></td></tr></table></figure><h4 id="设置性别约束"><a href="#设置性别约束" class="headerlink" title="设置性别约束"></a>设置性别约束</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table user(<br>...<br>gender char(3) default &#x27;0&#x27; check (gender in(&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;)) comment &#x27;性别，0:未知 1:男 2:女&#x27;,<br>...<br>);<br></code></pre></td></tr></table></figure><h3 id="gorm"><a href="#gorm" class="headerlink" title="gorm"></a>gorm</h3><h4 id="gorm映射mysql数据表"><a href="#gorm映射mysql数据表" class="headerlink" title="gorm映射mysql数据表"></a>gorm映射mysql数据表</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TableName <span class="hljs-keyword">struct</span>&#123;<br>    ID            <span class="hljs-type">int</span>       <span class="hljs-string">`json:&quot;id&quot; gorm:&quot;column:id;primaryKey;autoIncrement;comment:自增主键id&quot;`</span><br>    Name          <span class="hljs-type">string</span>    <span class="hljs-string">`json:&quot;name&quot; gorm:&quot;column:name;comment:用户姓名&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>go在使用结构体映射mysql数据表时：column来对应mysql表中中的字段名，primaryKey对应主键，autoIncrement对应自增属性，comment对应字段注释，index对应索引。</p><p>还有size、not null、default等属性也可以一一对应</p><p>eg: <code>gorm:&quot;column:id;size:4;primaryKey;autoIncrement;not null;default:0;comment:自增主键id;index:index_name&quot;</code></p></blockquote><div class="note note-info">            <p>使用gorm时，进行修改增改操作时，尽量重新声明结构体来进行操作，和查询使用结构体分离开来。</p>          </div><h4 id="gorm-1"><a href="#gorm-1" class="headerlink" title="gorm"></a>gorm</h4><h6 id="FirstOrCreate与Assign"><a href="#FirstOrCreate与Assign" class="headerlink" title="FirstOrCreate与Assign"></a><code>FirstOrCreate</code>与<code>Assign</code></h6><p>空表插入数据、非空表更新数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">// 未找到 user，根据条件和 Assign 属性创建记录<br>db.Where(User&#123;Name: &quot;non_existing&quot;&#125;).Assign(User&#123;Age: 20&#125;).FirstOrCreate(&amp;user)<br>// SELECT * FROM users WHERE name = &#x27;non_existing&#x27; ORDER BY id LIMIT 1;<br>// INSERT INTO &quot;users&quot; (name, age) VALUES (&quot;non_existing&quot;, 20);<br>// user -&gt; User&#123;ID: 112, Name: &quot;non_existing&quot;, Age: 20&#125;<br><br>// 找到了 `name` = `jinzhu` 的 user，依然会根据 Assign 更新记录<br>db.Where(User&#123;Name: &quot;jinzhu&quot;&#125;).Assign(User&#123;Age: 20&#125;).FirstOrCreate(&amp;user)<br>// SELECT * FROM users WHERE name = &#x27;jinzhu&#x27; ORDER BY id LIMIT 1;<br>// UPDATE users SET age=20 WHERE id = 111;<br>// user -&gt; User&#123;ID: 111, Name: &quot;jinzhu&quot;, Age: 20&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>gorm</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建go-gin框架模版</title>
    <link href="/2023/01/31/%E6%90%AD%E5%BB%BAgo-gin%E6%A1%86%E6%9E%B6%E6%A8%A1%E7%89%88/"/>
    <url>/2023/01/31/%E6%90%AD%E5%BB%BAgo-gin%E6%A1%86%E6%9E%B6%E6%A8%A1%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="搭建go-gin框架模版"><a href="#搭建go-gin框架模版" class="headerlink" title="搭建go-gin框架模版"></a>搭建go-gin框架模版</h2><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><h4 id="新建一个gin-model文件夹"><a href="#新建一个gin-model文件夹" class="headerlink" title="新建一个gin-model文件夹"></a>新建一个gin-model文件夹</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir gin-model<br></code></pre></td></tr></table></figure><h4 id="初始化go-mod"><a href="#初始化go-mod" class="headerlink" title="初始化go mod"></a>初始化go mod</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> mod init github.com/xxx/gin-model<br></code></pre></td></tr></table></figure><h4 id="新建一个main-go程序"><a href="#新建一个main-go程序" class="headerlink" title="新建一个main.go程序"></a>新建一个main.go程序</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd gin-model<br>touch main.go<br></code></pre></td></tr></table></figure><p><strong>在编辑器中打开gin-model文件夹</strong></p><h4 id="安装Gin框架的库"><a href="#安装Gin框架的库" class="headerlink" title="安装Gin框架的库"></a>安装Gin框架的库</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/gin-gonic/gin<br></code></pre></td></tr></table></figure><p><strong>main.go</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;github.com/gookit/slog&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := gin.Default()<br>r.GET(<span class="hljs-string">&quot;/ping&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello World!&quot;</span>,<br>&#125;)<br>&#125;)<br>r.Run()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>启动项目&amp;&amp;测试</strong></p><p>打开<code>http://localhost:8080/ping</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Hello World!&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="配置初始化-amp-全局变量"><a href="#配置初始化-amp-全局变量" class="headerlink" title="配置初始化&amp;全局变量"></a>配置初始化&amp;全局变量</h3><p><strong>使用 <a href="https://link.juejin.cn/?target=https://github.com/spf13/viper">viper</a> 作为配置管理方案，支持 JSON、TOML、YAML、HCL、envfile、Java properties 等多种格式的配置文件，并且能够监听配置文件的修改，进行热重载。</strong></p><h4 id="安装viper库"><a href="#安装viper库" class="headerlink" title="安装viper库"></a>安装viper库</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/spf13/viper<br></code></pre></td></tr></table></figure><h4 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h4><p>在<code>gin-model</code>文件夹下新建<code>config</code>文件夹，在<code>config</code>文件夹下新建<code>config.yaml</code>文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">config:</span> <span class="hljs-comment"># 项目基本配置</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-comment"># local开发环境 test测试环境</span><br>    <span class="hljs-attr">env:</span> <span class="hljs-string">local</span> <br>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment"># 服务监听端口号</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">gin-model</span> <span class="hljs-comment"># 项目名称</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost</span> <span class="hljs-comment"># 项目域名</span><br>  <span class="hljs-attr">database:</span><br>    <span class="hljs-comment"># 数据库类型 mysql，sqlite3， postgres</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-comment"># 数据库连接字符串 mysql</span><br>    <span class="hljs-attr">source:</span> <span class="hljs-string">root:12345678@tcp(127.0.0.1:3306)/test?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;timeout=1000ms</span><br></code></pre></td></tr></table></figure><h4 id="编写配置结构体"><a href="#编写配置结构体" class="headerlink" title="编写配置结构体"></a>编写配置结构体</h4><p>在<code>gin-model</code>文件夹下新建<code>common</code>文件夹，在<code>common</code>下新建<code>config</code>文件夹，用于存放所有配置对应的结构体。</p><p>在<code>/common/config</code>路径下新建<code>config.go</code>文件，定义<code>Config</code>结构体，其<code>Settings</code>属性对应<code>config.yaml</code>中的<code>settings</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> config<br><br><span class="hljs-comment">// config.yaml文件中的基本配置</span><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>Settings Settings <span class="hljs-string">`mapstructure:&quot;settings&quot; json:&quot;settings&quot; yaml:&quot;settings&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义<code>Settings</code>结构体，其<code>Application</code>属性对应<code>config.yaml</code>中的<code>application</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> config<br><br><span class="hljs-comment">// 对应config.yaml文件中的settings</span><br><span class="hljs-keyword">type</span> Settings <span class="hljs-keyword">struct</span> &#123;<br>Application Application <span class="hljs-string">`mapstructure:&quot;application&quot; json:&quot;application&quot; yaml:&quot;application&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>定义 <code>Application</code> 结构体，其所有属性分别对应 <code>config.yaml</code> 中 <code>application</code> 下的所有配置</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> config<br><br><span class="hljs-comment">// 对应config.yaml文件中的application</span><br><span class="hljs-keyword">type</span> Application <span class="hljs-keyword">struct</span> &#123;<br>Env  <span class="hljs-type">string</span> <span class="hljs-string">`mapstructure:&quot;env&quot; json:&quot;env&quot; yaml:&quot;env&quot;`</span><br>Port <span class="hljs-type">string</span> <span class="hljs-string">`mapstructure:&quot;port&quot; json:&quot;port&quot; yaml:&quot;port&quot;`</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`mapstructure:&quot;name&quot; json:&quot;name&quot; yaml:&quot;name&quot;`</span><br>Url  <span class="hljs-type">string</span> <span class="hljs-string">`mapstructure:&quot;url&quot; json:&quot;url&quot; yaml:&quot;url&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-danger">            <p>配置结构体中 <code>mapstructure</code> 标签需对应 <code>config.yaml</code> 中的配置名称， <code>viper</code> 会根据标签 value 值把 <code>config.yaml</code> 的数据赋予给结构体</p>          </div><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>在<code>/common</code>路径下新建<code>/global/app.go</code>，定义<code>Application</code>结构体，用来存放一些项目启动时的变量，便于调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> global<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/iyaoo/go/gin-model/common/config&quot;</span><br><span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Application <span class="hljs-keyword">struct</span> &#123;<br>ConfigViper *viper.Viper<br>Config      config.Config<br>&#125;<br><br><span class="hljs-keyword">var</span> App = <span class="hljs-built_in">new</span>(Application)<br></code></pre></td></tr></table></figure><h4 id="使用-viper-载入配置"><a href="#使用-viper-载入配置" class="headerlink" title="使用 viper 载入配置"></a>使用 viper 载入配置</h4><p>在<code>common</code>路径下新建<code>bootstrap/config.go</code> 文件，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> bootstrap<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><br><span class="hljs-string">&quot;github.com/fsnotify/fsnotify&quot;</span><br><span class="hljs-string">&quot;github.com/iyaoo/go/gin-model/common/global&quot;</span><br><span class="hljs-string">&quot;github.com/spf13/viper&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitConfig</span><span class="hljs-params">()</span></span> *viper.Viper &#123;<br><span class="hljs-comment">// 设置配置路径</span><br>configFile := <span class="hljs-string">&quot;config/config.yaml&quot;</span><br><span class="hljs-comment">// 生产环境可以通过设置环境变量来改变配置文件路径</span><br><span class="hljs-keyword">if</span> configEnv := os.Getenv(<span class="hljs-string">&quot;VIPER_CONFIG&quot;</span>); configEnv != <span class="hljs-string">&quot;&quot;</span> &#123;<br>configFile = configEnv<br>&#125;<br><br><span class="hljs-comment">//初始化 viper</span><br>v := viper.New()<br>v.SetConfigFile(configFile)<br>v.SetConfigType(<span class="hljs-string">&quot;yaml&quot;</span>)<br><span class="hljs-keyword">if</span> err := v.ReadInConfig(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;read config failed: %s&quot;</span>, err))<br>&#125;<br><br><span class="hljs-comment">//监听配置文件</span><br>v.WatchConfig()<br>v.OnConfigChange(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(in fsnotify.Event)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;config file changed:&quot;</span>, in.Name)<br><span class="hljs-comment">//重载配置</span><br><span class="hljs-keyword">if</span> err := v.Unmarshal(&amp;global.App.Config); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>&#125;)<br><span class="hljs-comment">// 将配置赋值给全局变量</span><br><span class="hljs-keyword">if</span> err := v.Unmarshal(&amp;global.App.Config); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br><span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h4><p>修改<code>main.go</code>文件</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;github.com/iyaoo/go/gin-model/common/bootstrap&quot;</span><br><span class="hljs-string">&quot;github.com/iyaoo/go/gin-model/common/global&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">UseGin</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//初始化配置</span><br>bootstrap.InitConfig()<br><br>r := gin.Default()<br><br><span class="hljs-comment">//测试路由</span><br>r.GET(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>c.JSON(<span class="hljs-number">200</span>, gin.H&#123;<br><span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello World!&quot;</span>,<br>&#125;)<br>&#125;)<br><br><span class="hljs-comment">//启动服务器</span><br>r.Run(<span class="hljs-string">&quot;:&quot;</span> + global.App.Config.Settings.Application.Port)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>UseGin()<br>&#125;<br></code></pre></td></tr></table></figure><p>执行<code>go run main.go</code>,项目启动后，服务器监听的端口为配置文件中的端口号。</p><h3 id="日志初始化"><a href="#日志初始化" class="headerlink" title="日志初始化"></a>日志初始化</h3><p>日志是框架中必不可少的，平时代码调试，线上 Bug 分析都离不开它。这里将使用 <a href="https://github.com/gookit/slog">slog</a> 作为日志库。</p><h4 id="安装slog库"><a href="#安装slog库" class="headerlink" title="安装slog库"></a>安装slog库</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u github.com/gookit/slog<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>gin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go语言的slog日志库</title>
    <link href="/2023/01/31/go%E8%AF%AD%E8%A8%80%E7%9A%84slog%E6%97%A5%E5%BF%97%E5%BA%93/"/>
    <url>/2023/01/31/go%E8%AF%AD%E8%A8%80%E7%9A%84slog%E6%97%A5%E5%BF%97%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="go语言中的slog日志库"><a href="#go语言中的slog日志库" class="headerlink" title="go语言中的slog日志库"></a>go语言中的slog日志库</h2><h3 id="下载安装slog库"><a href="#下载安装slog库" class="headerlink" title="下载安装slog库:"></a>下载安装slog库:</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br>  <span class="hljs-string">&quot;github.com/gookit/slog&quot;</span><br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2023/01/31/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/01/31/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><h3 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h3><p><strong>轻量标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git tag v1.0.0<br></code></pre></td></tr></table></figure><p><strong>附注标签</strong>（为附注标签指定一条信息）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git tag -a v1.0.0 -m &#x27;version 1.0.0&#x27;<br></code></pre></td></tr></table></figure><p><strong>后期打标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs git">获取历史提交记录：<br>git log --pretty=oneline<br>补上标签：<br>git tag -a v1.0.0 9fceb02(校验和)<br></code></pre></td></tr></table></figure><p><strong>列出标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git tag<br>git tag -l<br>git tag --list<br></code></pre></td></tr></table></figure><p><strong>推送标签到github</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">git push origin tagname--推送单个标签<br>git push origin --tags--推送多个标签<br></code></pre></td></tr></table></figure><p><strong>删除标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">git tag -d v1.0.0    --删除本地标签<br>git push origin --delete v1.0.0    --删除远程标签<br>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;    --删除远程标签<br></code></pre></td></tr></table></figure><p><strong>检出标签</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git checkout v1.0.0<br></code></pre></td></tr></table></figure><h3 id="忽略某些不想提交的文件"><a href="#忽略某些不想提交的文件" class="headerlink" title="忽略某些不想提交的文件"></a>忽略某些不想提交的文件</h3><p><strong>在项目目录下创建.gitignore文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim .gitignore<br></code></pre></td></tr></table></figure><p>添加忽略的文件名或后缀</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">.idea<br>.gitignore<br>*.iml<br></code></pre></td></tr></table></figure><p><strong>忽略文件已上传解决办法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs git"># 删除缓存<br>git rm -r --cache .<br><br># 查看状态<br>git status<br><br># 将更改提交到本地暂存区 <br>git add .<br><br># 提交本地库<br>git commit -m &#x27;忽略 .idea .gitignore *.iml&#x27;<br><br># 上传服务器<br>git push origin main<br></code></pre></td></tr></table></figure><h3 id="撤销commit"><a href="#撤销commit" class="headerlink" title="撤销commit"></a>撤销commit</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 撤销commit<br>git reset --soft HEAD^<br><br># 修改commit注释<br>git commit --amend<br></code></pre></td></tr></table></figure><p><strong>参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs git"># --mixed<br>不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数,git reset --mixed HEAD^ 和 git reset HEAD^ 效果是一样的<br><br># --soft<br>不删除工作空间改动代码，撤销commit，不撤销git add . <br><br># --hard<br>删除工作空间改动代码，撤销commit，撤销git add . <br>注意完成这个操作后，就恢复到了上一次的commit状态<br><br># HEAD^<br>HEAD^的意思是上一个版本，也可以写成HEAD~1<br>如果进行了2次commit，想都撤回，可以使用HEAD~2<br></code></pre></td></tr></table></figure><h3 id="恢复到指定版本"><a href="#恢复到指定版本" class="headerlink" title="恢复到指定版本"></a>恢复到指定版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git"># 查看提交日志<br>git log<br><br># 恢复到指定版本<br>git reset --hard 版本号<br></code></pre></td></tr></table></figure><h3 id="撤销远程仓库的commit"><a href="#撤销远程仓库的commit" class="headerlink" title="撤销远程仓库的commit"></a>撤销远程仓库的commit</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs git"># 查看历史commit版本号<br>git log<br><br># 恢复到想要恢复的版本号<br>git reset --hard 版本号<br><br># 提交到远程仓库<br>git push origin branch_name --force<br></code></pre></td></tr></table></figure><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs git"># 本地创建分支 推送到远程仓库<br>git push --set-upstream origin branch_name<br><br># 远程创建分支 连接到本地分支<br>git fetch<br>git checkout -b branch_name origin/branch_name<br><br># 查看本地分支与远程分支连接情况<br>git branch -vv<br><br># 删除分支<br>git branch -b branch_name<br><br># 查看远程分支<br>git branch -r<br><br># 查看所有分支（远程+本地）<br>git branch -a<br></code></pre></td></tr></table></figure><h3 id="本地仓库连接远程仓库"><a href="#本地仓库连接远程仓库" class="headerlink" title="本地仓库连接远程仓库"></a>本地仓库连接远程仓库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs git">给目标文件夹连接到目标仓库<br>git remote add origin + ssh/https <br><br># 查看连接情况<br>git remote -v 查看连接情况<br><br># 移除已存在的远程仓库连接<br>git remote rm origin<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go读写csv文件</title>
    <link href="/2023/01/30/go%E8%AF%BB%E5%86%99csv%E6%96%87%E4%BB%B6/"/>
    <url>/2023/01/30/go%E8%AF%BB%E5%86%99csv%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="go读写csv文件"><a href="#go读写csv文件" class="headerlink" title="go读写csv文件"></a>go读写csv文件</h2><h3 id="使用依赖库"><a href="#使用依赖库" class="headerlink" title="使用依赖库"></a>使用依赖库</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br>  <span class="hljs-string">&quot;encoding/csv&quot;</span><br>)<br></code></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p><strong>打开一个csv文件并声明一个csv.Reader对象</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">file, err := os.Open(<span class="hljs-string">&quot;foo.csv&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>reader := csv.NewReader(file)<br></code></pre></td></tr></table></figure><p><strong>使用<code>csv.Reader.Read</code>来读取一行数据</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">row, err := reader.Read()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>fmt.Println(row)<br></code></pre></td></tr></table></figure><p><strong>使用<code>csv.Reader.ReadAll</code>读取所有行</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">rows, err := reader.ReadAll()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> rows &#123;<br>fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p><strong>创建一个csv文件并声明一个<code>csv.NewWriter</code>对象</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">file, err := os.Create(<span class="hljs-string">&quot;test.csv&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>writer := csv.NewWriter(file)<br></code></pre></td></tr></table></figure><p><strong>控制csv文件中的字段分隔符</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">write.Comma = <span class="hljs-string">&#x27;,&#x27;</span><br></code></pre></td></tr></table></figure><p><strong>使用<code>csv.Writer.Write</code>来写入一行数据</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">err = write.Write([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;nihao&quot;</span>, <span class="hljs-string">&quot;ok~&quot;</span>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>调用<code>csv.Writer.Flush</code>才能完成将数据写入文件中</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">write.Flush()<br></code></pre></td></tr></table></figure><p><strong>使用<code>csv.Writer.WriteAll</code>来进行多行写入</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">err = write.WriteAll([][]<span class="hljs-type">string</span>&#123;<br>&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;line1&quot;</span>, <span class="hljs-string">&quot;ok~&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;line2&quot;</span>, <span class="hljs-string">&quot;ok~&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;line3&quot;</span>, <span class="hljs-string">&quot;ok~&quot;</span>&#125;,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>write.Flush()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>csv文件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令随记</title>
    <link href="/2023/01/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9A%8F%E8%AE%B0/"/>
    <url>/2023/01/30/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9A%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux系统中常用的终端命令"><a href="#Linux系统中常用的终端命令" class="headerlink" title="Linux系统中常用的终端命令"></a>Linux系统中常用的终端命令</h2><h4 id="删除：rm"><a href="#删除：rm" class="headerlink" title="删除：rm"></a>删除：rm</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf abc/def.log<br>rm -f abc/def.log<br>删除多个文件:<br>rm -rf abc/a.txt abc/b.txt<br></code></pre></td></tr></table></figure><ul><li>-i 删除前逐一询问确认。</li><li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。</li><li>-r 将目录及以下之档案亦逐一删除。</li></ul><h4 id="复制：cp"><a href="#复制：cp" class="headerlink" title="复制：cp"></a>复制：cp</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">将当前目录test/下的所有文件复制到新目录newtest下:<br>cp -r test/ newtest<br></code></pre></td></tr></table></figure><ul><li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</li><li>-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。</li><li>-f：覆盖已经存在的目标文件而不给出提示。</li><li>-i：与 <strong>-f</strong> 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 <strong>y</strong> 时目标文件将被覆盖。</li><li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</li><li>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</li><li>-l：不复制文件，只是生成链接文件。</li></ul><div class="note note-danger">            <p>用户使用该指令复制目录时，必须使用参数 <strong>-r</strong> 或者 <strong>-R</strong> 。</p>          </div><h4 id="重命名与移动：mv"><a href="#重命名与移动：mv" class="headerlink" title="重命名与移动：mv"></a>重命名与移动：mv</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">将原文件名改为新文件名:<br>mv old_name(文件) new_name(文件)<br>将file_name文件移动到directory目录中:<br>mv file_name(文件) directory(目录)<br>若new_directory目录不存在，将old_directory重命名为new_directory;若new_directory目录已存在，将old_directory移动到new_directory目录下:<br>mv old_directory(目录) new_directory(目录)<br></code></pre></td></tr></table></figure><ul><li><strong>-b</strong>: 当目标文件或目录存在时，在执行覆盖前，会为其创建一个备份。</li><li><strong>-i</strong>: 如果指定移动的源目录或文件与目标的目录或文件同名，则会先询问是否覆盖旧文件，输入 y 表示直接覆盖，输入 n 表示取消该操作。</li><li><strong>-f</strong>: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。</li><li><strong>-n</strong>: 不要覆盖任何已存在的文件或目录。</li><li><strong>-u</strong>：当源文件比目标文件新或者目标文件不存在时，才执行移动操作。</li></ul><h4 id="服务器与本地计算机之间互相传送文件：scp"><a href="#服务器与本地计算机之间互相传送文件：scp" class="headerlink" title="服务器与本地计算机之间互相传送文件：scp"></a>服务器与本地计算机之间互相传送文件：scp</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">远程服务器-&gt;本地:<br>scp ubuntu@xx.xxx.xxx.xx:/home/ubuntu/a.log /home/space<br>本地-&gt;远程服务器:<br>scp /home/space/a.txt ubuntu@xx.xxx.xxx.xx:/home/ubuntu/space<br></code></pre></td></tr></table></figure><h4 id="新建文件、文件夹"><a href="#新建文件、文件夹" class="headerlink" title="新建文件、文件夹"></a>新建文件、文件夹</h4><p><strong>touch、mkdir</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch file.txt    --新建.txt文件<br>mkdir file    --新建文件夹<br></code></pre></td></tr></table></figure><p><strong>重定向操作符创建文件</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">file.txt    --文件不存在则创建，存在则覆盖</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt; file.txt    --文件不存在则创建，存在则添加到已存在的文件中</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker学习、使用笔记</title>
    <link href="/2022/10/27/docker%E5%AD%A6%E4%B9%A0%E3%80%81%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/27/docker%E5%AD%A6%E4%B9%A0%E3%80%81%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="docker学习、使用笔记"><a href="#docker学习、使用笔记" class="headerlink" title="docker学习、使用笔记"></a>docker学习、使用笔记</h2><p><a href="https://zhuanlan.zhihu.com/p/576172727">参考网站</a></p><p><a href="https://zhuanlan.zhihu.com/p/26418829">使用docker部署一个Web应用</a></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux查看进程</title>
    <link href="/2022/10/27/Linux%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B/"/>
    <url>/2022/10/27/Linux%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="Linux查看进程命令"><a href="#Linux查看进程命令" class="headerlink" title="Linux查看进程命令"></a>Linux查看进程命令</h3>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tmux工具</title>
    <link href="/2022/10/26/Tmux%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/10/26/Tmux%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="Tmux工具的学习使用"><a href="#Tmux工具的学习使用" class="headerlink" title="Tmux工具的学习使用"></a>Tmux工具的学习使用</h2><p>在服务器上测试demo的时候，需要后台挂起服务，方便查看项目运行情况，学习了一下tmux。</p><p>参考网站：<a href="https://zhuanlan.zhihu.com/p/102546608">知乎</a>、<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">阮一峰的博客</a></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>Tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法与数据数据结构C语言实现</title>
    <link href="/2022/10/24/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/10/24/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言基础学习笔记</title>
    <link href="/2022/10/20/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/20/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="从头捡起C语言"><a href="#从头捡起C语言" class="headerlink" title="从头捡起C语言"></a>从头捡起C语言</h2><p>开始刷算法，准备先过一遍数据结构与算法这门课程。发现大部分书籍都是用C语言实现的，而Go语言的书很少有，找到的一些电子书也不够完善，所以重学一遍C语言，先学一遍数据结构与算法，再来系统的刷题。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>全局变量保存在内存的全局存储区中，占用静态的存储单元</li><li>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元</li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="static关键字的使用"><a href="#static关键字的使用" class="headerlink" title="static关键字的使用"></a>static关键字的使用</h3><ul><li>局部变量的修饰符<br>通常是在某个函数体内，只能在该函数内被调用。<br>这样定义的变量通常被称为局部静态变量，它的值不会因为函数调用的结束而被清除，当函数再次被调用时，它的值是上一次调用结束后的值。<br>局部静态变量存储在静态存储区。</li><li>全局变量的修饰符<br>在某一个文件中，不属于任何一个函数。<br>这样定义的变量通常被称为静态全局变量。</li><li>用于函数的修饰符<br>关键字 static 还可以用于修饰一个函数，这样的函数称之为静态函数。<br>定义一个静态函数就是在函数的返回类型前加上 static 关键字。<br>静态函数的作用域仅限于本文件，不能被其它文件调用。</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><strong>枚举是c语言的一种基本数据类型</strong></p><p>声明一个枚举类型：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">enum 枚举名&#123;枚举元素1,枚举元素2...&#125;;<br></code></pre></td></tr></table></figure><p>定义一个枚举变量：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">//先声明枚举类型再定义枚举变量</span><br><span class="hljs-keyword">enum</span> 枚举名&#123;枚举元素<span class="hljs-number">1</span>,枚举元素<span class="hljs-number">2.</span>..&#125;;<br><span class="hljs-keyword">enum</span> 枚举名 枚举变量;<br><span class="hljs-keyword">enum</span> DAY &#123;MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN&#125;;<br><span class="hljs-keyword">enum</span> DAY <span class="hljs-built_in">day</span>;<br><span class="hljs-comment">//省略枚举名称，直接定义枚举变量</span><br><span class="hljs-keyword">enum</span> &#123;MON=<span class="hljs-number">1</span>, TUE, WED, THU, FRI, SAT, SUN&#125; <span class="hljs-built_in">day</span>;<br></code></pre></td></tr></table></figure><p>C语言中，不连续的枚举类型无法遍历。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针也就是内存地址，指针变量是用来存放内存地址的变量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//声明指针变量</span><br>type *p;<br><span class="hljs-comment">//指针变量赋值</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> *p;<br>p = &amp;a;<br>p -&gt; 一个十六进制内存地址<br>*p -&gt; p存储的十六进制内存地址所对应的值<br></code></pre></td></tr></table></figure><h4 id="C指针的算术运算"><a href="#C指针的算术运算" class="headerlink" title="C指针的算术运算"></a>C指针的算术运算</h4><p><strong>++、–、+、-</strong></p><ul><li><p>指针的每一次递增，它其实会指向下一个元素的存储单元。</p></li><li><p>指针的每一次递减，它都会指向前一个元素的存储单元。</p></li><li><p>指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。</p></li></ul><h4 id="递增一个指针"><a href="#递增一个指针" class="headerlink" title="递增一个指针"></a>递增一个指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> var[] = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;;<br><span class="hljs-type">int</span> *p;<br>p = var;<span class="hljs-comment">/* 指针中的数组地址 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;var[%d]=%p\n&quot;</span>,i,p);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;var[%d]=%d\n&quot;</span>,i,*p);<br><br>p++;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="递减一个指针"><a href="#递减一个指针" class="headerlink" title="递减一个指针"></a>递减一个指针</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> var[] = &#123;<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>&#125;;<br><span class="hljs-type">int</span> *p;<br>p = &amp;var[<span class="hljs-number">2</span>];<span class="hljs-comment">/* 指针中最后一个元素的地址 */</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;var[%d]=%p\n&quot;</span>,i,p);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;var[%d]=%d\n&quot;</span>,i,*p);<br>  <br>  p--;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="指针的比较"><a href="#指针的比较" class="headerlink" title="指针的比较"></a>指针的比较</h4><p>指针可以使用关系运算符进行比较，例如<span class="label label-primary">==</span>、<span class="label label-primary"><</span>和<span class="label label-primary">></span>。</p><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim">//声明一个指针数组<br><span class="hljs-keyword">type</span> *<span class="hljs-keyword">ptr</span>[] = <span class="hljs-meta">&#123;...&#125;</span>;<br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>字符串实际上是使用空字符 \0 结尾的一维字符数组。因此，\0 是用于标记字符串的结束。</strong></p><p><strong>空字符（Null character</strong>）又称结束符，缩写 <strong>NUL</strong>，是一个数值为 <strong>0</strong> 的控制字符，<strong>\0</strong> 是转义字符，意思是告诉编译器，这不是字符 <strong>0</strong>，而是空字符。</p><p>下面的声明和初始化创建了一个 <strong>RUNOOB</strong> 字符串。由于在数组的末尾存储了空字符 <strong>\0</strong>，所以字符数组的大小比单词 <strong>RUNOOB</strong> 的字符数多一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> site[<span class="hljs-number">7</span>] = &#123;<span class="hljs-string">&#x27;R&#x27;</span>, <span class="hljs-string">&#x27;U&#x27;</span>, <span class="hljs-string">&#x27;N&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br></code></pre></td></tr></table></figure><p>依据数组初始化规则，您可以把上面的语句写成以下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> site[] = <span class="hljs-string">&quot;RUNOOB&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="操作字符串的函数"><a href="#操作字符串的函数" class="headerlink" title="操作字符串的函数"></a>操作字符串的函数</h4><div class="note note-info">            <p><strong>strcpy(s1, s2);</strong></p><p>复制字符串 s2 到字符串 s1</p>          </div><div class="note note-info">            <p><strong>strcat(s1, s2);</strong></p><p>连接字符串 s2 到字符串 s1 的末尾</p>          </div><div class="note note-info">            <p><strong>strlen(s1);</strong></p><p>返回字符串 s1 的长度</p>          </div><div class="note note-info">            <p><strong>strcmp(s1,s2);</strong></p><p>如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</p>          </div><div class="note note-info">            <p><strong>strchr(s1,ch);</strong></p><p>返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。(截取ch及后面的字符)</p>          </div><div class="note note-info">            <p><strong>strstr(s1,s2);</strong></p><p>返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</p>          </div><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p><strong>C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</strong></p><h4 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h4><p>为了定义结构，您必须使用 <strong>struct</strong> 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">struct tag &#123; <br><span class="hljs-code">    member-list</span><br><span class="hljs-code">    member-list </span><br><span class="hljs-code">    member-list  </span><br><span class="hljs-code">    ...</span><br><span class="hljs-code">&#125; variable-list ;</span><br><span class="hljs-code">//tag 是结构体标签。</span><br><span class="hljs-code">//member-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。</span><br><span class="hljs-code">//variable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Books</span>&#123;</span><br><span class="hljs-type">char</span> title[<span class="hljs-number">50</span>];<br><span class="hljs-type">char</span> author[<span class="hljs-number">50</span>];<br><span class="hljs-type">char</span> subject[<span class="hljs-number">100</span>];<br><span class="hljs-type">int</span> book_id;<br>&#125; book;<br></code></pre></td></tr></table></figure><h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p><strong>共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。</strong></p><h4 id="定义共用体"><a href="#定义共用体" class="headerlink" title="定义共用体"></a>定义共用体</h4><p>为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> [<span class="hljs-title">union</span> <span class="hljs-title">tag</span>]</span><br><span class="hljs-class">&#123;</span><br>   member definition;<br>   member definition;<br>   ...<br>   member definition;<br>&#125; [one or more <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">variables</span>];</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">Data</span>&#123;</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-type">float</span> f;<br><span class="hljs-type">char</span> str[<span class="hljs-number">20</span>];<br>&#125; data;<br></code></pre></td></tr></table></figure><p>访问共用体成员，使用成员运算符<span class="label label-info">(.)</span></p><div class="note note-warning">            <p>在同一时间，只能使用一个类型的成员变量，否则会造成数据损坏。</p>          </div><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> BYTE;<br></code></pre></td></tr></table></figure><p>在这个类型定义之后，标识符 BYTE 可作为类型 <strong>unsigned char</strong> 的缩写，例如：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">BYTE</span> b1,b2;<br></code></pre></td></tr></table></figure><p>（按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但也可以使用小写字母。）</p><p>可以使用 <strong>typedef</strong> 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Books</span>&#123;<span class="hljs-comment">//typedef给结构体Books定义新数据类型名称Book</span><br><span class="hljs-type">char</span> title[<span class="hljs-number">50</span>];<br><span class="hljs-type">char</span> author[<span class="hljs-number">50</span>];<br><span class="hljs-type">char</span> subject[<span class="hljs-number">50</span>];<br><span class="hljs-type">int</span> book_id;<br>&#125;Book;<br>Book book;<span class="hljs-comment">//使用新数据类型名称Book定义变量book</span><br></code></pre></td></tr></table></figure><h4 id="typedef-与-define"><a href="#typedef-与-define" class="headerlink" title="typedef 与 #define"></a>typedef 与 #define</h4><p><strong>#define</strong> 是 C 指令，用于为各种数据类型定义别名，与 <strong>typedef</strong> 类似，但是它们有以下几点不同：</p><ul><li><p><strong>typedef</strong> 仅限于为类型定义符号名称，**#define** 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。</p></li><li><p><strong>typedef</strong> 是由编译器执行解释的，**#define** 语句是由预编译器进行处理的。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo fluid个人使用笔记</title>
    <link href="/2022/10/20/hexo-fluid%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/20/hexo-fluid%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>在Hexo+Fiuld主题搭建的个人博客使用过程中，根据用户手册，记录一些个人使用笔记。</strong></p><h3 id="修改页面图片"><a href="#修改页面图片" class="headerlink" title="修改页面图片"></a>修改页面图片</h3><p>在<code>_config.fluid.yml</code>文件中，修改对应页面的<code>banner_img</code>，图片需要保存在<code>/source/img</code>文件夹下。</p><h3 id="关闭版权声明"><a href="#关闭版权声明" class="headerlink" title="关闭版权声明"></a>关闭版权声明</h3><p>,轻度强迫症，感觉文章下面的版权声明看着十分难受，就关掉了</p><p><img src="/img/post_img/5-1.png"></p><p>在<code>_config.fluid.yml</code>文件中，<code>copyright</code>的<code>enable</code>改为<code>false</code></p><h3 id="关闭终端运行hexo命令时的效果"><a href="#关闭终端运行hexo命令时的效果" class="headerlink" title="关闭终端运行hexo命令时的效果"></a>关闭终端运行hexo命令时的效果</h3><p>关闭如下效果</p><p><img src="/img/post_img/5-2.png"></p><p>将博客目录文件夹的<code>node_modules/hexo-theme-fluid/scripts/events/lib/hello.js</code>文件中的对应效果删除即可</p><h3 id="Tag插件"><a href="#Tag插件" class="headerlink" title="Tag插件"></a>Tag插件</h3><p><strong>便签</strong></p><p>在 markdown 中加入如下的代码来使用便签：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% note success %&#125;<br>文字 或者 <span class="hljs-code">`markdown`</span> 均可<br>&#123;% endnote %&#125;<br></code></pre></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;note note-primary&quot;</span>&gt;</span>标签<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可选便签：</p><div class="note note-primary">            <p>primary</p>          </div><div class="note note-secondary">            <p>secondary</p>          </div><div class="note note-success">            <p>success</p>          </div><div class="note note-danger">            <p>danger</p>          </div><div class="note note-warning">            <p>warning</p>          </div><div class="note note-info">            <p>info</p>          </div><div class="note note-light">            <p>light</p>          </div><p><strong>行内标签</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">&#123;% label primary @text %&#125;<br></code></pre></td></tr></table></figure><p>或者使用 HTML 形式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;label label-primary&quot;</span>&gt;</span>Label<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可选Label</p><span class="label label-primary">primary</span> <span class="label label-default">default</span> <span class="label label-info">info</span><span class="label label-success">success</span> <span class="label label-warning">warning</span> <span class="label label-danger">danger</span>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fiuld</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用图片作为文章标题</title>
    <link href="/2022/10/19/%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87%E4%BD%9C%E4%B8%BA%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/"/>
    <url>/2022/10/19/%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87%E4%BD%9C%E4%B8%BA%E6%96%87%E7%AB%A0%E6%A0%87%E9%A2%98/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fiuld</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu搭建Jenkins环境自动发布Go项目</title>
    <link href="/2022/10/19/ubuntu%E6%90%AD%E5%BB%BAJenkins%E7%8E%AF%E5%A2%83%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83Go%E9%A1%B9%E7%9B%AE/"/>
    <url>/2022/10/19/ubuntu%E6%90%AD%E5%BB%BAJenkins%E7%8E%AF%E5%A2%83%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83Go%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="ubuntu搭建Jenkins环境"><a href="#ubuntu搭建Jenkins环境" class="headerlink" title="ubuntu搭建Jenkins环境"></a>ubuntu搭建Jenkins环境</h3><ul><li>安装Java<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt update<br>$ sudo apt install openjdk-11-jdk<br>$ java -version<br>//自Jenkins 2.357 和 LTS 2.361.1 起，Jenkins 需要 Java 11 或 17<br></code></pre></td></tr></table></figure></li></ul><div class="note note-success">            <p>文字 或者 <code>markdown</code> 均可</p>          </div>]]></content>
    
    
    <categories>
      
      <category>搭建环境</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
      <tag>Jenkins</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo使用Fluid主题</title>
    <link href="/2022/10/19/hexo%E4%BD%BF%E7%94%A8Fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2022/10/19/hexo%E4%BD%BF%E7%94%A8Fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>Fluid 是基于 Hexo 的一款 Material Design 风格的主题，由 <a href="https://github.com/fluid-dev">Fluid-dev (opens new window)</a>负责开发与维护。</p><p>主题 GitHub: <a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>预览网站：<a href="https://hexo.fluid-dev.com/">Fluid’s blog (opens new window)</a><a href="https://zkqiang.cn/">zkqiang’s blog</a></p><h3 id="搭建hexo博客"><a href="#搭建hexo博客" class="headerlink" title="搭建hexo博客"></a>搭建hexo博客</h3><p>先安装hexo，搭建hexo博客网站</p><h3 id="获取主题"><a href="#获取主题" class="headerlink" title="获取主题"></a>获取主题</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><h3 id="选择hexo主题"><a href="#选择hexo主题" class="headerlink" title="选择hexo主题"></a>选择hexo主题</h3><p>如下修改Hexo博客目录中的的<code>_config.yml</code>文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment">#指定主题</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment">#指定语言</span><br></code></pre></td></tr></table></figure><h3 id="创建「关于页」"><a href="#创建「关于页」" class="headerlink" title="创建「关于页」"></a>创建「关于页」</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ hexo n page about<br></code></pre></td></tr></table></figure><p>然后修改<code>/source/about/index.md</code>文件，添加<code>layout</code>属性</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">标题</span><br><span class="hljs-attr">layout:</span> <span class="hljs-string">about</span><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-string">这里填写你想在about页展示的内容</span><br></code></pre></td></tr></table></figure><blockquote><p>WARNING</p><p><code>layout: about</code>必须存在，并且不能修改成其他值，否则不会显示头像等样式。</p></blockquote><h2 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h2><p><strong>方式一</strong></p><blockquote><p>适用于通过npm安装主题</p></blockquote><p>在博客目录下执行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ npm update --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p><strong>方式二</strong></p><blockquote><p>适用于通过Release压缩包安装主题，且没有自行修改任何代码的情况</p></blockquote><ol><li>先将原文件夹重命名为别的名称，例如 <code>fluid-bkp</code>，用于升级失败进行回退；</li><li>按照安装步骤，重新下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">release (opens new window)</a>并解压重命名为 <code>fluid</code>；</li><li>如果某些配置发生了变化（改名或弃用），release 的说明里会特别提示，同步修改原配置文件即可。</li></ol><p><strong>方式三</strong></p><blockquote><p>适用于自定义了一些代码 ，或想体验其他分支的情况，以 dev 分支为例。</p></blockquote><ol><li><p>确定自己的 fluid 目录已经开启 git，并且所有改动都已 commit；</p></li><li><p>把 fluid 仓库的 develop 分支拉取到自己当前的分支上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ git pull https://github.com/fluid-dev/hexo-theme-fluid.git develop<br></code></pre></td></tr></table></figure></li><li><p>解决代码冲突，保留自己修改的部分</p></li></ol><p>​                                                                         文章来源：<a href="https://hexo.fluid-dev.com/docs/">Hexo Fluid 用户手册</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fiuld</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/19/hello-world/"/>
    <url>/2022/10/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客。</p><h2 id="博客的搭建"><a href="#博客的搭建" class="headerlink" title="博客的搭建"></a>博客的搭建</h2><p>搭建博客网站使用的是hexo</p><h3 id="创建一个新文章"><a href="#创建一个新文章" class="headerlink" title="创建一个新文章"></a>创建一个新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Postname&quot;</span> 或 $ hexo n <span class="hljs-string">&quot;My New Postname&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="运行服务"><a href="#运行服务" class="headerlink" title="运行服务"></a>运行服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server 或 $ hexo s<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate 或 $ hexo g<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="部署到远程站点"><a href="#部署到远程站点" class="headerlink" title="部署到远程站点"></a>部署到远程站点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy 或 $ hexo d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>清除缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean 或 $ hexo c<br></code></pre></td></tr></table></figure><p><a href="https://hexo.io/docs/one-command-deployment.html">https://hexo.io/docs/one-command-deployment.html</a>)</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
